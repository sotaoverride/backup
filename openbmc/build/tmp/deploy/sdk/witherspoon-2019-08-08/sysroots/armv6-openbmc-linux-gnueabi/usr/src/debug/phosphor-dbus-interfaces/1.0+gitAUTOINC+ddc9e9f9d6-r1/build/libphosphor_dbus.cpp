#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/MemoryBuffer/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

MemoryBuffer::MemoryBuffer(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_MemoryBuffer_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t MemoryBuffer::_vtable[] = {vtable::start(),
                                                  vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Board/IOBoard/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace Board
{
namespace server
{

IOBoard::IOBoard(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Board_IOBoard_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t IOBoard::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Board
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Board/Motherboard/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace Board
{
namespace server
{

Motherboard::Motherboard(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Board_Motherboard_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Motherboard::_vtable[] = {vtable::start(),
                                                 vtable::end()};

} // namespace server
} // namespace Board
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/CpuCore/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

CpuCore::CpuCore(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_CpuCore_interface(bus, path, _interface,
                                                          _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t CpuCore::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Bmc/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Bmc::Bmc(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Bmc_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Bmc::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/NetworkInterface/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

NetworkInterface::NetworkInterface(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_NetworkInterface_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

NetworkInterface::NetworkInterface(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    NetworkInterface(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto NetworkInterface::mACAddress() const -> std::string
{
    return _mACAddress;
}

int NetworkInterface::_callback_get_MACAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<NetworkInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->mACAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto NetworkInterface::mACAddress(std::string value, bool skipSignal)
    -> std::string
{
    if (_mACAddress != value)
    {
        _mACAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_NetworkInterface_interface
                .property_changed("MACAddress");
        }
    }

    return _mACAddress;
}

auto NetworkInterface::mACAddress(std::string val) -> std::string
{
    return mACAddress(val, false);
}
int NetworkInterface::_callback_set_MACAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<NetworkInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->mACAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace NetworkInterface
{
static const auto _property_MACAddress =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void NetworkInterface::setPropertyByName(const std::string& _name,
                                         const PropertiesVariant& val,
                                         bool skipSignal)
{
    if (_name == "MACAddress")
    {
        auto& v = std::get<std::string>(val);
        mACAddress(v, skipSignal);
        return;
    }
}

auto NetworkInterface::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "MACAddress")
    {
        return mACAddress();
    }

    return PropertiesVariant();
}

const vtable::vtable_t NetworkInterface::_vtable[] = {
    vtable::start(),
    vtable::property("MACAddress",
                     details::NetworkInterface::_property_MACAddress.data(),
                     _callback_get_MACAddress, _callback_set_MACAddress,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Accelerator/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Accelerator::Accelerator(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Accelerator_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Accelerator::_vtable[] = {vtable::start(),
                                                 vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/System/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

System::System(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_System_interface(bus, path, _interface,
                                                         _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t System::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Dimm/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Dimm::Dimm(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Dimm_interface(bus, path, _interface,
                                                       _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Dimm::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Fan/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Fan::Fan(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Fan_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Fan::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Tpm/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Tpm::Tpm(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Tpm_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Tpm::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Cpu/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Cpu::Cpu(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Cpu_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Cpu::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Chassis/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Chassis::Chassis(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Chassis_interface(bus, path, _interface,
                                                          _vtable, this),
    _intf(bus.getInterface())
{
}

Chassis::Chassis(bus::bus& bus, const char* path,
                 const std::map<std::string, PropertiesVariant>& vals,
                 bool skipSignal) :
    Chassis(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Chassis::type() const -> std::string
{
    return _type;
}

int Chassis::_callback_get_Type(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* reply, void* context,
                                sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Chassis*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->type()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Chassis::type(std::string value, bool skipSignal) -> std::string
{
    if (_type != value)
    {
        _type = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_Chassis_interface
                .property_changed("Type");
        }
    }

    return _type;
}

auto Chassis::type(std::string val) -> std::string
{
    return type(val, false);
}
int Chassis::_callback_set_Type(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* value, void* context,
                                sd_bus_error* error)
{
    auto o = static_cast<Chassis*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->type(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Chassis
{
static const auto _property_Type =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Chassis::setPropertyByName(const std::string& _name,
                                const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Type")
    {
        auto& v = std::get<std::string>(val);
        type(v, skipSignal);
        return;
    }
}

auto Chassis::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Type")
    {
        return type();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Chassis::_vtable[] = {
    vtable::start(),
    vtable::property("Type", details::Chassis::_property_Type.data(),
                     _callback_get_Type, _callback_set_Type,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Board/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Board::Board(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Board_interface(bus, path, _interface,
                                                        _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Board::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/PowerSupply/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

PowerSupply::PowerSupply(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_PowerSupply_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t PowerSupply::_vtable[] = {vtable::start(),
                                                 vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/PCIeDevice/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

PCIeDevice::PCIeDevice(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

PCIeDevice::PCIeDevice(bus::bus& bus, const char* path,
                       const std::map<std::string, PropertiesVariant>& vals,
                       bool skipSignal) :
    PCIeDevice(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto PCIeDevice::deviceType() const -> std::string
{
    return _deviceType;
}

int PCIeDevice::_callback_get_DeviceType(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->deviceType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::deviceType(std::string value, bool skipSignal) -> std::string
{
    if (_deviceType != value)
    {
        _deviceType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("DeviceType");
        }
    }

    return _deviceType;
}

auto PCIeDevice::deviceType(std::string val) -> std::string
{
    return deviceType(val, false);
}
int PCIeDevice::_callback_set_DeviceType(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->deviceType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_DeviceType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function0ClassCode() const -> std::string
{
    return _function0ClassCode;
}

int PCIeDevice::_callback_get_Function0ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function0ClassCode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function0ClassCode(std::string value, bool skipSignal)
    -> std::string
{
    if (_function0ClassCode != value)
    {
        _function0ClassCode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function0ClassCode");
        }
    }

    return _function0ClassCode;
}

auto PCIeDevice::function0ClassCode(std::string val) -> std::string
{
    return function0ClassCode(val, false);
}
int PCIeDevice::_callback_set_Function0ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function0ClassCode(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function0ClassCode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function0DeviceClass() const -> std::string
{
    return _function0DeviceClass;
}

int PCIeDevice::_callback_get_Function0DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function0DeviceClass()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function0DeviceClass(std::string value, bool skipSignal)
    -> std::string
{
    if (_function0DeviceClass != value)
    {
        _function0DeviceClass = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function0DeviceClass");
        }
    }

    return _function0DeviceClass;
}

auto PCIeDevice::function0DeviceClass(std::string val) -> std::string
{
    return function0DeviceClass(val, false);
}
int PCIeDevice::_callback_set_Function0DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function0DeviceClass(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function0DeviceClass =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function0DeviceId() const -> std::string
{
    return _function0DeviceId;
}

int PCIeDevice::_callback_get_Function0DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function0DeviceId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function0DeviceId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function0DeviceId != value)
    {
        _function0DeviceId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function0DeviceId");
        }
    }

    return _function0DeviceId;
}

auto PCIeDevice::function0DeviceId(std::string val) -> std::string
{
    return function0DeviceId(val, false);
}
int PCIeDevice::_callback_set_Function0DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function0DeviceId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function0DeviceId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function0FunctionType() const -> std::string
{
    return _function0FunctionType;
}

int PCIeDevice::_callback_get_Function0FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function0FunctionType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function0FunctionType(std::string value, bool skipSignal)
    -> std::string
{
    if (_function0FunctionType != value)
    {
        _function0FunctionType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function0FunctionType");
        }
    }

    return _function0FunctionType;
}

auto PCIeDevice::function0FunctionType(std::string val) -> std::string
{
    return function0FunctionType(val, false);
}
int PCIeDevice::_callback_set_Function0FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function0FunctionType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function0FunctionType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function0RevisionId() const -> std::string
{
    return _function0RevisionId;
}

int PCIeDevice::_callback_get_Function0RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function0RevisionId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function0RevisionId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function0RevisionId != value)
    {
        _function0RevisionId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function0RevisionId");
        }
    }

    return _function0RevisionId;
}

auto PCIeDevice::function0RevisionId(std::string val) -> std::string
{
    return function0RevisionId(val, false);
}
int PCIeDevice::_callback_set_Function0RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function0RevisionId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function0RevisionId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function0SubsystemId() const -> std::string
{
    return _function0SubsystemId;
}

int PCIeDevice::_callback_get_Function0SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function0SubsystemId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function0SubsystemId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function0SubsystemId != value)
    {
        _function0SubsystemId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function0SubsystemId");
        }
    }

    return _function0SubsystemId;
}

auto PCIeDevice::function0SubsystemId(std::string val) -> std::string
{
    return function0SubsystemId(val, false);
}
int PCIeDevice::_callback_set_Function0SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function0SubsystemId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function0SubsystemId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function0SubsystemVendorId() const -> std::string
{
    return _function0SubsystemVendorId;
}

int PCIeDevice::_callback_get_Function0SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function0SubsystemVendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function0SubsystemVendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function0SubsystemVendorId != value)
    {
        _function0SubsystemVendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function0SubsystemVendorId");
        }
    }

    return _function0SubsystemVendorId;
}

auto PCIeDevice::function0SubsystemVendorId(std::string val) -> std::string
{
    return function0SubsystemVendorId(val, false);
}
int PCIeDevice::_callback_set_Function0SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function0SubsystemVendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function0SubsystemVendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function0VendorId() const -> std::string
{
    return _function0VendorId;
}

int PCIeDevice::_callback_get_Function0VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function0VendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function0VendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function0VendorId != value)
    {
        _function0VendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function0VendorId");
        }
    }

    return _function0VendorId;
}

auto PCIeDevice::function0VendorId(std::string val) -> std::string
{
    return function0VendorId(val, false);
}
int PCIeDevice::_callback_set_Function0VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function0VendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function0VendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function1ClassCode() const -> std::string
{
    return _function1ClassCode;
}

int PCIeDevice::_callback_get_Function1ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function1ClassCode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function1ClassCode(std::string value, bool skipSignal)
    -> std::string
{
    if (_function1ClassCode != value)
    {
        _function1ClassCode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function1ClassCode");
        }
    }

    return _function1ClassCode;
}

auto PCIeDevice::function1ClassCode(std::string val) -> std::string
{
    return function1ClassCode(val, false);
}
int PCIeDevice::_callback_set_Function1ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function1ClassCode(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function1ClassCode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function1DeviceClass() const -> std::string
{
    return _function1DeviceClass;
}

int PCIeDevice::_callback_get_Function1DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function1DeviceClass()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function1DeviceClass(std::string value, bool skipSignal)
    -> std::string
{
    if (_function1DeviceClass != value)
    {
        _function1DeviceClass = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function1DeviceClass");
        }
    }

    return _function1DeviceClass;
}

auto PCIeDevice::function1DeviceClass(std::string val) -> std::string
{
    return function1DeviceClass(val, false);
}
int PCIeDevice::_callback_set_Function1DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function1DeviceClass(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function1DeviceClass =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function1DeviceId() const -> std::string
{
    return _function1DeviceId;
}

int PCIeDevice::_callback_get_Function1DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function1DeviceId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function1DeviceId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function1DeviceId != value)
    {
        _function1DeviceId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function1DeviceId");
        }
    }

    return _function1DeviceId;
}

auto PCIeDevice::function1DeviceId(std::string val) -> std::string
{
    return function1DeviceId(val, false);
}
int PCIeDevice::_callback_set_Function1DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function1DeviceId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function1DeviceId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function1FunctionType() const -> std::string
{
    return _function1FunctionType;
}

int PCIeDevice::_callback_get_Function1FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function1FunctionType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function1FunctionType(std::string value, bool skipSignal)
    -> std::string
{
    if (_function1FunctionType != value)
    {
        _function1FunctionType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function1FunctionType");
        }
    }

    return _function1FunctionType;
}

auto PCIeDevice::function1FunctionType(std::string val) -> std::string
{
    return function1FunctionType(val, false);
}
int PCIeDevice::_callback_set_Function1FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function1FunctionType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function1FunctionType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function1RevisionId() const -> std::string
{
    return _function1RevisionId;
}

int PCIeDevice::_callback_get_Function1RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function1RevisionId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function1RevisionId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function1RevisionId != value)
    {
        _function1RevisionId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function1RevisionId");
        }
    }

    return _function1RevisionId;
}

auto PCIeDevice::function1RevisionId(std::string val) -> std::string
{
    return function1RevisionId(val, false);
}
int PCIeDevice::_callback_set_Function1RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function1RevisionId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function1RevisionId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function1SubsystemId() const -> std::string
{
    return _function1SubsystemId;
}

int PCIeDevice::_callback_get_Function1SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function1SubsystemId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function1SubsystemId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function1SubsystemId != value)
    {
        _function1SubsystemId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function1SubsystemId");
        }
    }

    return _function1SubsystemId;
}

auto PCIeDevice::function1SubsystemId(std::string val) -> std::string
{
    return function1SubsystemId(val, false);
}
int PCIeDevice::_callback_set_Function1SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function1SubsystemId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function1SubsystemId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function1SubsystemVendorId() const -> std::string
{
    return _function1SubsystemVendorId;
}

int PCIeDevice::_callback_get_Function1SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function1SubsystemVendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function1SubsystemVendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function1SubsystemVendorId != value)
    {
        _function1SubsystemVendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function1SubsystemVendorId");
        }
    }

    return _function1SubsystemVendorId;
}

auto PCIeDevice::function1SubsystemVendorId(std::string val) -> std::string
{
    return function1SubsystemVendorId(val, false);
}
int PCIeDevice::_callback_set_Function1SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function1SubsystemVendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function1SubsystemVendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function1VendorId() const -> std::string
{
    return _function1VendorId;
}

int PCIeDevice::_callback_get_Function1VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function1VendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function1VendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function1VendorId != value)
    {
        _function1VendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function1VendorId");
        }
    }

    return _function1VendorId;
}

auto PCIeDevice::function1VendorId(std::string val) -> std::string
{
    return function1VendorId(val, false);
}
int PCIeDevice::_callback_set_Function1VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function1VendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function1VendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function2ClassCode() const -> std::string
{
    return _function2ClassCode;
}

int PCIeDevice::_callback_get_Function2ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function2ClassCode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function2ClassCode(std::string value, bool skipSignal)
    -> std::string
{
    if (_function2ClassCode != value)
    {
        _function2ClassCode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function2ClassCode");
        }
    }

    return _function2ClassCode;
}

auto PCIeDevice::function2ClassCode(std::string val) -> std::string
{
    return function2ClassCode(val, false);
}
int PCIeDevice::_callback_set_Function2ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function2ClassCode(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function2ClassCode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function2DeviceClass() const -> std::string
{
    return _function2DeviceClass;
}

int PCIeDevice::_callback_get_Function2DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function2DeviceClass()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function2DeviceClass(std::string value, bool skipSignal)
    -> std::string
{
    if (_function2DeviceClass != value)
    {
        _function2DeviceClass = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function2DeviceClass");
        }
    }

    return _function2DeviceClass;
}

auto PCIeDevice::function2DeviceClass(std::string val) -> std::string
{
    return function2DeviceClass(val, false);
}
int PCIeDevice::_callback_set_Function2DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function2DeviceClass(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function2DeviceClass =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function2DeviceId() const -> std::string
{
    return _function2DeviceId;
}

int PCIeDevice::_callback_get_Function2DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function2DeviceId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function2DeviceId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function2DeviceId != value)
    {
        _function2DeviceId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function2DeviceId");
        }
    }

    return _function2DeviceId;
}

auto PCIeDevice::function2DeviceId(std::string val) -> std::string
{
    return function2DeviceId(val, false);
}
int PCIeDevice::_callback_set_Function2DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function2DeviceId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function2DeviceId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function2FunctionType() const -> std::string
{
    return _function2FunctionType;
}

int PCIeDevice::_callback_get_Function2FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function2FunctionType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function2FunctionType(std::string value, bool skipSignal)
    -> std::string
{
    if (_function2FunctionType != value)
    {
        _function2FunctionType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function2FunctionType");
        }
    }

    return _function2FunctionType;
}

auto PCIeDevice::function2FunctionType(std::string val) -> std::string
{
    return function2FunctionType(val, false);
}
int PCIeDevice::_callback_set_Function2FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function2FunctionType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function2FunctionType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function2RevisionId() const -> std::string
{
    return _function2RevisionId;
}

int PCIeDevice::_callback_get_Function2RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function2RevisionId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function2RevisionId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function2RevisionId != value)
    {
        _function2RevisionId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function2RevisionId");
        }
    }

    return _function2RevisionId;
}

auto PCIeDevice::function2RevisionId(std::string val) -> std::string
{
    return function2RevisionId(val, false);
}
int PCIeDevice::_callback_set_Function2RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function2RevisionId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function2RevisionId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function2SubsystemId() const -> std::string
{
    return _function2SubsystemId;
}

int PCIeDevice::_callback_get_Function2SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function2SubsystemId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function2SubsystemId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function2SubsystemId != value)
    {
        _function2SubsystemId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function2SubsystemId");
        }
    }

    return _function2SubsystemId;
}

auto PCIeDevice::function2SubsystemId(std::string val) -> std::string
{
    return function2SubsystemId(val, false);
}
int PCIeDevice::_callback_set_Function2SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function2SubsystemId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function2SubsystemId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function2SubsystemVendorId() const -> std::string
{
    return _function2SubsystemVendorId;
}

int PCIeDevice::_callback_get_Function2SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function2SubsystemVendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function2SubsystemVendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function2SubsystemVendorId != value)
    {
        _function2SubsystemVendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function2SubsystemVendorId");
        }
    }

    return _function2SubsystemVendorId;
}

auto PCIeDevice::function2SubsystemVendorId(std::string val) -> std::string
{
    return function2SubsystemVendorId(val, false);
}
int PCIeDevice::_callback_set_Function2SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function2SubsystemVendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function2SubsystemVendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function2VendorId() const -> std::string
{
    return _function2VendorId;
}

int PCIeDevice::_callback_get_Function2VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function2VendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function2VendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function2VendorId != value)
    {
        _function2VendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function2VendorId");
        }
    }

    return _function2VendorId;
}

auto PCIeDevice::function2VendorId(std::string val) -> std::string
{
    return function2VendorId(val, false);
}
int PCIeDevice::_callback_set_Function2VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function2VendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function2VendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function3ClassCode() const -> std::string
{
    return _function3ClassCode;
}

int PCIeDevice::_callback_get_Function3ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function3ClassCode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function3ClassCode(std::string value, bool skipSignal)
    -> std::string
{
    if (_function3ClassCode != value)
    {
        _function3ClassCode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function3ClassCode");
        }
    }

    return _function3ClassCode;
}

auto PCIeDevice::function3ClassCode(std::string val) -> std::string
{
    return function3ClassCode(val, false);
}
int PCIeDevice::_callback_set_Function3ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function3ClassCode(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function3ClassCode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function3DeviceClass() const -> std::string
{
    return _function3DeviceClass;
}

int PCIeDevice::_callback_get_Function3DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function3DeviceClass()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function3DeviceClass(std::string value, bool skipSignal)
    -> std::string
{
    if (_function3DeviceClass != value)
    {
        _function3DeviceClass = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function3DeviceClass");
        }
    }

    return _function3DeviceClass;
}

auto PCIeDevice::function3DeviceClass(std::string val) -> std::string
{
    return function3DeviceClass(val, false);
}
int PCIeDevice::_callback_set_Function3DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function3DeviceClass(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function3DeviceClass =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function3DeviceId() const -> std::string
{
    return _function3DeviceId;
}

int PCIeDevice::_callback_get_Function3DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function3DeviceId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function3DeviceId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function3DeviceId != value)
    {
        _function3DeviceId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function3DeviceId");
        }
    }

    return _function3DeviceId;
}

auto PCIeDevice::function3DeviceId(std::string val) -> std::string
{
    return function3DeviceId(val, false);
}
int PCIeDevice::_callback_set_Function3DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function3DeviceId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function3DeviceId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function3FunctionType() const -> std::string
{
    return _function3FunctionType;
}

int PCIeDevice::_callback_get_Function3FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function3FunctionType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function3FunctionType(std::string value, bool skipSignal)
    -> std::string
{
    if (_function3FunctionType != value)
    {
        _function3FunctionType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function3FunctionType");
        }
    }

    return _function3FunctionType;
}

auto PCIeDevice::function3FunctionType(std::string val) -> std::string
{
    return function3FunctionType(val, false);
}
int PCIeDevice::_callback_set_Function3FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function3FunctionType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function3FunctionType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function3RevisionId() const -> std::string
{
    return _function3RevisionId;
}

int PCIeDevice::_callback_get_Function3RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function3RevisionId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function3RevisionId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function3RevisionId != value)
    {
        _function3RevisionId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function3RevisionId");
        }
    }

    return _function3RevisionId;
}

auto PCIeDevice::function3RevisionId(std::string val) -> std::string
{
    return function3RevisionId(val, false);
}
int PCIeDevice::_callback_set_Function3RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function3RevisionId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function3RevisionId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function3SubsystemId() const -> std::string
{
    return _function3SubsystemId;
}

int PCIeDevice::_callback_get_Function3SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function3SubsystemId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function3SubsystemId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function3SubsystemId != value)
    {
        _function3SubsystemId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function3SubsystemId");
        }
    }

    return _function3SubsystemId;
}

auto PCIeDevice::function3SubsystemId(std::string val) -> std::string
{
    return function3SubsystemId(val, false);
}
int PCIeDevice::_callback_set_Function3SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function3SubsystemId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function3SubsystemId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function3SubsystemVendorId() const -> std::string
{
    return _function3SubsystemVendorId;
}

int PCIeDevice::_callback_get_Function3SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function3SubsystemVendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function3SubsystemVendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function3SubsystemVendorId != value)
    {
        _function3SubsystemVendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function3SubsystemVendorId");
        }
    }

    return _function3SubsystemVendorId;
}

auto PCIeDevice::function3SubsystemVendorId(std::string val) -> std::string
{
    return function3SubsystemVendorId(val, false);
}
int PCIeDevice::_callback_set_Function3SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function3SubsystemVendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function3SubsystemVendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function3VendorId() const -> std::string
{
    return _function3VendorId;
}

int PCIeDevice::_callback_get_Function3VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function3VendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function3VendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function3VendorId != value)
    {
        _function3VendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function3VendorId");
        }
    }

    return _function3VendorId;
}

auto PCIeDevice::function3VendorId(std::string val) -> std::string
{
    return function3VendorId(val, false);
}
int PCIeDevice::_callback_set_Function3VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function3VendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function3VendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function4ClassCode() const -> std::string
{
    return _function4ClassCode;
}

int PCIeDevice::_callback_get_Function4ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function4ClassCode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function4ClassCode(std::string value, bool skipSignal)
    -> std::string
{
    if (_function4ClassCode != value)
    {
        _function4ClassCode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function4ClassCode");
        }
    }

    return _function4ClassCode;
}

auto PCIeDevice::function4ClassCode(std::string val) -> std::string
{
    return function4ClassCode(val, false);
}
int PCIeDevice::_callback_set_Function4ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function4ClassCode(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function4ClassCode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function4DeviceClass() const -> std::string
{
    return _function4DeviceClass;
}

int PCIeDevice::_callback_get_Function4DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function4DeviceClass()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function4DeviceClass(std::string value, bool skipSignal)
    -> std::string
{
    if (_function4DeviceClass != value)
    {
        _function4DeviceClass = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function4DeviceClass");
        }
    }

    return _function4DeviceClass;
}

auto PCIeDevice::function4DeviceClass(std::string val) -> std::string
{
    return function4DeviceClass(val, false);
}
int PCIeDevice::_callback_set_Function4DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function4DeviceClass(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function4DeviceClass =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function4DeviceId() const -> std::string
{
    return _function4DeviceId;
}

int PCIeDevice::_callback_get_Function4DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function4DeviceId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function4DeviceId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function4DeviceId != value)
    {
        _function4DeviceId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function4DeviceId");
        }
    }

    return _function4DeviceId;
}

auto PCIeDevice::function4DeviceId(std::string val) -> std::string
{
    return function4DeviceId(val, false);
}
int PCIeDevice::_callback_set_Function4DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function4DeviceId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function4DeviceId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function4FunctionType() const -> std::string
{
    return _function4FunctionType;
}

int PCIeDevice::_callback_get_Function4FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function4FunctionType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function4FunctionType(std::string value, bool skipSignal)
    -> std::string
{
    if (_function4FunctionType != value)
    {
        _function4FunctionType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function4FunctionType");
        }
    }

    return _function4FunctionType;
}

auto PCIeDevice::function4FunctionType(std::string val) -> std::string
{
    return function4FunctionType(val, false);
}
int PCIeDevice::_callback_set_Function4FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function4FunctionType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function4FunctionType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function4RevisionId() const -> std::string
{
    return _function4RevisionId;
}

int PCIeDevice::_callback_get_Function4RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function4RevisionId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function4RevisionId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function4RevisionId != value)
    {
        _function4RevisionId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function4RevisionId");
        }
    }

    return _function4RevisionId;
}

auto PCIeDevice::function4RevisionId(std::string val) -> std::string
{
    return function4RevisionId(val, false);
}
int PCIeDevice::_callback_set_Function4RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function4RevisionId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function4RevisionId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function4SubsystemId() const -> std::string
{
    return _function4SubsystemId;
}

int PCIeDevice::_callback_get_Function4SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function4SubsystemId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function4SubsystemId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function4SubsystemId != value)
    {
        _function4SubsystemId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function4SubsystemId");
        }
    }

    return _function4SubsystemId;
}

auto PCIeDevice::function4SubsystemId(std::string val) -> std::string
{
    return function4SubsystemId(val, false);
}
int PCIeDevice::_callback_set_Function4SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function4SubsystemId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function4SubsystemId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function4SubsystemVendorId() const -> std::string
{
    return _function4SubsystemVendorId;
}

int PCIeDevice::_callback_get_Function4SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function4SubsystemVendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function4SubsystemVendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function4SubsystemVendorId != value)
    {
        _function4SubsystemVendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function4SubsystemVendorId");
        }
    }

    return _function4SubsystemVendorId;
}

auto PCIeDevice::function4SubsystemVendorId(std::string val) -> std::string
{
    return function4SubsystemVendorId(val, false);
}
int PCIeDevice::_callback_set_Function4SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function4SubsystemVendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function4SubsystemVendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function4VendorId() const -> std::string
{
    return _function4VendorId;
}

int PCIeDevice::_callback_get_Function4VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function4VendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function4VendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function4VendorId != value)
    {
        _function4VendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function4VendorId");
        }
    }

    return _function4VendorId;
}

auto PCIeDevice::function4VendorId(std::string val) -> std::string
{
    return function4VendorId(val, false);
}
int PCIeDevice::_callback_set_Function4VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function4VendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function4VendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function5ClassCode() const -> std::string
{
    return _function5ClassCode;
}

int PCIeDevice::_callback_get_Function5ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function5ClassCode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function5ClassCode(std::string value, bool skipSignal)
    -> std::string
{
    if (_function5ClassCode != value)
    {
        _function5ClassCode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function5ClassCode");
        }
    }

    return _function5ClassCode;
}

auto PCIeDevice::function5ClassCode(std::string val) -> std::string
{
    return function5ClassCode(val, false);
}
int PCIeDevice::_callback_set_Function5ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function5ClassCode(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function5ClassCode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function5DeviceClass() const -> std::string
{
    return _function5DeviceClass;
}

int PCIeDevice::_callback_get_Function5DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function5DeviceClass()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function5DeviceClass(std::string value, bool skipSignal)
    -> std::string
{
    if (_function5DeviceClass != value)
    {
        _function5DeviceClass = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function5DeviceClass");
        }
    }

    return _function5DeviceClass;
}

auto PCIeDevice::function5DeviceClass(std::string val) -> std::string
{
    return function5DeviceClass(val, false);
}
int PCIeDevice::_callback_set_Function5DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function5DeviceClass(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function5DeviceClass =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function5DeviceId() const -> std::string
{
    return _function5DeviceId;
}

int PCIeDevice::_callback_get_Function5DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function5DeviceId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function5DeviceId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function5DeviceId != value)
    {
        _function5DeviceId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function5DeviceId");
        }
    }

    return _function5DeviceId;
}

auto PCIeDevice::function5DeviceId(std::string val) -> std::string
{
    return function5DeviceId(val, false);
}
int PCIeDevice::_callback_set_Function5DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function5DeviceId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function5DeviceId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function5FunctionType() const -> std::string
{
    return _function5FunctionType;
}

int PCIeDevice::_callback_get_Function5FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function5FunctionType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function5FunctionType(std::string value, bool skipSignal)
    -> std::string
{
    if (_function5FunctionType != value)
    {
        _function5FunctionType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function5FunctionType");
        }
    }

    return _function5FunctionType;
}

auto PCIeDevice::function5FunctionType(std::string val) -> std::string
{
    return function5FunctionType(val, false);
}
int PCIeDevice::_callback_set_Function5FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function5FunctionType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function5FunctionType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function5RevisionId() const -> std::string
{
    return _function5RevisionId;
}

int PCIeDevice::_callback_get_Function5RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function5RevisionId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function5RevisionId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function5RevisionId != value)
    {
        _function5RevisionId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function5RevisionId");
        }
    }

    return _function5RevisionId;
}

auto PCIeDevice::function5RevisionId(std::string val) -> std::string
{
    return function5RevisionId(val, false);
}
int PCIeDevice::_callback_set_Function5RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function5RevisionId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function5RevisionId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function5SubsystemId() const -> std::string
{
    return _function5SubsystemId;
}

int PCIeDevice::_callback_get_Function5SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function5SubsystemId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function5SubsystemId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function5SubsystemId != value)
    {
        _function5SubsystemId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function5SubsystemId");
        }
    }

    return _function5SubsystemId;
}

auto PCIeDevice::function5SubsystemId(std::string val) -> std::string
{
    return function5SubsystemId(val, false);
}
int PCIeDevice::_callback_set_Function5SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function5SubsystemId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function5SubsystemId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function5SubsystemVendorId() const -> std::string
{
    return _function5SubsystemVendorId;
}

int PCIeDevice::_callback_get_Function5SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function5SubsystemVendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function5SubsystemVendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function5SubsystemVendorId != value)
    {
        _function5SubsystemVendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function5SubsystemVendorId");
        }
    }

    return _function5SubsystemVendorId;
}

auto PCIeDevice::function5SubsystemVendorId(std::string val) -> std::string
{
    return function5SubsystemVendorId(val, false);
}
int PCIeDevice::_callback_set_Function5SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function5SubsystemVendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function5SubsystemVendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function5VendorId() const -> std::string
{
    return _function5VendorId;
}

int PCIeDevice::_callback_get_Function5VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function5VendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function5VendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function5VendorId != value)
    {
        _function5VendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function5VendorId");
        }
    }

    return _function5VendorId;
}

auto PCIeDevice::function5VendorId(std::string val) -> std::string
{
    return function5VendorId(val, false);
}
int PCIeDevice::_callback_set_Function5VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function5VendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function5VendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function6ClassCode() const -> std::string
{
    return _function6ClassCode;
}

int PCIeDevice::_callback_get_Function6ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function6ClassCode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function6ClassCode(std::string value, bool skipSignal)
    -> std::string
{
    if (_function6ClassCode != value)
    {
        _function6ClassCode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function6ClassCode");
        }
    }

    return _function6ClassCode;
}

auto PCIeDevice::function6ClassCode(std::string val) -> std::string
{
    return function6ClassCode(val, false);
}
int PCIeDevice::_callback_set_Function6ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function6ClassCode(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function6ClassCode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function6DeviceClass() const -> std::string
{
    return _function6DeviceClass;
}

int PCIeDevice::_callback_get_Function6DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function6DeviceClass()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function6DeviceClass(std::string value, bool skipSignal)
    -> std::string
{
    if (_function6DeviceClass != value)
    {
        _function6DeviceClass = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function6DeviceClass");
        }
    }

    return _function6DeviceClass;
}

auto PCIeDevice::function6DeviceClass(std::string val) -> std::string
{
    return function6DeviceClass(val, false);
}
int PCIeDevice::_callback_set_Function6DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function6DeviceClass(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function6DeviceClass =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function6DeviceId() const -> std::string
{
    return _function6DeviceId;
}

int PCIeDevice::_callback_get_Function6DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function6DeviceId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function6DeviceId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function6DeviceId != value)
    {
        _function6DeviceId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function6DeviceId");
        }
    }

    return _function6DeviceId;
}

auto PCIeDevice::function6DeviceId(std::string val) -> std::string
{
    return function6DeviceId(val, false);
}
int PCIeDevice::_callback_set_Function6DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function6DeviceId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function6DeviceId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function6FunctionType() const -> std::string
{
    return _function6FunctionType;
}

int PCIeDevice::_callback_get_Function6FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function6FunctionType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function6FunctionType(std::string value, bool skipSignal)
    -> std::string
{
    if (_function6FunctionType != value)
    {
        _function6FunctionType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function6FunctionType");
        }
    }

    return _function6FunctionType;
}

auto PCIeDevice::function6FunctionType(std::string val) -> std::string
{
    return function6FunctionType(val, false);
}
int PCIeDevice::_callback_set_Function6FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function6FunctionType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function6FunctionType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function6RevisionId() const -> std::string
{
    return _function6RevisionId;
}

int PCIeDevice::_callback_get_Function6RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function6RevisionId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function6RevisionId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function6RevisionId != value)
    {
        _function6RevisionId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function6RevisionId");
        }
    }

    return _function6RevisionId;
}

auto PCIeDevice::function6RevisionId(std::string val) -> std::string
{
    return function6RevisionId(val, false);
}
int PCIeDevice::_callback_set_Function6RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function6RevisionId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function6RevisionId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function6SubsystemId() const -> std::string
{
    return _function6SubsystemId;
}

int PCIeDevice::_callback_get_Function6SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function6SubsystemId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function6SubsystemId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function6SubsystemId != value)
    {
        _function6SubsystemId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function6SubsystemId");
        }
    }

    return _function6SubsystemId;
}

auto PCIeDevice::function6SubsystemId(std::string val) -> std::string
{
    return function6SubsystemId(val, false);
}
int PCIeDevice::_callback_set_Function6SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function6SubsystemId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function6SubsystemId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function6SubsystemVendorId() const -> std::string
{
    return _function6SubsystemVendorId;
}

int PCIeDevice::_callback_get_Function6SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function6SubsystemVendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function6SubsystemVendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function6SubsystemVendorId != value)
    {
        _function6SubsystemVendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function6SubsystemVendorId");
        }
    }

    return _function6SubsystemVendorId;
}

auto PCIeDevice::function6SubsystemVendorId(std::string val) -> std::string
{
    return function6SubsystemVendorId(val, false);
}
int PCIeDevice::_callback_set_Function6SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function6SubsystemVendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function6SubsystemVendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function6VendorId() const -> std::string
{
    return _function6VendorId;
}

int PCIeDevice::_callback_get_Function6VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function6VendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function6VendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function6VendorId != value)
    {
        _function6VendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function6VendorId");
        }
    }

    return _function6VendorId;
}

auto PCIeDevice::function6VendorId(std::string val) -> std::string
{
    return function6VendorId(val, false);
}
int PCIeDevice::_callback_set_Function6VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function6VendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function6VendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function7ClassCode() const -> std::string
{
    return _function7ClassCode;
}

int PCIeDevice::_callback_get_Function7ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function7ClassCode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function7ClassCode(std::string value, bool skipSignal)
    -> std::string
{
    if (_function7ClassCode != value)
    {
        _function7ClassCode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function7ClassCode");
        }
    }

    return _function7ClassCode;
}

auto PCIeDevice::function7ClassCode(std::string val) -> std::string
{
    return function7ClassCode(val, false);
}
int PCIeDevice::_callback_set_Function7ClassCode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function7ClassCode(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function7ClassCode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function7DeviceClass() const -> std::string
{
    return _function7DeviceClass;
}

int PCIeDevice::_callback_get_Function7DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function7DeviceClass()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function7DeviceClass(std::string value, bool skipSignal)
    -> std::string
{
    if (_function7DeviceClass != value)
    {
        _function7DeviceClass = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function7DeviceClass");
        }
    }

    return _function7DeviceClass;
}

auto PCIeDevice::function7DeviceClass(std::string val) -> std::string
{
    return function7DeviceClass(val, false);
}
int PCIeDevice::_callback_set_Function7DeviceClass(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function7DeviceClass(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function7DeviceClass =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function7DeviceId() const -> std::string
{
    return _function7DeviceId;
}

int PCIeDevice::_callback_get_Function7DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function7DeviceId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function7DeviceId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function7DeviceId != value)
    {
        _function7DeviceId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function7DeviceId");
        }
    }

    return _function7DeviceId;
}

auto PCIeDevice::function7DeviceId(std::string val) -> std::string
{
    return function7DeviceId(val, false);
}
int PCIeDevice::_callback_set_Function7DeviceId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function7DeviceId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function7DeviceId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function7FunctionType() const -> std::string
{
    return _function7FunctionType;
}

int PCIeDevice::_callback_get_Function7FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function7FunctionType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function7FunctionType(std::string value, bool skipSignal)
    -> std::string
{
    if (_function7FunctionType != value)
    {
        _function7FunctionType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function7FunctionType");
        }
    }

    return _function7FunctionType;
}

auto PCIeDevice::function7FunctionType(std::string val) -> std::string
{
    return function7FunctionType(val, false);
}
int PCIeDevice::_callback_set_Function7FunctionType(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function7FunctionType(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function7FunctionType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function7RevisionId() const -> std::string
{
    return _function7RevisionId;
}

int PCIeDevice::_callback_get_Function7RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function7RevisionId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function7RevisionId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function7RevisionId != value)
    {
        _function7RevisionId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function7RevisionId");
        }
    }

    return _function7RevisionId;
}

auto PCIeDevice::function7RevisionId(std::string val) -> std::string
{
    return function7RevisionId(val, false);
}
int PCIeDevice::_callback_set_Function7RevisionId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function7RevisionId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function7RevisionId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function7SubsystemId() const -> std::string
{
    return _function7SubsystemId;
}

int PCIeDevice::_callback_get_Function7SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function7SubsystemId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function7SubsystemId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function7SubsystemId != value)
    {
        _function7SubsystemId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function7SubsystemId");
        }
    }

    return _function7SubsystemId;
}

auto PCIeDevice::function7SubsystemId(std::string val) -> std::string
{
    return function7SubsystemId(val, false);
}
int PCIeDevice::_callback_set_Function7SubsystemId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function7SubsystemId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function7SubsystemId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function7SubsystemVendorId() const -> std::string
{
    return _function7SubsystemVendorId;
}

int PCIeDevice::_callback_get_Function7SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function7SubsystemVendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function7SubsystemVendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function7SubsystemVendorId != value)
    {
        _function7SubsystemVendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function7SubsystemVendorId");
        }
    }

    return _function7SubsystemVendorId;
}

auto PCIeDevice::function7SubsystemVendorId(std::string val) -> std::string
{
    return function7SubsystemVendorId(val, false);
}
int PCIeDevice::_callback_set_Function7SubsystemVendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function7SubsystemVendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function7SubsystemVendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::function7VendorId() const -> std::string
{
    return _function7VendorId;
}

int PCIeDevice::_callback_get_Function7VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->function7VendorId()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::function7VendorId(std::string value, bool skipSignal)
    -> std::string
{
    if (_function7VendorId != value)
    {
        _function7VendorId = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Function7VendorId");
        }
    }

    return _function7VendorId;
}

auto PCIeDevice::function7VendorId(std::string val) -> std::string
{
    return function7VendorId(val, false);
}
int PCIeDevice::_callback_set_Function7VendorId(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->function7VendorId(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Function7VendorId =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PCIeDevice::manufacturer() const -> std::string
{
    return _manufacturer;
}

int PCIeDevice::_callback_get_Manufacturer(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->manufacturer()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PCIeDevice::manufacturer(std::string value, bool skipSignal) -> std::string
{
    if (_manufacturer != value)
    {
        _manufacturer = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_PCIeDevice_interface
                .property_changed("Manufacturer");
        }
    }

    return _manufacturer;
}

auto PCIeDevice::manufacturer(std::string val) -> std::string
{
    return manufacturer(val, false);
}
int PCIeDevice::_callback_set_Manufacturer(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<PCIeDevice*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->manufacturer(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PCIeDevice
{
static const auto _property_Manufacturer =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void PCIeDevice::setPropertyByName(const std::string& _name,
                                   const PropertiesVariant& val,
                                   bool skipSignal)
{
    if (_name == "DeviceType")
    {
        auto& v = std::get<std::string>(val);
        deviceType(v, skipSignal);
        return;
    }
    if (_name == "Function0ClassCode")
    {
        auto& v = std::get<std::string>(val);
        function0ClassCode(v, skipSignal);
        return;
    }
    if (_name == "Function0DeviceClass")
    {
        auto& v = std::get<std::string>(val);
        function0DeviceClass(v, skipSignal);
        return;
    }
    if (_name == "Function0DeviceId")
    {
        auto& v = std::get<std::string>(val);
        function0DeviceId(v, skipSignal);
        return;
    }
    if (_name == "Function0FunctionType")
    {
        auto& v = std::get<std::string>(val);
        function0FunctionType(v, skipSignal);
        return;
    }
    if (_name == "Function0RevisionId")
    {
        auto& v = std::get<std::string>(val);
        function0RevisionId(v, skipSignal);
        return;
    }
    if (_name == "Function0SubsystemId")
    {
        auto& v = std::get<std::string>(val);
        function0SubsystemId(v, skipSignal);
        return;
    }
    if (_name == "Function0SubsystemVendorId")
    {
        auto& v = std::get<std::string>(val);
        function0SubsystemVendorId(v, skipSignal);
        return;
    }
    if (_name == "Function0VendorId")
    {
        auto& v = std::get<std::string>(val);
        function0VendorId(v, skipSignal);
        return;
    }
    if (_name == "Function1ClassCode")
    {
        auto& v = std::get<std::string>(val);
        function1ClassCode(v, skipSignal);
        return;
    }
    if (_name == "Function1DeviceClass")
    {
        auto& v = std::get<std::string>(val);
        function1DeviceClass(v, skipSignal);
        return;
    }
    if (_name == "Function1DeviceId")
    {
        auto& v = std::get<std::string>(val);
        function1DeviceId(v, skipSignal);
        return;
    }
    if (_name == "Function1FunctionType")
    {
        auto& v = std::get<std::string>(val);
        function1FunctionType(v, skipSignal);
        return;
    }
    if (_name == "Function1RevisionId")
    {
        auto& v = std::get<std::string>(val);
        function1RevisionId(v, skipSignal);
        return;
    }
    if (_name == "Function1SubsystemId")
    {
        auto& v = std::get<std::string>(val);
        function1SubsystemId(v, skipSignal);
        return;
    }
    if (_name == "Function1SubsystemVendorId")
    {
        auto& v = std::get<std::string>(val);
        function1SubsystemVendorId(v, skipSignal);
        return;
    }
    if (_name == "Function1VendorId")
    {
        auto& v = std::get<std::string>(val);
        function1VendorId(v, skipSignal);
        return;
    }
    if (_name == "Function2ClassCode")
    {
        auto& v = std::get<std::string>(val);
        function2ClassCode(v, skipSignal);
        return;
    }
    if (_name == "Function2DeviceClass")
    {
        auto& v = std::get<std::string>(val);
        function2DeviceClass(v, skipSignal);
        return;
    }
    if (_name == "Function2DeviceId")
    {
        auto& v = std::get<std::string>(val);
        function2DeviceId(v, skipSignal);
        return;
    }
    if (_name == "Function2FunctionType")
    {
        auto& v = std::get<std::string>(val);
        function2FunctionType(v, skipSignal);
        return;
    }
    if (_name == "Function2RevisionId")
    {
        auto& v = std::get<std::string>(val);
        function2RevisionId(v, skipSignal);
        return;
    }
    if (_name == "Function2SubsystemId")
    {
        auto& v = std::get<std::string>(val);
        function2SubsystemId(v, skipSignal);
        return;
    }
    if (_name == "Function2SubsystemVendorId")
    {
        auto& v = std::get<std::string>(val);
        function2SubsystemVendorId(v, skipSignal);
        return;
    }
    if (_name == "Function2VendorId")
    {
        auto& v = std::get<std::string>(val);
        function2VendorId(v, skipSignal);
        return;
    }
    if (_name == "Function3ClassCode")
    {
        auto& v = std::get<std::string>(val);
        function3ClassCode(v, skipSignal);
        return;
    }
    if (_name == "Function3DeviceClass")
    {
        auto& v = std::get<std::string>(val);
        function3DeviceClass(v, skipSignal);
        return;
    }
    if (_name == "Function3DeviceId")
    {
        auto& v = std::get<std::string>(val);
        function3DeviceId(v, skipSignal);
        return;
    }
    if (_name == "Function3FunctionType")
    {
        auto& v = std::get<std::string>(val);
        function3FunctionType(v, skipSignal);
        return;
    }
    if (_name == "Function3RevisionId")
    {
        auto& v = std::get<std::string>(val);
        function3RevisionId(v, skipSignal);
        return;
    }
    if (_name == "Function3SubsystemId")
    {
        auto& v = std::get<std::string>(val);
        function3SubsystemId(v, skipSignal);
        return;
    }
    if (_name == "Function3SubsystemVendorId")
    {
        auto& v = std::get<std::string>(val);
        function3SubsystemVendorId(v, skipSignal);
        return;
    }
    if (_name == "Function3VendorId")
    {
        auto& v = std::get<std::string>(val);
        function3VendorId(v, skipSignal);
        return;
    }
    if (_name == "Function4ClassCode")
    {
        auto& v = std::get<std::string>(val);
        function4ClassCode(v, skipSignal);
        return;
    }
    if (_name == "Function4DeviceClass")
    {
        auto& v = std::get<std::string>(val);
        function4DeviceClass(v, skipSignal);
        return;
    }
    if (_name == "Function4DeviceId")
    {
        auto& v = std::get<std::string>(val);
        function4DeviceId(v, skipSignal);
        return;
    }
    if (_name == "Function4FunctionType")
    {
        auto& v = std::get<std::string>(val);
        function4FunctionType(v, skipSignal);
        return;
    }
    if (_name == "Function4RevisionId")
    {
        auto& v = std::get<std::string>(val);
        function4RevisionId(v, skipSignal);
        return;
    }
    if (_name == "Function4SubsystemId")
    {
        auto& v = std::get<std::string>(val);
        function4SubsystemId(v, skipSignal);
        return;
    }
    if (_name == "Function4SubsystemVendorId")
    {
        auto& v = std::get<std::string>(val);
        function4SubsystemVendorId(v, skipSignal);
        return;
    }
    if (_name == "Function4VendorId")
    {
        auto& v = std::get<std::string>(val);
        function4VendorId(v, skipSignal);
        return;
    }
    if (_name == "Function5ClassCode")
    {
        auto& v = std::get<std::string>(val);
        function5ClassCode(v, skipSignal);
        return;
    }
    if (_name == "Function5DeviceClass")
    {
        auto& v = std::get<std::string>(val);
        function5DeviceClass(v, skipSignal);
        return;
    }
    if (_name == "Function5DeviceId")
    {
        auto& v = std::get<std::string>(val);
        function5DeviceId(v, skipSignal);
        return;
    }
    if (_name == "Function5FunctionType")
    {
        auto& v = std::get<std::string>(val);
        function5FunctionType(v, skipSignal);
        return;
    }
    if (_name == "Function5RevisionId")
    {
        auto& v = std::get<std::string>(val);
        function5RevisionId(v, skipSignal);
        return;
    }
    if (_name == "Function5SubsystemId")
    {
        auto& v = std::get<std::string>(val);
        function5SubsystemId(v, skipSignal);
        return;
    }
    if (_name == "Function5SubsystemVendorId")
    {
        auto& v = std::get<std::string>(val);
        function5SubsystemVendorId(v, skipSignal);
        return;
    }
    if (_name == "Function5VendorId")
    {
        auto& v = std::get<std::string>(val);
        function5VendorId(v, skipSignal);
        return;
    }
    if (_name == "Function6ClassCode")
    {
        auto& v = std::get<std::string>(val);
        function6ClassCode(v, skipSignal);
        return;
    }
    if (_name == "Function6DeviceClass")
    {
        auto& v = std::get<std::string>(val);
        function6DeviceClass(v, skipSignal);
        return;
    }
    if (_name == "Function6DeviceId")
    {
        auto& v = std::get<std::string>(val);
        function6DeviceId(v, skipSignal);
        return;
    }
    if (_name == "Function6FunctionType")
    {
        auto& v = std::get<std::string>(val);
        function6FunctionType(v, skipSignal);
        return;
    }
    if (_name == "Function6RevisionId")
    {
        auto& v = std::get<std::string>(val);
        function6RevisionId(v, skipSignal);
        return;
    }
    if (_name == "Function6SubsystemId")
    {
        auto& v = std::get<std::string>(val);
        function6SubsystemId(v, skipSignal);
        return;
    }
    if (_name == "Function6SubsystemVendorId")
    {
        auto& v = std::get<std::string>(val);
        function6SubsystemVendorId(v, skipSignal);
        return;
    }
    if (_name == "Function6VendorId")
    {
        auto& v = std::get<std::string>(val);
        function6VendorId(v, skipSignal);
        return;
    }
    if (_name == "Function7ClassCode")
    {
        auto& v = std::get<std::string>(val);
        function7ClassCode(v, skipSignal);
        return;
    }
    if (_name == "Function7DeviceClass")
    {
        auto& v = std::get<std::string>(val);
        function7DeviceClass(v, skipSignal);
        return;
    }
    if (_name == "Function7DeviceId")
    {
        auto& v = std::get<std::string>(val);
        function7DeviceId(v, skipSignal);
        return;
    }
    if (_name == "Function7FunctionType")
    {
        auto& v = std::get<std::string>(val);
        function7FunctionType(v, skipSignal);
        return;
    }
    if (_name == "Function7RevisionId")
    {
        auto& v = std::get<std::string>(val);
        function7RevisionId(v, skipSignal);
        return;
    }
    if (_name == "Function7SubsystemId")
    {
        auto& v = std::get<std::string>(val);
        function7SubsystemId(v, skipSignal);
        return;
    }
    if (_name == "Function7SubsystemVendorId")
    {
        auto& v = std::get<std::string>(val);
        function7SubsystemVendorId(v, skipSignal);
        return;
    }
    if (_name == "Function7VendorId")
    {
        auto& v = std::get<std::string>(val);
        function7VendorId(v, skipSignal);
        return;
    }
    if (_name == "Manufacturer")
    {
        auto& v = std::get<std::string>(val);
        manufacturer(v, skipSignal);
        return;
    }
}

auto PCIeDevice::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "DeviceType")
    {
        return deviceType();
    }
    if (_name == "Function0ClassCode")
    {
        return function0ClassCode();
    }
    if (_name == "Function0DeviceClass")
    {
        return function0DeviceClass();
    }
    if (_name == "Function0DeviceId")
    {
        return function0DeviceId();
    }
    if (_name == "Function0FunctionType")
    {
        return function0FunctionType();
    }
    if (_name == "Function0RevisionId")
    {
        return function0RevisionId();
    }
    if (_name == "Function0SubsystemId")
    {
        return function0SubsystemId();
    }
    if (_name == "Function0SubsystemVendorId")
    {
        return function0SubsystemVendorId();
    }
    if (_name == "Function0VendorId")
    {
        return function0VendorId();
    }
    if (_name == "Function1ClassCode")
    {
        return function1ClassCode();
    }
    if (_name == "Function1DeviceClass")
    {
        return function1DeviceClass();
    }
    if (_name == "Function1DeviceId")
    {
        return function1DeviceId();
    }
    if (_name == "Function1FunctionType")
    {
        return function1FunctionType();
    }
    if (_name == "Function1RevisionId")
    {
        return function1RevisionId();
    }
    if (_name == "Function1SubsystemId")
    {
        return function1SubsystemId();
    }
    if (_name == "Function1SubsystemVendorId")
    {
        return function1SubsystemVendorId();
    }
    if (_name == "Function1VendorId")
    {
        return function1VendorId();
    }
    if (_name == "Function2ClassCode")
    {
        return function2ClassCode();
    }
    if (_name == "Function2DeviceClass")
    {
        return function2DeviceClass();
    }
    if (_name == "Function2DeviceId")
    {
        return function2DeviceId();
    }
    if (_name == "Function2FunctionType")
    {
        return function2FunctionType();
    }
    if (_name == "Function2RevisionId")
    {
        return function2RevisionId();
    }
    if (_name == "Function2SubsystemId")
    {
        return function2SubsystemId();
    }
    if (_name == "Function2SubsystemVendorId")
    {
        return function2SubsystemVendorId();
    }
    if (_name == "Function2VendorId")
    {
        return function2VendorId();
    }
    if (_name == "Function3ClassCode")
    {
        return function3ClassCode();
    }
    if (_name == "Function3DeviceClass")
    {
        return function3DeviceClass();
    }
    if (_name == "Function3DeviceId")
    {
        return function3DeviceId();
    }
    if (_name == "Function3FunctionType")
    {
        return function3FunctionType();
    }
    if (_name == "Function3RevisionId")
    {
        return function3RevisionId();
    }
    if (_name == "Function3SubsystemId")
    {
        return function3SubsystemId();
    }
    if (_name == "Function3SubsystemVendorId")
    {
        return function3SubsystemVendorId();
    }
    if (_name == "Function3VendorId")
    {
        return function3VendorId();
    }
    if (_name == "Function4ClassCode")
    {
        return function4ClassCode();
    }
    if (_name == "Function4DeviceClass")
    {
        return function4DeviceClass();
    }
    if (_name == "Function4DeviceId")
    {
        return function4DeviceId();
    }
    if (_name == "Function4FunctionType")
    {
        return function4FunctionType();
    }
    if (_name == "Function4RevisionId")
    {
        return function4RevisionId();
    }
    if (_name == "Function4SubsystemId")
    {
        return function4SubsystemId();
    }
    if (_name == "Function4SubsystemVendorId")
    {
        return function4SubsystemVendorId();
    }
    if (_name == "Function4VendorId")
    {
        return function4VendorId();
    }
    if (_name == "Function5ClassCode")
    {
        return function5ClassCode();
    }
    if (_name == "Function5DeviceClass")
    {
        return function5DeviceClass();
    }
    if (_name == "Function5DeviceId")
    {
        return function5DeviceId();
    }
    if (_name == "Function5FunctionType")
    {
        return function5FunctionType();
    }
    if (_name == "Function5RevisionId")
    {
        return function5RevisionId();
    }
    if (_name == "Function5SubsystemId")
    {
        return function5SubsystemId();
    }
    if (_name == "Function5SubsystemVendorId")
    {
        return function5SubsystemVendorId();
    }
    if (_name == "Function5VendorId")
    {
        return function5VendorId();
    }
    if (_name == "Function6ClassCode")
    {
        return function6ClassCode();
    }
    if (_name == "Function6DeviceClass")
    {
        return function6DeviceClass();
    }
    if (_name == "Function6DeviceId")
    {
        return function6DeviceId();
    }
    if (_name == "Function6FunctionType")
    {
        return function6FunctionType();
    }
    if (_name == "Function6RevisionId")
    {
        return function6RevisionId();
    }
    if (_name == "Function6SubsystemId")
    {
        return function6SubsystemId();
    }
    if (_name == "Function6SubsystemVendorId")
    {
        return function6SubsystemVendorId();
    }
    if (_name == "Function6VendorId")
    {
        return function6VendorId();
    }
    if (_name == "Function7ClassCode")
    {
        return function7ClassCode();
    }
    if (_name == "Function7DeviceClass")
    {
        return function7DeviceClass();
    }
    if (_name == "Function7DeviceId")
    {
        return function7DeviceId();
    }
    if (_name == "Function7FunctionType")
    {
        return function7FunctionType();
    }
    if (_name == "Function7RevisionId")
    {
        return function7RevisionId();
    }
    if (_name == "Function7SubsystemId")
    {
        return function7SubsystemId();
    }
    if (_name == "Function7SubsystemVendorId")
    {
        return function7SubsystemVendorId();
    }
    if (_name == "Function7VendorId")
    {
        return function7VendorId();
    }
    if (_name == "Manufacturer")
    {
        return manufacturer();
    }

    return PropertiesVariant();
}

const vtable::vtable_t PCIeDevice::_vtable[] = {
    vtable::start(),
    vtable::property("DeviceType",
                     details::PCIeDevice::_property_DeviceType.data(),
                     _callback_get_DeviceType, _callback_set_DeviceType,
                     vtable::property_::emits_change),
    vtable::property("Function0ClassCode",
                     details::PCIeDevice::_property_Function0ClassCode.data(),
                     _callback_get_Function0ClassCode,
                     _callback_set_Function0ClassCode,
                     vtable::property_::emits_change),
    vtable::property("Function0DeviceClass",
                     details::PCIeDevice::_property_Function0DeviceClass.data(),
                     _callback_get_Function0DeviceClass,
                     _callback_set_Function0DeviceClass,
                     vtable::property_::emits_change),
    vtable::property("Function0DeviceId",
                     details::PCIeDevice::_property_Function0DeviceId.data(),
                     _callback_get_Function0DeviceId,
                     _callback_set_Function0DeviceId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function0FunctionType",
        details::PCIeDevice::_property_Function0FunctionType.data(),
        _callback_get_Function0FunctionType,
        _callback_set_Function0FunctionType, vtable::property_::emits_change),
    vtable::property("Function0RevisionId",
                     details::PCIeDevice::_property_Function0RevisionId.data(),
                     _callback_get_Function0RevisionId,
                     _callback_set_Function0RevisionId,
                     vtable::property_::emits_change),
    vtable::property("Function0SubsystemId",
                     details::PCIeDevice::_property_Function0SubsystemId.data(),
                     _callback_get_Function0SubsystemId,
                     _callback_set_Function0SubsystemId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function0SubsystemVendorId",
        details::PCIeDevice::_property_Function0SubsystemVendorId.data(),
        _callback_get_Function0SubsystemVendorId,
        _callback_set_Function0SubsystemVendorId,
        vtable::property_::emits_change),
    vtable::property("Function0VendorId",
                     details::PCIeDevice::_property_Function0VendorId.data(),
                     _callback_get_Function0VendorId,
                     _callback_set_Function0VendorId,
                     vtable::property_::emits_change),
    vtable::property("Function1ClassCode",
                     details::PCIeDevice::_property_Function1ClassCode.data(),
                     _callback_get_Function1ClassCode,
                     _callback_set_Function1ClassCode,
                     vtable::property_::emits_change),
    vtable::property("Function1DeviceClass",
                     details::PCIeDevice::_property_Function1DeviceClass.data(),
                     _callback_get_Function1DeviceClass,
                     _callback_set_Function1DeviceClass,
                     vtable::property_::emits_change),
    vtable::property("Function1DeviceId",
                     details::PCIeDevice::_property_Function1DeviceId.data(),
                     _callback_get_Function1DeviceId,
                     _callback_set_Function1DeviceId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function1FunctionType",
        details::PCIeDevice::_property_Function1FunctionType.data(),
        _callback_get_Function1FunctionType,
        _callback_set_Function1FunctionType, vtable::property_::emits_change),
    vtable::property("Function1RevisionId",
                     details::PCIeDevice::_property_Function1RevisionId.data(),
                     _callback_get_Function1RevisionId,
                     _callback_set_Function1RevisionId,
                     vtable::property_::emits_change),
    vtable::property("Function1SubsystemId",
                     details::PCIeDevice::_property_Function1SubsystemId.data(),
                     _callback_get_Function1SubsystemId,
                     _callback_set_Function1SubsystemId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function1SubsystemVendorId",
        details::PCIeDevice::_property_Function1SubsystemVendorId.data(),
        _callback_get_Function1SubsystemVendorId,
        _callback_set_Function1SubsystemVendorId,
        vtable::property_::emits_change),
    vtable::property("Function1VendorId",
                     details::PCIeDevice::_property_Function1VendorId.data(),
                     _callback_get_Function1VendorId,
                     _callback_set_Function1VendorId,
                     vtable::property_::emits_change),
    vtable::property("Function2ClassCode",
                     details::PCIeDevice::_property_Function2ClassCode.data(),
                     _callback_get_Function2ClassCode,
                     _callback_set_Function2ClassCode,
                     vtable::property_::emits_change),
    vtable::property("Function2DeviceClass",
                     details::PCIeDevice::_property_Function2DeviceClass.data(),
                     _callback_get_Function2DeviceClass,
                     _callback_set_Function2DeviceClass,
                     vtable::property_::emits_change),
    vtable::property("Function2DeviceId",
                     details::PCIeDevice::_property_Function2DeviceId.data(),
                     _callback_get_Function2DeviceId,
                     _callback_set_Function2DeviceId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function2FunctionType",
        details::PCIeDevice::_property_Function2FunctionType.data(),
        _callback_get_Function2FunctionType,
        _callback_set_Function2FunctionType, vtable::property_::emits_change),
    vtable::property("Function2RevisionId",
                     details::PCIeDevice::_property_Function2RevisionId.data(),
                     _callback_get_Function2RevisionId,
                     _callback_set_Function2RevisionId,
                     vtable::property_::emits_change),
    vtable::property("Function2SubsystemId",
                     details::PCIeDevice::_property_Function2SubsystemId.data(),
                     _callback_get_Function2SubsystemId,
                     _callback_set_Function2SubsystemId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function2SubsystemVendorId",
        details::PCIeDevice::_property_Function2SubsystemVendorId.data(),
        _callback_get_Function2SubsystemVendorId,
        _callback_set_Function2SubsystemVendorId,
        vtable::property_::emits_change),
    vtable::property("Function2VendorId",
                     details::PCIeDevice::_property_Function2VendorId.data(),
                     _callback_get_Function2VendorId,
                     _callback_set_Function2VendorId,
                     vtable::property_::emits_change),
    vtable::property("Function3ClassCode",
                     details::PCIeDevice::_property_Function3ClassCode.data(),
                     _callback_get_Function3ClassCode,
                     _callback_set_Function3ClassCode,
                     vtable::property_::emits_change),
    vtable::property("Function3DeviceClass",
                     details::PCIeDevice::_property_Function3DeviceClass.data(),
                     _callback_get_Function3DeviceClass,
                     _callback_set_Function3DeviceClass,
                     vtable::property_::emits_change),
    vtable::property("Function3DeviceId",
                     details::PCIeDevice::_property_Function3DeviceId.data(),
                     _callback_get_Function3DeviceId,
                     _callback_set_Function3DeviceId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function3FunctionType",
        details::PCIeDevice::_property_Function3FunctionType.data(),
        _callback_get_Function3FunctionType,
        _callback_set_Function3FunctionType, vtable::property_::emits_change),
    vtable::property("Function3RevisionId",
                     details::PCIeDevice::_property_Function3RevisionId.data(),
                     _callback_get_Function3RevisionId,
                     _callback_set_Function3RevisionId,
                     vtable::property_::emits_change),
    vtable::property("Function3SubsystemId",
                     details::PCIeDevice::_property_Function3SubsystemId.data(),
                     _callback_get_Function3SubsystemId,
                     _callback_set_Function3SubsystemId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function3SubsystemVendorId",
        details::PCIeDevice::_property_Function3SubsystemVendorId.data(),
        _callback_get_Function3SubsystemVendorId,
        _callback_set_Function3SubsystemVendorId,
        vtable::property_::emits_change),
    vtable::property("Function3VendorId",
                     details::PCIeDevice::_property_Function3VendorId.data(),
                     _callback_get_Function3VendorId,
                     _callback_set_Function3VendorId,
                     vtable::property_::emits_change),
    vtable::property("Function4ClassCode",
                     details::PCIeDevice::_property_Function4ClassCode.data(),
                     _callback_get_Function4ClassCode,
                     _callback_set_Function4ClassCode,
                     vtable::property_::emits_change),
    vtable::property("Function4DeviceClass",
                     details::PCIeDevice::_property_Function4DeviceClass.data(),
                     _callback_get_Function4DeviceClass,
                     _callback_set_Function4DeviceClass,
                     vtable::property_::emits_change),
    vtable::property("Function4DeviceId",
                     details::PCIeDevice::_property_Function4DeviceId.data(),
                     _callback_get_Function4DeviceId,
                     _callback_set_Function4DeviceId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function4FunctionType",
        details::PCIeDevice::_property_Function4FunctionType.data(),
        _callback_get_Function4FunctionType,
        _callback_set_Function4FunctionType, vtable::property_::emits_change),
    vtable::property("Function4RevisionId",
                     details::PCIeDevice::_property_Function4RevisionId.data(),
                     _callback_get_Function4RevisionId,
                     _callback_set_Function4RevisionId,
                     vtable::property_::emits_change),
    vtable::property("Function4SubsystemId",
                     details::PCIeDevice::_property_Function4SubsystemId.data(),
                     _callback_get_Function4SubsystemId,
                     _callback_set_Function4SubsystemId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function4SubsystemVendorId",
        details::PCIeDevice::_property_Function4SubsystemVendorId.data(),
        _callback_get_Function4SubsystemVendorId,
        _callback_set_Function4SubsystemVendorId,
        vtable::property_::emits_change),
    vtable::property("Function4VendorId",
                     details::PCIeDevice::_property_Function4VendorId.data(),
                     _callback_get_Function4VendorId,
                     _callback_set_Function4VendorId,
                     vtable::property_::emits_change),
    vtable::property("Function5ClassCode",
                     details::PCIeDevice::_property_Function5ClassCode.data(),
                     _callback_get_Function5ClassCode,
                     _callback_set_Function5ClassCode,
                     vtable::property_::emits_change),
    vtable::property("Function5DeviceClass",
                     details::PCIeDevice::_property_Function5DeviceClass.data(),
                     _callback_get_Function5DeviceClass,
                     _callback_set_Function5DeviceClass,
                     vtable::property_::emits_change),
    vtable::property("Function5DeviceId",
                     details::PCIeDevice::_property_Function5DeviceId.data(),
                     _callback_get_Function5DeviceId,
                     _callback_set_Function5DeviceId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function5FunctionType",
        details::PCIeDevice::_property_Function5FunctionType.data(),
        _callback_get_Function5FunctionType,
        _callback_set_Function5FunctionType, vtable::property_::emits_change),
    vtable::property("Function5RevisionId",
                     details::PCIeDevice::_property_Function5RevisionId.data(),
                     _callback_get_Function5RevisionId,
                     _callback_set_Function5RevisionId,
                     vtable::property_::emits_change),
    vtable::property("Function5SubsystemId",
                     details::PCIeDevice::_property_Function5SubsystemId.data(),
                     _callback_get_Function5SubsystemId,
                     _callback_set_Function5SubsystemId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function5SubsystemVendorId",
        details::PCIeDevice::_property_Function5SubsystemVendorId.data(),
        _callback_get_Function5SubsystemVendorId,
        _callback_set_Function5SubsystemVendorId,
        vtable::property_::emits_change),
    vtable::property("Function5VendorId",
                     details::PCIeDevice::_property_Function5VendorId.data(),
                     _callback_get_Function5VendorId,
                     _callback_set_Function5VendorId,
                     vtable::property_::emits_change),
    vtable::property("Function6ClassCode",
                     details::PCIeDevice::_property_Function6ClassCode.data(),
                     _callback_get_Function6ClassCode,
                     _callback_set_Function6ClassCode,
                     vtable::property_::emits_change),
    vtable::property("Function6DeviceClass",
                     details::PCIeDevice::_property_Function6DeviceClass.data(),
                     _callback_get_Function6DeviceClass,
                     _callback_set_Function6DeviceClass,
                     vtable::property_::emits_change),
    vtable::property("Function6DeviceId",
                     details::PCIeDevice::_property_Function6DeviceId.data(),
                     _callback_get_Function6DeviceId,
                     _callback_set_Function6DeviceId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function6FunctionType",
        details::PCIeDevice::_property_Function6FunctionType.data(),
        _callback_get_Function6FunctionType,
        _callback_set_Function6FunctionType, vtable::property_::emits_change),
    vtable::property("Function6RevisionId",
                     details::PCIeDevice::_property_Function6RevisionId.data(),
                     _callback_get_Function6RevisionId,
                     _callback_set_Function6RevisionId,
                     vtable::property_::emits_change),
    vtable::property("Function6SubsystemId",
                     details::PCIeDevice::_property_Function6SubsystemId.data(),
                     _callback_get_Function6SubsystemId,
                     _callback_set_Function6SubsystemId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function6SubsystemVendorId",
        details::PCIeDevice::_property_Function6SubsystemVendorId.data(),
        _callback_get_Function6SubsystemVendorId,
        _callback_set_Function6SubsystemVendorId,
        vtable::property_::emits_change),
    vtable::property("Function6VendorId",
                     details::PCIeDevice::_property_Function6VendorId.data(),
                     _callback_get_Function6VendorId,
                     _callback_set_Function6VendorId,
                     vtable::property_::emits_change),
    vtable::property("Function7ClassCode",
                     details::PCIeDevice::_property_Function7ClassCode.data(),
                     _callback_get_Function7ClassCode,
                     _callback_set_Function7ClassCode,
                     vtable::property_::emits_change),
    vtable::property("Function7DeviceClass",
                     details::PCIeDevice::_property_Function7DeviceClass.data(),
                     _callback_get_Function7DeviceClass,
                     _callback_set_Function7DeviceClass,
                     vtable::property_::emits_change),
    vtable::property("Function7DeviceId",
                     details::PCIeDevice::_property_Function7DeviceId.data(),
                     _callback_get_Function7DeviceId,
                     _callback_set_Function7DeviceId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function7FunctionType",
        details::PCIeDevice::_property_Function7FunctionType.data(),
        _callback_get_Function7FunctionType,
        _callback_set_Function7FunctionType, vtable::property_::emits_change),
    vtable::property("Function7RevisionId",
                     details::PCIeDevice::_property_Function7RevisionId.data(),
                     _callback_get_Function7RevisionId,
                     _callback_set_Function7RevisionId,
                     vtable::property_::emits_change),
    vtable::property("Function7SubsystemId",
                     details::PCIeDevice::_property_Function7SubsystemId.data(),
                     _callback_get_Function7SubsystemId,
                     _callback_set_Function7SubsystemId,
                     vtable::property_::emits_change),
    vtable::property(
        "Function7SubsystemVendorId",
        details::PCIeDevice::_property_Function7SubsystemVendorId.data(),
        _callback_get_Function7SubsystemVendorId,
        _callback_set_Function7SubsystemVendorId,
        vtable::property_::emits_change),
    vtable::property("Function7VendorId",
                     details::PCIeDevice::_property_Function7VendorId.data(),
                     _callback_get_Function7VendorId,
                     _callback_set_Function7VendorId,
                     vtable::property_::emits_change),
    vtable::property("Manufacturer",
                     details::PCIeDevice::_property_Manufacturer.data(),
                     _callback_get_Manufacturer, _callback_set_Manufacturer,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/Ethernet/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Item
{
namespace server
{

Ethernet::Ethernet(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_Ethernet_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t Ethernet::_vtable[] = {vtable::start(), vtable::end()};

} // namespace server
} // namespace Item
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Manager/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace server
{

Manager::Manager(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Manager_interface(bus, path, _interface,
                                                     _vtable, this),
    _intf(bus.getInterface())
{
}

int Manager::_callback_Notify(sd_bus_message* msg, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::map<sdbusplus::message::object_path,
                 std::map<std::string,
                          std::map<std::string,
                                   std::variant<bool, int64_t, std::string>>>>
            object{};

        m.read(object);

        auto o = static_cast<Manager*>(context);
        o->notify(object);

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Manager
{
static const auto _param_Notify = utility::tuple_to_array(
    message::types::type_id<std::map<
        sdbusplus::message::object_path,
        std::map<std::string,
                 std::map<std::string,
                          std::variant<bool, int64_t, std::string>>>>>());
static const auto _return_Notify =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Manager
} // namespace details

const vtable::vtable_t Manager::_vtable[] = {
    vtable::start(),

    vtable::method("Notify", details::Manager::_param_Notify.data(),
                   details::Manager::_return_Notify.data(), _callback_Notify),
    vtable::end()};

} // namespace server
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Item/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace server
{

Item::Item(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Item_interface(bus, path, _interface,
                                                  _vtable, this),
    _intf(bus.getInterface())
{
}

Item::Item(bus::bus& bus, const char* path,
           const std::map<std::string, PropertiesVariant>& vals,
           bool skipSignal) :
    Item(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Item::prettyName() const -> std::string
{
    return _prettyName;
}

int Item::_callback_get_PrettyName(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Item*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->prettyName()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Item::prettyName(std::string value, bool skipSignal) -> std::string
{
    if (_prettyName != value)
    {
        _prettyName = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_interface.property_changed(
                "PrettyName");
        }
    }

    return _prettyName;
}

auto Item::prettyName(std::string val) -> std::string
{
    return prettyName(val, false);
}
int Item::_callback_set_PrettyName(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Item*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->prettyName(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Item
{
static const auto _property_PrettyName =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Item::present() const -> bool
{
    return _present;
}

int Item::_callback_get_Present(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* reply, void* context,
                                sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Item*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->present()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Item::present(bool value, bool skipSignal) -> bool
{
    if (_present != value)
    {
        _present = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Item_interface.property_changed(
                "Present");
        }
    }

    return _present;
}

auto Item::present(bool val) -> bool
{
    return present(val, false);
}
int Item::_callback_set_Present(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* value, void* context,
                                sd_bus_error* error)
{
    auto o = static_cast<Item*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->present(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Item
{
static const auto _property_Present =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Item::setPropertyByName(const std::string& _name,
                             const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "PrettyName")
    {
        auto& v = std::get<std::string>(val);
        prettyName(v, skipSignal);
        return;
    }
    if (_name == "Present")
    {
        auto& v = std::get<bool>(val);
        present(v, skipSignal);
        return;
    }
}

auto Item::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "PrettyName")
    {
        return prettyName();
    }
    if (_name == "Present")
    {
        return present();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Item::_vtable[] = {
    vtable::start(),
    vtable::property("PrettyName", details::Item::_property_PrettyName.data(),
                     _callback_get_PrettyName, _callback_set_PrettyName,
                     vtable::property_::emits_change),
    vtable::property("Present", details::Item::_property_Present.data(),
                     _callback_get_Present, _callback_set_Present,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/Asset/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

Asset::Asset(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_Asset_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Asset::Asset(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Asset(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Asset::partNumber() const -> std::string
{
    return _partNumber;
}

int Asset::_callback_get_PartNumber(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* reply, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->partNumber()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Asset::partNumber(std::string value, bool skipSignal) -> std::string
{
    if (_partNumber != value)
    {
        _partNumber = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_Asset_interface
                .property_changed("PartNumber");
        }
    }

    return _partNumber;
}

auto Asset::partNumber(std::string val) -> std::string
{
    return partNumber(val, false);
}
int Asset::_callback_set_PartNumber(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* value, void* context,
                                    sd_bus_error* error)
{
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->partNumber(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Asset
{
static const auto _property_PartNumber =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Asset::serialNumber() const -> std::string
{
    return _serialNumber;
}

int Asset::_callback_get_SerialNumber(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->serialNumber()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Asset::serialNumber(std::string value, bool skipSignal) -> std::string
{
    if (_serialNumber != value)
    {
        _serialNumber = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_Asset_interface
                .property_changed("SerialNumber");
        }
    }

    return _serialNumber;
}

auto Asset::serialNumber(std::string val) -> std::string
{
    return serialNumber(val, false);
}
int Asset::_callback_set_SerialNumber(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->serialNumber(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Asset
{
static const auto _property_SerialNumber =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Asset::manufacturer() const -> std::string
{
    return _manufacturer;
}

int Asset::_callback_get_Manufacturer(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->manufacturer()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Asset::manufacturer(std::string value, bool skipSignal) -> std::string
{
    if (_manufacturer != value)
    {
        _manufacturer = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_Asset_interface
                .property_changed("Manufacturer");
        }
    }

    return _manufacturer;
}

auto Asset::manufacturer(std::string val) -> std::string
{
    return manufacturer(val, false);
}
int Asset::_callback_set_Manufacturer(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->manufacturer(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Asset
{
static const auto _property_Manufacturer =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Asset::buildDate() const -> std::string
{
    return _buildDate;
}

int Asset::_callback_get_BuildDate(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->buildDate()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Asset::buildDate(std::string value, bool skipSignal) -> std::string
{
    if (_buildDate != value)
    {
        _buildDate = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_Asset_interface
                .property_changed("BuildDate");
        }
    }

    return _buildDate;
}

auto Asset::buildDate(std::string val) -> std::string
{
    return buildDate(val, false);
}
int Asset::_callback_set_BuildDate(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->buildDate(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Asset
{
static const auto _property_BuildDate =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Asset::model() const -> std::string
{
    return _model;
}

int Asset::_callback_get_Model(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->model()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Asset::model(std::string value, bool skipSignal) -> std::string
{
    if (_model != value)
    {
        _model = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_Asset_interface
                .property_changed("Model");
        }
    }

    return _model;
}

auto Asset::model(std::string val) -> std::string
{
    return model(val, false);
}
int Asset::_callback_set_Model(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<Asset*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->model(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Asset
{
static const auto _property_Model =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Asset::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "PartNumber")
    {
        auto& v = std::get<std::string>(val);
        partNumber(v, skipSignal);
        return;
    }
    if (_name == "SerialNumber")
    {
        auto& v = std::get<std::string>(val);
        serialNumber(v, skipSignal);
        return;
    }
    if (_name == "Manufacturer")
    {
        auto& v = std::get<std::string>(val);
        manufacturer(v, skipSignal);
        return;
    }
    if (_name == "BuildDate")
    {
        auto& v = std::get<std::string>(val);
        buildDate(v, skipSignal);
        return;
    }
    if (_name == "Model")
    {
        auto& v = std::get<std::string>(val);
        model(v, skipSignal);
        return;
    }
}

auto Asset::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "PartNumber")
    {
        return partNumber();
    }
    if (_name == "SerialNumber")
    {
        return serialNumber();
    }
    if (_name == "Manufacturer")
    {
        return manufacturer();
    }
    if (_name == "BuildDate")
    {
        return buildDate();
    }
    if (_name == "Model")
    {
        return model();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Asset::_vtable[] = {
    vtable::start(),
    vtable::property("PartNumber", details::Asset::_property_PartNumber.data(),
                     _callback_get_PartNumber, _callback_set_PartNumber,
                     vtable::property_::emits_change),
    vtable::property("SerialNumber",
                     details::Asset::_property_SerialNumber.data(),
                     _callback_get_SerialNumber, _callback_set_SerialNumber,
                     vtable::property_::emits_change),
    vtable::property("Manufacturer",
                     details::Asset::_property_Manufacturer.data(),
                     _callback_get_Manufacturer, _callback_set_Manufacturer,
                     vtable::property_::emits_change),
    vtable::property("BuildDate", details::Asset::_property_BuildDate.data(),
                     _callback_get_BuildDate, _callback_set_BuildDate,
                     vtable::property_::emits_change),
    vtable::property("Model", details::Asset::_property_Model.data(),
                     _callback_get_Model, _callback_set_Model,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/VoltageControl/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

VoltageControl::VoltageControl(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_VoltageControl_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t VoltageControl::_vtable[] = {vtable::start(),
                                                    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/CoolingType/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

CoolingType::CoolingType(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_CoolingType_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

CoolingType::CoolingType(bus::bus& bus, const char* path,
                         const std::map<std::string, PropertiesVariant>& vals,
                         bool skipSignal) :
    CoolingType(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto CoolingType::airCooled() const -> bool
{
    return _airCooled;
}

int CoolingType::_callback_get_AirCooled(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<CoolingType*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->airCooled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto CoolingType::airCooled(bool value, bool skipSignal) -> bool
{
    if (_airCooled != value)
    {
        _airCooled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_CoolingType_interface
                .property_changed("AirCooled");
        }
    }

    return _airCooled;
}

auto CoolingType::airCooled(bool val) -> bool
{
    return airCooled(val, false);
}
int CoolingType::_callback_set_AirCooled(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<CoolingType*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->airCooled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace CoolingType
{
static const auto _property_AirCooled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto CoolingType::waterCooled() const -> bool
{
    return _waterCooled;
}

int CoolingType::_callback_get_WaterCooled(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<CoolingType*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->waterCooled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto CoolingType::waterCooled(bool value, bool skipSignal) -> bool
{
    if (_waterCooled != value)
    {
        _waterCooled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_CoolingType_interface
                .property_changed("WaterCooled");
        }
    }

    return _waterCooled;
}

auto CoolingType::waterCooled(bool val) -> bool
{
    return waterCooled(val, false);
}
int CoolingType::_callback_set_WaterCooled(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<CoolingType*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->waterCooled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace CoolingType
{
static const auto _property_WaterCooled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void CoolingType::setPropertyByName(const std::string& _name,
                                    const PropertiesVariant& val,
                                    bool skipSignal)
{
    if (_name == "AirCooled")
    {
        auto& v = std::get<bool>(val);
        airCooled(v, skipSignal);
        return;
    }
    if (_name == "WaterCooled")
    {
        auto& v = std::get<bool>(val);
        waterCooled(v, skipSignal);
        return;
    }
}

auto CoolingType::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "AirCooled")
    {
        return airCooled();
    }
    if (_name == "WaterCooled")
    {
        return waterCooled();
    }

    return PropertiesVariant();
}

const vtable::vtable_t CoolingType::_vtable[] = {
    vtable::start(),
    vtable::property("AirCooled",
                     details::CoolingType::_property_AirCooled.data(),
                     _callback_get_AirCooled, _callback_set_AirCooled,
                     vtable::property_::emits_change),
    vtable::property("WaterCooled",
                     details::CoolingType::_property_WaterCooled.data(),
                     _callback_get_WaterCooled, _callback_set_WaterCooled,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/Replaceable/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

Replaceable::Replaceable(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_Replaceable_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Replaceable::Replaceable(bus::bus& bus, const char* path,
                         const std::map<std::string, PropertiesVariant>& vals,
                         bool skipSignal) :
    Replaceable(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Replaceable::fieldReplaceable() const -> bool
{
    return _fieldReplaceable;
}

int Replaceable::_callback_get_FieldReplaceable(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Replaceable*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->fieldReplaceable()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Replaceable::fieldReplaceable(bool value, bool skipSignal) -> bool
{
    if (_fieldReplaceable != value)
    {
        _fieldReplaceable = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_Replaceable_interface
                .property_changed("FieldReplaceable");
        }
    }

    return _fieldReplaceable;
}

auto Replaceable::fieldReplaceable(bool val) -> bool
{
    return fieldReplaceable(val, false);
}
int Replaceable::_callback_set_FieldReplaceable(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Replaceable*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->fieldReplaceable(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Replaceable
{
static const auto _property_FieldReplaceable =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Replaceable::setPropertyByName(const std::string& _name,
                                    const PropertiesVariant& val,
                                    bool skipSignal)
{
    if (_name == "FieldReplaceable")
    {
        auto& v = std::get<bool>(val);
        fieldReplaceable(v, skipSignal);
        return;
    }
}

auto Replaceable::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "FieldReplaceable")
    {
        return fieldReplaceable();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Replaceable::_vtable[] = {
    vtable::start(),
    vtable::property("FieldReplaceable",
                     details::Replaceable::_property_FieldReplaceable.data(),
                     _callback_get_FieldReplaceable,
                     _callback_set_FieldReplaceable,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/MeetsMinimumShipLevel/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

MeetsMinimumShipLevel::MeetsMinimumShipLevel(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_MeetsMinimumShipLevel_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

MeetsMinimumShipLevel::MeetsMinimumShipLevel(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    MeetsMinimumShipLevel(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto MeetsMinimumShipLevel::meetsMinimumShipLevel() const -> bool
{
    return _meetsMinimumShipLevel;
}

int MeetsMinimumShipLevel::_callback_get_MeetsMinimumShipLevel(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<MeetsMinimumShipLevel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->meetsMinimumShipLevel()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto MeetsMinimumShipLevel::meetsMinimumShipLevel(bool value, bool skipSignal)
    -> bool
{
    if (_meetsMinimumShipLevel != value)
    {
        _meetsMinimumShipLevel = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_MeetsMinimumShipLevel_interface
                .property_changed("MeetsMinimumShipLevel");
        }
    }

    return _meetsMinimumShipLevel;
}

auto MeetsMinimumShipLevel::meetsMinimumShipLevel(bool val) -> bool
{
    return meetsMinimumShipLevel(val, false);
}
int MeetsMinimumShipLevel::_callback_set_MeetsMinimumShipLevel(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<MeetsMinimumShipLevel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->meetsMinimumShipLevel(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace MeetsMinimumShipLevel
{
static const auto _property_MeetsMinimumShipLevel =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void MeetsMinimumShipLevel::setPropertyByName(const std::string& _name,
                                              const PropertiesVariant& val,
                                              bool skipSignal)
{
    if (_name == "MeetsMinimumShipLevel")
    {
        auto& v = std::get<bool>(val);
        meetsMinimumShipLevel(v, skipSignal);
        return;
    }
}

auto MeetsMinimumShipLevel::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "MeetsMinimumShipLevel")
    {
        return meetsMinimumShipLevel();
    }

    return PropertiesVariant();
}

const vtable::vtable_t MeetsMinimumShipLevel::_vtable[] = {
    vtable::start(),
    vtable::property(
        "MeetsMinimumShipLevel",
        details::MeetsMinimumShipLevel::_property_MeetsMinimumShipLevel.data(),
        _callback_get_MeetsMinimumShipLevel,
        _callback_set_MeetsMinimumShipLevel, vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/AssetTag/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

AssetTag::AssetTag(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_AssetTag_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

AssetTag::AssetTag(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    AssetTag(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto AssetTag::assetTag() const -> std::string
{
    return _assetTag;
}

int AssetTag::_callback_get_AssetTag(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<AssetTag*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->assetTag()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto AssetTag::assetTag(std::string value, bool skipSignal) -> std::string
{
    if (_assetTag != value)
    {
        _assetTag = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_AssetTag_interface
                .property_changed("AssetTag");
        }
    }

    return _assetTag;
}

auto AssetTag::assetTag(std::string val) -> std::string
{
    return assetTag(val, false);
}
int AssetTag::_callback_set_AssetTag(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<AssetTag*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->assetTag(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace AssetTag
{
static const auto _property_AssetTag =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void AssetTag::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "AssetTag")
    {
        auto& v = std::get<std::string>(val);
        assetTag(v, skipSignal);
        return;
    }
}

auto AssetTag::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "AssetTag")
    {
        return assetTag();
    }

    return PropertiesVariant();
}

const vtable::vtable_t AssetTag::_vtable[] = {
    vtable::start(),
    vtable::property("AssetTag", details::AssetTag::_property_AssetTag.data(),
                     _callback_get_AssetTag, _callback_set_AssetTag,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/Cacheable/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

Cacheable::Cacheable(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_Cacheable_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Cacheable::Cacheable(bus::bus& bus, const char* path,
                     const std::map<std::string, PropertiesVariant>& vals,
                     bool skipSignal) :
    Cacheable(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Cacheable::cached() const -> bool
{
    return _cached;
}

int Cacheable::_callback_get_Cached(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* reply, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Cacheable*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->cached()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Cacheable::cached(bool value, bool skipSignal) -> bool
{
    if (_cached != value)
    {
        _cached = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_Cacheable_interface
                .property_changed("Cached");
        }
    }

    return _cached;
}

auto Cacheable::cached(bool val) -> bool
{
    return cached(val, false);
}
int Cacheable::_callback_set_Cached(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* value, void* context,
                                    sd_bus_error* error)
{
    auto o = static_cast<Cacheable*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->cached(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Cacheable
{
static const auto _property_Cached =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Cacheable::setPropertyByName(const std::string& _name,
                                  const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Cached")
    {
        auto& v = std::get<bool>(val);
        cached(v, skipSignal);
        return;
    }
}

auto Cacheable::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Cached")
    {
        return cached();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Cacheable::_vtable[] = {
    vtable::start(),
    vtable::property("Cached", details::Cacheable::_property_Cached.data(),
                     _callback_get_Cached, _callback_set_Cached,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/Revision/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

Revision::Revision(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_Revision_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Revision::Revision(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    Revision(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Revision::version() const -> std::string
{
    return _version;
}

int Revision::_callback_get_Version(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* reply, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Revision*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->version()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Revision::version(std::string value, bool skipSignal) -> std::string
{
    if (_version != value)
    {
        _version = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_Revision_interface
                .property_changed("Version");
        }
    }

    return _version;
}

auto Revision::version(std::string val) -> std::string
{
    return version(val, false);
}
int Revision::_callback_set_Version(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* value, void* context,
                                    sd_bus_error* error)
{
    auto o = static_cast<Revision*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->version(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Revision
{
static const auto _property_Version =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Revision::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Version")
    {
        auto& v = std::get<std::string>(val);
        version(v, skipSignal);
        return;
    }
}

auto Revision::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Version")
    {
        return version();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Revision::_vtable[] = {
    vtable::start(),
    vtable::property("Version", details::Revision::_property_Version.data(),
                     _callback_get_Version, _callback_set_Version,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Inventory/Decorator/VendorInformation/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Decorator
{
namespace server
{

VendorInformation::VendorInformation(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Inventory_Decorator_VendorInformation_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

VendorInformation::VendorInformation(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    VendorInformation(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto VendorInformation::customField1() const -> std::string
{
    return _customField1;
}

int VendorInformation::_callback_get_CustomField1(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<VendorInformation*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->customField1()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto VendorInformation::customField1(std::string value, bool skipSignal)
    -> std::string
{
    if (_customField1 != value)
    {
        _customField1 = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_VendorInformation_interface
                .property_changed("CustomField1");
        }
    }

    return _customField1;
}

auto VendorInformation::customField1(std::string val) -> std::string
{
    return customField1(val, false);
}
int VendorInformation::_callback_set_CustomField1(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<VendorInformation*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->customField1(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace VendorInformation
{
static const auto _property_CustomField1 =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto VendorInformation::customField2() const -> std::string
{
    return _customField2;
}

int VendorInformation::_callback_get_CustomField2(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<VendorInformation*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->customField2()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto VendorInformation::customField2(std::string value, bool skipSignal)
    -> std::string
{
    if (_customField2 != value)
    {
        _customField2 = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Inventory_Decorator_VendorInformation_interface
                .property_changed("CustomField2");
        }
    }

    return _customField2;
}

auto VendorInformation::customField2(std::string val) -> std::string
{
    return customField2(val, false);
}
int VendorInformation::_callback_set_CustomField2(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<VendorInformation*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->customField2(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace VendorInformation
{
static const auto _property_CustomField2 =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void VendorInformation::setPropertyByName(const std::string& _name,
                                          const PropertiesVariant& val,
                                          bool skipSignal)
{
    if (_name == "CustomField1")
    {
        auto& v = std::get<std::string>(val);
        customField1(v, skipSignal);
        return;
    }
    if (_name == "CustomField2")
    {
        auto& v = std::get<std::string>(val);
        customField2(v, skipSignal);
        return;
    }
}

auto VendorInformation::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "CustomField1")
    {
        return customField1();
    }
    if (_name == "CustomField2")
    {
        return customField2();
    }

    return PropertiesVariant();
}

const vtable::vtable_t VendorInformation::_vtable[] = {
    vtable::start(),
    vtable::property("CustomField1",
                     details::VendorInformation::_property_CustomField1.data(),
                     _callback_get_CustomField1, _callback_set_CustomField1,
                     vtable::property_::emits_change),
    vtable::property("CustomField2",
                     details::VendorInformation::_property_CustomField2.data(),
                     _callback_get_CustomField2, _callback_set_CustomField2,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Association/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace server
{

Association::Association(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Association_interface(bus, path, _interface, _vtable,
                                               this),
    _intf(bus.getInterface())
{
}

Association::Association(bus::bus& bus, const char* path,
                         const std::map<std::string, PropertiesVariant>& vals,
                         bool skipSignal) :
    Association(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Association::endpoints() const
    -> std::vector<sdbusplus::message::object_path>
{
    return _endpoints;
}

int Association::_callback_get_Endpoints(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Association*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->endpoints()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Association::endpoints(std::vector<sdbusplus::message::object_path> value,
                            bool skipSignal)
    -> std::vector<sdbusplus::message::object_path>
{
    if (_endpoints != value)
    {
        _endpoints = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Association_interface.property_changed(
                "Endpoints");
        }
    }

    return _endpoints;
}

auto Association::endpoints(std::vector<sdbusplus::message::object_path> val)
    -> std::vector<sdbusplus::message::object_path>
{
    return endpoints(val, false);
}
int Association::_callback_set_Endpoints(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Association*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<sdbusplus::message::object_path> v{};
        m.read(v);
        o->endpoints(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Association
{
static const auto _property_Endpoints = utility::tuple_to_array(
    message::types::type_id<std::vector<sdbusplus::message::object_path>>());
}
} // namespace details

void Association::setPropertyByName(const std::string& _name,
                                    const PropertiesVariant& val,
                                    bool skipSignal)
{
    if (_name == "Endpoints")
    {
        auto& v = std::get<std::vector<sdbusplus::message::object_path>>(val);
        endpoints(v, skipSignal);
        return;
    }
}

auto Association::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "Endpoints")
    {
        return endpoints();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Association::_vtable[] = {
    vtable::start(),
    vtable::property("Endpoints",
                     details::Association::_property_Endpoints.data(),
                     _callback_get_Endpoints, _callback_set_Endpoints,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/ObjectMapper/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace server
{

ObjectMapper::ObjectMapper(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_ObjectMapper_interface(bus, path, _interface, _vtable,
                                                this),
    _intf(bus.getInterface())
{
}

int ObjectMapper::_callback_GetObject(sd_bus_message* msg, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        sdbusplus::message::object_path path{};
        std::vector<std::string> interfaces{};

        m.read(path, interfaces);

        auto o = static_cast<ObjectMapper*>(context);
        auto r = o->getObject(path, interfaces);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ObjectMapper
{
static const auto _param_GetObject = utility::tuple_to_array(
    message::types::type_id<sdbusplus::message::object_path,
                            std::vector<std::string>>());
static const auto _return_GetObject = utility::tuple_to_array(
    message::types::type_id<std::map<std::string, std::vector<std::string>>>());
} // namespace ObjectMapper
} // namespace details

int ObjectMapper::_callback_GetAncestors(sd_bus_message* msg, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        sdbusplus::message::object_path path{};
        std::vector<std::string> interfaces{};

        m.read(path, interfaces);

        auto o = static_cast<ObjectMapper*>(context);
        auto r = o->getAncestors(path, interfaces);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ObjectMapper
{
static const auto _param_GetAncestors = utility::tuple_to_array(
    message::types::type_id<sdbusplus::message::object_path,
                            std::vector<std::string>>());
static const auto _return_GetAncestors = utility::tuple_to_array(
    message::types::type_id<
        std::map<sdbusplus::message::object_path,
                 std::map<std::string, std::vector<std::string>>>>());
} // namespace ObjectMapper
} // namespace details

int ObjectMapper::_callback_GetSubTree(sd_bus_message* msg, void* context,
                                       sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        sdbusplus::message::object_path subtree{};
        int32_t depth{};
        std::vector<std::string> interfaces{};

        m.read(subtree, depth, interfaces);

        auto o = static_cast<ObjectMapper*>(context);
        auto r = o->getSubTree(subtree, depth, interfaces);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ObjectMapper
{
static const auto _param_GetSubTree = utility::tuple_to_array(
    message::types::type_id<sdbusplus::message::object_path, int32_t,
                            std::vector<std::string>>());
static const auto _return_GetSubTree = utility::tuple_to_array(
    message::types::type_id<
        std::map<sdbusplus::message::object_path,
                 std::map<std::string, std::vector<std::string>>>>());
} // namespace ObjectMapper
} // namespace details

int ObjectMapper::_callback_GetSubTreePaths(sd_bus_message* msg, void* context,
                                            sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        sdbusplus::message::object_path subtree{};
        int32_t depth{};
        std::vector<std::string> interfaces{};

        m.read(subtree, depth, interfaces);

        auto o = static_cast<ObjectMapper*>(context);
        auto r = o->getSubTreePaths(subtree, depth, interfaces);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ObjectMapper
{
static const auto _param_GetSubTreePaths = utility::tuple_to_array(
    message::types::type_id<sdbusplus::message::object_path, int32_t,
                            std::vector<std::string>>());
static const auto _return_GetSubTreePaths = utility::tuple_to_array(
    message::types::type_id<std::vector<sdbusplus::message::object_path>>());
} // namespace ObjectMapper
} // namespace details

const vtable::vtable_t ObjectMapper::_vtable[] = {
    vtable::start(),

    vtable::method("GetObject", details::ObjectMapper::_param_GetObject.data(),
                   details::ObjectMapper::_return_GetObject.data(),
                   _callback_GetObject),

    vtable::method("GetAncestors",
                   details::ObjectMapper::_param_GetAncestors.data(),
                   details::ObjectMapper::_return_GetAncestors.data(),
                   _callback_GetAncestors),

    vtable::method(
        "GetSubTree", details::ObjectMapper::_param_GetSubTree.data(),
        details::ObjectMapper::_return_GetSubTree.data(), _callback_GetSubTree),

    vtable::method("GetSubTreePaths",
                   details::ObjectMapper::_param_GetSubTreePaths.data(),
                   details::ObjectMapper::_return_GetSubTreePaths.data(),
                   _callback_GetSubTreePaths),
    vtable::end()};

} // namespace server
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Association/Definitions/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Association
{
namespace server
{

Definitions::Definitions(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Association_Definitions_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Definitions::Definitions(bus::bus& bus, const char* path,
                         const std::map<std::string, PropertiesVariant>& vals,
                         bool skipSignal) :
    Definitions(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Definitions::associations() const
    -> std::vector<std::tuple<std::string, std::string, std::string>>
{
    return _associations;
}

int Definitions::_callback_get_Associations(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Definitions*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->associations()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Definitions::associations(
    std::vector<std::tuple<std::string, std::string, std::string>> value,
    bool skipSignal)
    -> std::vector<std::tuple<std::string, std::string, std::string>>
{
    if (_associations != value)
    {
        _associations = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Association_Definitions_interface
                .property_changed("Associations");
        }
    }

    return _associations;
}

auto Definitions::associations(
    std::vector<std::tuple<std::string, std::string, std::string>> val)
    -> std::vector<std::tuple<std::string, std::string, std::string>>
{
    return associations(val, false);
}
int Definitions::_callback_set_Associations(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<Definitions*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::tuple<std::string, std::string, std::string>> v{};
        m.read(v);
        o->associations(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Definitions
{
static const auto _property_Associations = utility::tuple_to_array(
    message::types::type_id<
        std::vector<std::tuple<std::string, std::string, std::string>>>());
}
} // namespace details

void Definitions::setPropertyByName(const std::string& _name,
                                    const PropertiesVariant& val,
                                    bool skipSignal)
{
    if (_name == "Associations")
    {
        auto& v = std::get<
            std::vector<std::tuple<std::string, std::string, std::string>>>(
            val);
        associations(v, skipSignal);
        return;
    }
}

auto Definitions::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "Associations")
    {
        return associations();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Definitions::_vtable[] = {
    vtable::start(),
    vtable::property("Associations",
                     details::Definitions::_property_Associations.data(),
                     _callback_get_Associations, _callback_set_Associations,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Association
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Channel/ChannelAccess/server.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Channel
{
namespace server
{

ChannelAccess::ChannelAccess(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Channel_ChannelAccess_interface(bus, path, _interface,
                                                         _vtable, this),
    _intf(bus.getInterface())
{
}

ChannelAccess::ChannelAccess(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    ChannelAccess(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto ChannelAccess::maxPrivilege() const -> std::string
{
    return _maxPrivilege;
}

int ChannelAccess::_callback_get_MaxPrivilege(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ChannelAccess*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->maxPrivilege()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ChannelAccess::maxPrivilege(std::string value, bool skipSignal)
    -> std::string
{
    if (_maxPrivilege != value)
    {
        _maxPrivilege = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Channel_ChannelAccess_interface
                .property_changed("MaxPrivilege");
        }
    }

    return _maxPrivilege;
}

auto ChannelAccess::maxPrivilege(std::string val) -> std::string
{
    return maxPrivilege(val, false);
}
int ChannelAccess::_callback_set_MaxPrivilege(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ChannelAccess*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->maxPrivilege(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ChannelAccess
{
static const auto _property_MaxPrivilege =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void ChannelAccess::setPropertyByName(const std::string& _name,
                                      const PropertiesVariant& val,
                                      bool skipSignal)
{
    if (_name == "MaxPrivilege")
    {
        auto& v = std::get<std::string>(val);
        maxPrivilege(v, skipSignal);
        return;
    }
}

auto ChannelAccess::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "MaxPrivilege")
    {
        return maxPrivilege();
    }

    return PropertiesVariant();
}

const vtable::vtable_t ChannelAccess::_vtable[] = {
    vtable::start(),
    vtable::property("MaxPrivilege",
                     details::ChannelAccess::_property_MaxPrivilege.data(),
                     _callback_get_MaxPrivilege, _callback_set_MaxPrivilege,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Channel
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Chassis/Intrusion/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace server
{

Intrusion::Intrusion(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Chassis_Intrusion_interface(bus, path, _interface,
                                                     _vtable, this),
    _intf(bus.getInterface())
{
}

Intrusion::Intrusion(bus::bus& bus, const char* path,
                     const std::map<std::string, PropertiesVariant>& vals,
                     bool skipSignal) :
    Intrusion(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Intrusion::status() const -> std::string
{
    return _status;
}

int Intrusion::_callback_get_Status(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* reply, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Intrusion*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->status()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Intrusion::status(std::string value, bool skipSignal) -> std::string
{
    if (_status != value)
    {
        _status = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Chassis_Intrusion_interface.property_changed(
                "Status");
        }
    }

    return _status;
}

auto Intrusion::status(std::string val) -> std::string
{
    return status(val, false);
}
int Intrusion::_callback_set_Status(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* value, void* context,
                                    sd_bus_error* error)
{
    auto o = static_cast<Intrusion*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->status(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Intrusion
{
static const auto _property_Status =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Intrusion::setPropertyByName(const std::string& _name,
                                  const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Status")
    {
        auto& v = std::get<std::string>(val);
        status(v, skipSignal);
        return;
    }
}

auto Intrusion::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Status")
    {
        return status();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Intrusion::_vtable[] = {
    vtable::start(),
    vtable::property("Status", details::Intrusion::_property_Status.data(),
                     _callback_get_Status, _callback_set_Status,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Chassis/Buttons/NMI/server.hpp>
#include <xyz/openbmc_project/Chassis/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Buttons
{
namespace server
{

NMI::NMI(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Chassis_Buttons_NMI_interface(bus, path, _interface,
                                                       _vtable, this),
    _intf(bus.getInterface())
{
}

NMI::NMI(bus::bus& bus, const char* path,
         const std::map<std::string, PropertiesVariant>& vals,
         bool skipSignal) :
    NMI(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

int NMI::_callback_SimPress(sd_bus_message* msg, void* context,
                            sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<NMI*>(context);
        o->simPress();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace NMI
{
static const auto _param_SimPress =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_SimPress =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace NMI
} // namespace details

void NMI::released()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_NMI_interface;
    auto m = i.new_signal("Released");

    m.append();
    m.signal_send();
}

namespace details
{
namespace NMI
{
static const auto _signal_Released =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

void NMI::pressed()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_NMI_interface;
    auto m = i.new_signal("Pressed");

    m.append();
    m.signal_send();
}

namespace details
{
namespace NMI
{
static const auto _signal_Pressed =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

auto NMI::enabled() const -> bool
{
    return _enabled;
}

int NMI::_callback_get_Enabled(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<NMI*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->enabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto NMI::enabled(bool value, bool skipSignal) -> bool
{
    if (_enabled != value)
    {
        _enabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Chassis_Buttons_NMI_interface.property_changed(
                "Enabled");
        }
    }

    return _enabled;
}

auto NMI::enabled(bool val) -> bool
{
    return enabled(val, false);
}
int NMI::_callback_set_Enabled(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<NMI*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->enabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace NMI
{
static const auto _property_Enabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void NMI::setPropertyByName(const std::string& _name,
                            const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Enabled")
    {
        auto& v = std::get<bool>(val);
        enabled(v, skipSignal);
        return;
    }
}

auto NMI::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Enabled")
    {
        return enabled();
    }

    return PropertiesVariant();
}

const vtable::vtable_t NMI::_vtable[] = {
    vtable::start(),

    vtable::method("simPress", details::NMI::_param_SimPress.data(),
                   details::NMI::_return_SimPress.data(), _callback_SimPress),

    vtable::signal("Released", details::NMI::_signal_Released.data()),

    vtable::signal("Pressed", details::NMI::_signal_Pressed.data()),
    vtable::property("Enabled", details::NMI::_property_Enabled.data(),
                     _callback_get_Enabled, _callback_set_Enabled,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Buttons
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Chassis/Buttons/Reset/server.hpp>
#include <xyz/openbmc_project/Chassis/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Buttons
{
namespace server
{

Reset::Reset(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Chassis_Buttons_Reset_interface(bus, path, _interface,
                                                         _vtable, this),
    _intf(bus.getInterface())
{
}

Reset::Reset(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Reset(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

int Reset::_callback_SimPress(sd_bus_message* msg, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<Reset*>(context);
        o->simPress();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Reset
{
static const auto _param_SimPress =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_SimPress =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Reset
} // namespace details

void Reset::released()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_Reset_interface;
    auto m = i.new_signal("Released");

    m.append();
    m.signal_send();
}

namespace details
{
namespace Reset
{
static const auto _signal_Released =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

void Reset::pressed()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_Reset_interface;
    auto m = i.new_signal("Pressed");

    m.append();
    m.signal_send();
}

namespace details
{
namespace Reset
{
static const auto _signal_Pressed =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

auto Reset::enabled() const -> bool
{
    return _enabled;
}

int Reset::_callback_get_Enabled(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Reset*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->enabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Reset::enabled(bool value, bool skipSignal) -> bool
{
    if (_enabled != value)
    {
        _enabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Chassis_Buttons_Reset_interface
                .property_changed("Enabled");
        }
    }

    return _enabled;
}

auto Reset::enabled(bool val) -> bool
{
    return enabled(val, false);
}
int Reset::_callback_set_Enabled(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<Reset*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->enabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Reset
{
static const auto _property_Enabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Reset::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Enabled")
    {
        auto& v = std::get<bool>(val);
        enabled(v, skipSignal);
        return;
    }
}

auto Reset::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Enabled")
    {
        return enabled();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Reset::_vtable[] = {
    vtable::start(),

    vtable::method("simPress", details::Reset::_param_SimPress.data(),
                   details::Reset::_return_SimPress.data(), _callback_SimPress),

    vtable::signal("Released", details::Reset::_signal_Released.data()),

    vtable::signal("Pressed", details::Reset::_signal_Pressed.data()),
    vtable::property("Enabled", details::Reset::_property_Enabled.data(),
                     _callback_get_Enabled, _callback_set_Enabled,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Buttons
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Chassis/Buttons/ID/server.hpp>
#include <xyz/openbmc_project/Chassis/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Buttons
{
namespace server
{

ID::ID(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Chassis_Buttons_ID_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

int ID::_callback_SimPress(sd_bus_message* msg, void* context,
                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<ID*>(context);
        o->simPress();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ID
{
static const auto _param_SimPress =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_SimPress =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace ID
} // namespace details

void ID::released()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_ID_interface;
    auto m = i.new_signal("Released");

    m.append();
    m.signal_send();
}

namespace details
{
namespace ID
{
static const auto _signal_Released =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

void ID::pressed()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_ID_interface;
    auto m = i.new_signal("Pressed");

    m.append();
    m.signal_send();
}

namespace details
{
namespace ID
{
static const auto _signal_Pressed =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

const vtable::vtable_t ID::_vtable[] = {
    vtable::start(),

    vtable::method("simPress", details::ID::_param_SimPress.data(),
                   details::ID::_return_SimPress.data(), _callback_SimPress),

    vtable::signal("Released", details::ID::_signal_Released.data()),

    vtable::signal("Pressed", details::ID::_signal_Pressed.data()),
    vtable::end()};

} // namespace server
} // namespace Buttons
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Chassis/Buttons/Power/server.hpp>
#include <xyz/openbmc_project/Chassis/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Buttons
{
namespace server
{

Power::Power(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Chassis_Buttons_Power_interface(bus, path, _interface,
                                                         _vtable, this),
    _intf(bus.getInterface())
{
}

Power::Power(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Power(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

int Power::_callback_SimPress(sd_bus_message* msg, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<Power*>(context);
        o->simPress();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Power
{
static const auto _param_SimPress =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_SimPress =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Power
} // namespace details

int Power::_callback_SimLongPress(sd_bus_message* msg, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<Power*>(context);
        o->simLongPress();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Power
{
static const auto _param_SimLongPress =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_SimLongPress =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Power
} // namespace details

void Power::released()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_Power_interface;
    auto m = i.new_signal("Released");

    m.append();
    m.signal_send();
}

namespace details
{
namespace Power
{
static const auto _signal_Released =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

void Power::pressed()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_Power_interface;
    auto m = i.new_signal("Pressed");

    m.append();
    m.signal_send();
}

namespace details
{
namespace Power
{
static const auto _signal_Pressed =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

void Power::pressedLong()
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Chassis_Buttons_Power_interface;
    auto m = i.new_signal("PressedLong");

    m.append();
    m.signal_send();
}

namespace details
{
namespace Power
{
static const auto _signal_PressedLong =
    utility::tuple_to_array(std::make_tuple('\0'));
}
} // namespace details

auto Power::enabled() const -> bool
{
    return _enabled;
}

int Power::_callback_get_Enabled(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Power*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->enabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Power::enabled(bool value, bool skipSignal) -> bool
{
    if (_enabled != value)
    {
        _enabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Chassis_Buttons_Power_interface
                .property_changed("Enabled");
        }
    }

    return _enabled;
}

auto Power::enabled(bool val) -> bool
{
    return enabled(val, false);
}
int Power::_callback_set_Enabled(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<Power*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->enabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Power
{
static const auto _property_Enabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Power::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Enabled")
    {
        auto& v = std::get<bool>(val);
        enabled(v, skipSignal);
        return;
    }
}

auto Power::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Enabled")
    {
        return enabled();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Power::_vtable[] = {
    vtable::start(),

    vtable::method("simPress", details::Power::_param_SimPress.data(),
                   details::Power::_return_SimPress.data(), _callback_SimPress),

    vtable::method("simLongPress", details::Power::_param_SimLongPress.data(),
                   details::Power::_return_SimLongPress.data(),
                   _callback_SimLongPress),

    vtable::signal("Released", details::Power::_signal_Released.data()),

    vtable::signal("Pressed", details::Power::_signal_Pressed.data()),

    vtable::signal("PressedLong", details::Power::_signal_PressedLong.data()),
    vtable::property("Enabled", details::Power::_property_Enabled.data(),
                     _callback_get_Enabled, _callback_set_Enabled,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Buttons
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Chassis/Common/error.hpp>
#include <xyz/openbmc_project/Chassis/Control/Power/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Control
{
namespace server
{

Power::Power(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Chassis_Control_Power_interface(bus, path, _interface,
                                                         _vtable, this),
    _intf(bus.getInterface())
{
}

Power::Power(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Power(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

int Power::_callback_ForcePowerOff(sd_bus_message* msg, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<Power*>(context);
        auto r = o->forcePowerOff();

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::
               UnsupportedCommand& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Power
{
static const auto _param_ForcePowerOff =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_ForcePowerOff =
    utility::tuple_to_array(message::types::type_id<bool>());
} // namespace Power
} // namespace details

auto Power::pGood() const -> bool
{
    return _pGood;
}

int Power::_callback_get_PGood(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Power*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->pGood()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Power::pGood(bool value, bool skipSignal) -> bool
{
    if (_pGood != value)
    {
        _pGood = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Chassis_Control_Power_interface
                .property_changed("PGood");
        }
    }

    return _pGood;
}

auto Power::pGood(bool val) -> bool
{
    return pGood(val, false);
}
int Power::_callback_set_PGood(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<Power*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->pGood(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Power
{
static const auto _property_PGood =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Power::state() const -> int32_t
{
    return _state;
}

int Power::_callback_get_State(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Power*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->state()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Power::state(int32_t value, bool skipSignal) -> int32_t
{
    if (_state != value)
    {
        _state = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Chassis_Control_Power_interface
                .property_changed("State");
        }
    }

    return _state;
}

auto Power::state(int32_t val) -> int32_t
{
    return state(val, false);
}
int Power::_callback_set_State(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<Power*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int32_t v{};
        m.read(v);
        o->state(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Power
{
static const auto _property_State =
    utility::tuple_to_array(message::types::type_id<int32_t>());
}
} // namespace details

void Power::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "PGood")
    {
        auto& v = std::get<bool>(val);
        pGood(v, skipSignal);
        return;
    }
    if (_name == "State")
    {
        auto& v = std::get<int32_t>(val);
        state(v, skipSignal);
        return;
    }
}

auto Power::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "PGood")
    {
        return pGood();
    }
    if (_name == "State")
    {
        return state();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Power::_vtable[] = {
    vtable::start(),

    vtable::method("forcePowerOff", details::Power::_param_ForcePowerOff.data(),
                   details::Power::_return_ForcePowerOff.data(),
                   _callback_ForcePowerOff),
    vtable::property("PGood", details::Power::_property_PGood.data(),
                     _callback_get_PGood, _callback_set_PGood,
                     vtable::property_::emits_change),
    vtable::property("State", details::Power::_property_State.data(),
                     _callback_get_State, _callback_set_State,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Object/Enable/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Object
{
namespace server
{

Enable::Enable(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Object_Enable_interface(bus, path, _interface, _vtable,
                                                 this),
    _intf(bus.getInterface())
{
}

Enable::Enable(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    Enable(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Enable::enabled() const -> bool
{
    return _enabled;
}

int Enable::_callback_get_Enabled(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Enable*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->enabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Enable::enabled(bool value, bool skipSignal) -> bool
{
    if (_enabled != value)
    {
        _enabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Object_Enable_interface.property_changed(
                "Enabled");
        }
    }

    return _enabled;
}

auto Enable::enabled(bool val) -> bool
{
    return enabled(val, false);
}
int Enable::_callback_set_Enabled(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Enable*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->enabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Enable
{
static const auto _property_Enabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Enable::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Enabled")
    {
        auto& v = std::get<bool>(val);
        enabled(v, skipSignal);
        return;
    }
}

auto Enable::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Enabled")
    {
        return enabled();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Enable::_vtable[] = {
    vtable::start(),
    vtable::property("Enabled", details::Enable::_property_Enabled.data(),
                     _callback_get_Enabled, _callback_set_Enabled,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Object
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Object/Delete/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Object
{
namespace server
{

Delete::Delete(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Object_Delete_interface(bus, path, _interface, _vtable,
                                                 this),
    _intf(bus.getInterface())
{
}

int Delete::_callback_Delete(sd_bus_message* msg, void* context,
                             sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<Delete*>(context);
        o->delete_();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Delete
{
static const auto _param_Delete =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_Delete =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Delete
} // namespace details

const vtable::vtable_t Delete::_vtable[] = {
    vtable::start(),

    vtable::method("Delete", details::Delete::_param_Delete.data(),
                   details::Delete::_return_Delete.data(), _callback_Delete),
    vtable::end()};

} // namespace server
} // namespace Object
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Certs/Install/server.hpp>
#include <xyz/openbmc_project/Certs/error.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Certs
{
namespace server
{

Install::Install(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Certs_Install_interface(bus, path, _interface, _vtable,
                                                 this),
    _intf(bus.getInterface())
{
}

int Install::_callback_Install(sd_bus_message* msg, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string path{};

        m.read(path);

        auto o = static_cast<Install*>(context);
        o->install(path);

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Certs::Error::InvalidCertificate& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Install
{
static const auto _param_Install =
    utility::tuple_to_array(message::types::type_id<std::string>());
static const auto _return_Install =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Install
} // namespace details

const vtable::vtable_t Install::_vtable[] = {
    vtable::start(),

    vtable::method("Install", details::Install::_param_Install.data(),
                   details::Install::_return_Install.data(), _callback_Install),
    vtable::end()};

} // namespace server
} // namespace Certs
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Certs/Replace/server.hpp>
#include <xyz/openbmc_project/Certs/error.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Certs
{
namespace server
{

Replace::Replace(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Certs_Replace_interface(bus, path, _interface, _vtable,
                                                 this),
    _intf(bus.getInterface())
{
}

int Replace::_callback_Replace(sd_bus_message* msg, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string path{};

        m.read(path);

        auto o = static_cast<Replace*>(context);
        o->replace(path);

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Certs::Error::InvalidCertificate& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Replace
{
static const auto _param_Replace =
    utility::tuple_to_array(message::types::type_id<std::string>());
static const auto _return_Replace =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Replace
} // namespace details

const vtable::vtable_t Replace::_vtable[] = {
    vtable::start(),

    vtable::method("Replace", details::Replace::_param_Replace.data(),
                   details::Replace::_return_Replace.data(), _callback_Replace),
    vtable::end()};

} // namespace server
} // namespace Certs
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Certs/Certificate/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Certs
{
namespace server
{

Certificate::Certificate(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Certs_Certificate_interface(bus, path, _interface,
                                                     _vtable, this),
    _intf(bus.getInterface())
{
}

Certificate::Certificate(bus::bus& bus, const char* path,
                         const std::map<std::string, PropertiesVariant>& vals,
                         bool skipSignal) :
    Certificate(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Certificate::certificateString() const -> std::string
{
    return _certificateString;
}

int Certificate::_callback_get_CertificateString(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->certificateString()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Certificate::certificateString(std::string value, bool skipSignal)
    -> std::string
{
    if (_certificateString != value)
    {
        _certificateString = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Certs_Certificate_interface.property_changed(
                "CertificateString");
        }
    }

    return _certificateString;
}

auto Certificate::certificateString(std::string val) -> std::string
{
    return certificateString(val, false);
}
int Certificate::_callback_set_CertificateString(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->certificateString(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Certificate
{
static const auto _property_CertificateString =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Certificate::keyUsage() const -> std::vector<std::string>
{
    return _keyUsage;
}

int Certificate::_callback_get_KeyUsage(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->keyUsage()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Certificate::keyUsage(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_keyUsage != value)
    {
        _keyUsage = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Certs_Certificate_interface.property_changed(
                "KeyUsage");
        }
    }

    return _keyUsage;
}

auto Certificate::keyUsage(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return keyUsage(val, false);
}
int Certificate::_callback_set_KeyUsage(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->keyUsage(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Certificate
{
static const auto _property_KeyUsage = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto Certificate::issuer() const -> std::string
{
    return _issuer;
}

int Certificate::_callback_get_Issuer(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->issuer()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Certificate::issuer(std::string value, bool skipSignal) -> std::string
{
    if (_issuer != value)
    {
        _issuer = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Certs_Certificate_interface.property_changed(
                "Issuer");
        }
    }

    return _issuer;
}

auto Certificate::issuer(std::string val) -> std::string
{
    return issuer(val, false);
}
int Certificate::_callback_set_Issuer(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->issuer(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Certificate
{
static const auto _property_Issuer =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Certificate::subject() const -> std::string
{
    return _subject;
}

int Certificate::_callback_get_Subject(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* reply, void* context,
                                       sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->subject()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Certificate::subject(std::string value, bool skipSignal) -> std::string
{
    if (_subject != value)
    {
        _subject = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Certs_Certificate_interface.property_changed(
                "Subject");
        }
    }

    return _subject;
}

auto Certificate::subject(std::string val) -> std::string
{
    return subject(val, false);
}
int Certificate::_callback_set_Subject(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* value, void* context,
                                       sd_bus_error* error)
{
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->subject(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Certificate
{
static const auto _property_Subject =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Certificate::validNotAfter() const -> uint64_t
{
    return _validNotAfter;
}

int Certificate::_callback_get_ValidNotAfter(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->validNotAfter()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Certificate::validNotAfter(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_validNotAfter != value)
    {
        _validNotAfter = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Certs_Certificate_interface.property_changed(
                "ValidNotAfter");
        }
    }

    return _validNotAfter;
}

auto Certificate::validNotAfter(uint64_t val) -> uint64_t
{
    return validNotAfter(val, false);
}
int Certificate::_callback_set_ValidNotAfter(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->validNotAfter(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Certificate
{
static const auto _property_ValidNotAfter =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

auto Certificate::validNotBefore() const -> uint64_t
{
    return _validNotBefore;
}

int Certificate::_callback_get_ValidNotBefore(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->validNotBefore()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Certificate::validNotBefore(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_validNotBefore != value)
    {
        _validNotBefore = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Certs_Certificate_interface.property_changed(
                "ValidNotBefore");
        }
    }

    return _validNotBefore;
}

auto Certificate::validNotBefore(uint64_t val) -> uint64_t
{
    return validNotBefore(val, false);
}
int Certificate::_callback_set_ValidNotBefore(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Certificate*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->validNotBefore(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Certificate
{
static const auto _property_ValidNotBefore =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

void Certificate::setPropertyByName(const std::string& _name,
                                    const PropertiesVariant& val,
                                    bool skipSignal)
{
    if (_name == "CertificateString")
    {
        auto& v = std::get<std::string>(val);
        certificateString(v, skipSignal);
        return;
    }
    if (_name == "KeyUsage")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        keyUsage(v, skipSignal);
        return;
    }
    if (_name == "Issuer")
    {
        auto& v = std::get<std::string>(val);
        issuer(v, skipSignal);
        return;
    }
    if (_name == "Subject")
    {
        auto& v = std::get<std::string>(val);
        subject(v, skipSignal);
        return;
    }
    if (_name == "ValidNotAfter")
    {
        auto& v = std::get<uint64_t>(val);
        validNotAfter(v, skipSignal);
        return;
    }
    if (_name == "ValidNotBefore")
    {
        auto& v = std::get<uint64_t>(val);
        validNotBefore(v, skipSignal);
        return;
    }
}

auto Certificate::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "CertificateString")
    {
        return certificateString();
    }
    if (_name == "KeyUsage")
    {
        return keyUsage();
    }
    if (_name == "Issuer")
    {
        return issuer();
    }
    if (_name == "Subject")
    {
        return subject();
    }
    if (_name == "ValidNotAfter")
    {
        return validNotAfter();
    }
    if (_name == "ValidNotBefore")
    {
        return validNotBefore();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Certificate::_vtable[] = {
    vtable::start(),
    vtable::property("CertificateString",
                     details::Certificate::_property_CertificateString.data(),
                     _callback_get_CertificateString,
                     _callback_set_CertificateString,
                     vtable::property_::emits_change),
    vtable::property("KeyUsage",
                     details::Certificate::_property_KeyUsage.data(),
                     _callback_get_KeyUsage, _callback_set_KeyUsage,
                     vtable::property_::emits_change),
    vtable::property("Issuer", details::Certificate::_property_Issuer.data(),
                     _callback_get_Issuer, _callback_set_Issuer,
                     vtable::property_::emits_change),
    vtable::property("Subject", details::Certificate::_property_Subject.data(),
                     _callback_get_Subject, _callback_set_Subject,
                     vtable::property_::emits_change),
    vtable::property("ValidNotAfter",
                     details::Certificate::_property_ValidNotAfter.data(),
                     _callback_get_ValidNotAfter, _callback_set_ValidNotAfter,
                     vtable::property_::emits_change),
    vtable::property("ValidNotBefore",
                     details::Certificate::_property_ValidNotBefore.data(),
                     _callback_get_ValidNotBefore, _callback_set_ValidNotBefore,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Certs
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Certs/CSR/server.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Certs
{
namespace server
{

CSR::CSR(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Certs_CSR_interface(bus, path, _interface, _vtable,
                                             this),
    _intf(bus.getInterface())
{
}

int CSR::_callback_CSR(sd_bus_message* msg, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<CSR*>(context);
        auto r = o->cSR();

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace CSR
{
static const auto _param_CSR = utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_CSR =
    utility::tuple_to_array(message::types::type_id<std::string>());
} // namespace CSR
} // namespace details

const vtable::vtable_t CSR::_vtable[] = {
    vtable::start(),

    vtable::method("CSR", details::CSR::_param_CSR.data(),
                   details::CSR::_return_CSR.data(), _callback_CSR),
    vtable::end()};

} // namespace server
} // namespace Certs
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Certs/CSR/Create/server.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Certs
{
namespace CSR
{
namespace server
{

Create::Create(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Certs_CSR_Create_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

int Create::_callback_GenerateCSR(sd_bus_message* msg, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> alternativeNames{};
        std::string challengePassword{};
        std::string city{};
        std::string commonName{};
        std::string contactPerson{};
        std::string country{};
        std::string email{};
        std::string givenName{};
        std::string initials{};
        int64_t keyBitLength{};
        std::string keyCurveId{};
        std::string keyPairAlgorithm{};
        std::vector<std::string> keyUsage{};
        std::string organization{};
        std::string organizationalUnit{};
        std::string state{};
        std::string surname{};
        std::string unstructuredName{};

        m.read(alternativeNames, challengePassword, city, commonName,
               contactPerson, country, email, givenName, initials, keyBitLength,
               keyCurveId, keyPairAlgorithm, keyUsage, organization,
               organizationalUnit, state, surname, unstructuredName);

        auto o = static_cast<Create*>(context);
        auto r = o->generateCSR(
            alternativeNames, challengePassword, city, commonName,
            contactPerson, country, email, givenName, initials, keyBitLength,
            keyCurveId, keyPairAlgorithm, keyUsage, organization,
            organizationalUnit, state, surname, unstructuredName);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Create
{
static const auto _param_GenerateCSR = utility::tuple_to_array(
    message::types::type_id<
        std::vector<std::string>, std::string, std::string, std::string,
        std::string, std::string, std::string, std::string, std::string,
        int64_t, std::string, std::string, std::vector<std::string>,
        std::string, std::string, std::string, std::string, std::string>());
static const auto _return_GenerateCSR =
    utility::tuple_to_array(message::types::type_id<std::string>());
} // namespace Create
} // namespace details

const vtable::vtable_t Create::_vtable[] = {
    vtable::start(),

    vtable::method("GenerateCSR", details::Create::_param_GenerateCSR.data(),
                   details::Create::_return_GenerateCSR.data(),
                   _callback_GenerateCSR),
    vtable::end()};

} // namespace server
} // namespace CSR
} // namespace Certs
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Service/Attributes/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Service
{
namespace server
{

Attributes::Attributes(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Service_Attributes_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Attributes::Attributes(bus::bus& bus, const char* path,
                       const std::map<std::string, PropertiesVariant>& vals,
                       bool skipSignal) :
    Attributes(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Attributes::state() const -> SupportedStates
{
    return _state;
}

int Attributes::_callback_get_State(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* reply, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->state()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Attributes::state(SupportedStates value, bool skipSignal)
    -> SupportedStates
{
    if (_state != value)
    {
        _state = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Service_Attributes_interface
                .property_changed("State");
        }
    }

    return _state;
}

auto Attributes::state(SupportedStates val) -> SupportedStates
{
    return state(val, false);
}
int Attributes::_callback_set_State(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* value, void* context,
                                    sd_bus_error* error)
{
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->state(convertSupportedStatesFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Attributes
{
static const auto _property_State =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Attributes::port() const -> uint32_t
{
    return _port;
}

int Attributes::_callback_get_Port(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->port()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Attributes::port(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_port != value)
    {
        _port = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Service_Attributes_interface
                .property_changed("Port");
        }
    }

    return _port;
}

auto Attributes::port(uint32_t val) -> uint32_t
{
    return port(val, false);
}
int Attributes::_callback_set_Port(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->port(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Attributes
{
static const auto _property_Port =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto Attributes::channel() const -> std::vector<std::string>
{
    return _channel;
}

int Attributes::_callback_get_Channel(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->channel()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Attributes::channel(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_channel != value)
    {
        _channel = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Service_Attributes_interface
                .property_changed("Channel");
        }
    }

    return _channel;
}

auto Attributes::channel(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return channel(val, false);
}
int Attributes::_callback_set_Channel(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->channel(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Attributes
{
static const auto _property_Channel = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

void Attributes::setPropertyByName(const std::string& _name,
                                   const PropertiesVariant& val,
                                   bool skipSignal)
{
    if (_name == "State")
    {
        auto& v = std::get<SupportedStates>(val);
        state(v, skipSignal);
        return;
    }
    if (_name == "Port")
    {
        auto& v = std::get<uint32_t>(val);
        port(v, skipSignal);
        return;
    }
    if (_name == "Channel")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        channel(v, skipSignal);
        return;
    }
}

auto Attributes::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "State")
    {
        return state();
    }
    if (_name == "Port")
    {
        return port();
    }
    if (_name == "Channel")
    {
        return channel();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Attributes::SupportedStates */
static const std::tuple<const char*, Attributes::SupportedStates>
    mappingAttributesSupportedStates[] = {
        std::make_tuple("xyz.openbmc_project.Control.Service.Attributes."
                        "SupportedStates.enabled",
                        Attributes::SupportedStates::enabled),
        std::make_tuple("xyz.openbmc_project.Control.Service.Attributes."
                        "SupportedStates.disabled",
                        Attributes::SupportedStates::disabled),
};

} // anonymous namespace

auto Attributes::convertSupportedStatesFromString(const std::string& s)
    -> SupportedStates
{
    auto i =
        std::find_if(std::begin(mappingAttributesSupportedStates),
                     std::end(mappingAttributesSupportedStates), [&s](auto& e) {
                         return 0 == strcmp(s.c_str(), std::get<0>(e));
                     });
    if (std::end(mappingAttributesSupportedStates) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Attributes::SupportedStates v)
{
    auto i = std::find_if(std::begin(mappingAttributesSupportedStates),
                          std::end(mappingAttributesSupportedStates),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingAttributesSupportedStates))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Attributes::_vtable[] = {
    vtable::start(),
    vtable::property("State", details::Attributes::_property_State.data(),
                     _callback_get_State, _callback_set_State,
                     vtable::property_::emits_change),
    vtable::property("Port", details::Attributes::_property_Port.data(),
                     _callback_get_Port, _callback_set_Port,
                     vtable::property_::emits_change),
    vtable::property("Channel", details::Attributes::_property_Channel.data(),
                     _callback_get_Channel, _callback_set_Channel,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Service
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/CFMLimit/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

CFMLimit::CFMLimit(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_CFMLimit_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

CFMLimit::CFMLimit(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    CFMLimit(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto CFMLimit::limit() const -> double
{
    return _limit;
}

int CFMLimit::_callback_get_Limit(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<CFMLimit*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->limit()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto CFMLimit::limit(double value, bool skipSignal) -> double
{
    if (_limit != value)
    {
        _limit = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_CFMLimit_interface.property_changed(
                "Limit");
        }
    }

    return _limit;
}

auto CFMLimit::limit(double val) -> double
{
    return limit(val, false);
}
int CFMLimit::_callback_set_Limit(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<CFMLimit*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        double v{};
        m.read(v);
        o->limit(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace CFMLimit
{
static const auto _property_Limit =
    utility::tuple_to_array(message::types::type_id<double>());
}
} // namespace details

void CFMLimit::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Limit")
    {
        auto& v = std::get<double>(val);
        limit(v, skipSignal);
        return;
    }
}

auto CFMLimit::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Limit")
    {
        return limit();
    }

    return PropertiesVariant();
}

const vtable::vtable_t CFMLimit::_vtable[] = {
    vtable::start(),
    vtable::property("Limit", details::CFMLimit::_property_Limit.data(),
                     _callback_get_Limit, _callback_set_Limit,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/PowerSupplyAttributes/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

PowerSupplyAttributes::PowerSupplyAttributes(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_PowerSupplyAttributes_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

PowerSupplyAttributes::PowerSupplyAttributes(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    PowerSupplyAttributes(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto PowerSupplyAttributes::deratingFactor() const -> uint32_t
{
    return _deratingFactor;
}

int PowerSupplyAttributes::_callback_get_DeratingFactor(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerSupplyAttributes*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->deratingFactor()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerSupplyAttributes::deratingFactor(uint32_t value, bool skipSignal)
    -> uint32_t
{
    if (_deratingFactor != value)
    {
        _deratingFactor = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_PowerSupplyAttributes_interface
                .property_changed("DeratingFactor");
        }
    }

    return _deratingFactor;
}

auto PowerSupplyAttributes::deratingFactor(uint32_t val) -> uint32_t
{
    return deratingFactor(val, false);
}
int PowerSupplyAttributes::_callback_set_DeratingFactor(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PowerSupplyAttributes*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->deratingFactor(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerSupplyAttributes
{
static const auto _property_DeratingFactor =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

void PowerSupplyAttributes::setPropertyByName(const std::string& _name,
                                              const PropertiesVariant& val,
                                              bool skipSignal)
{
    if (_name == "DeratingFactor")
    {
        auto& v = std::get<uint32_t>(val);
        deratingFactor(v, skipSignal);
        return;
    }
}

auto PowerSupplyAttributes::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "DeratingFactor")
    {
        return deratingFactor();
    }

    return PropertiesVariant();
}

const vtable::vtable_t PowerSupplyAttributes::_vtable[] = {
    vtable::start(),
    vtable::property(
        "DeratingFactor",
        details::PowerSupplyAttributes::_property_DeratingFactor.data(),
        _callback_get_DeratingFactor, vtable::property_::const_),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/ThermalMode/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

ThermalMode::ThermalMode(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_ThermalMode_interface(bus, path, _interface,
                                                       _vtable, this),
    _intf(bus.getInterface())
{
}

ThermalMode::ThermalMode(bus::bus& bus, const char* path,
                         const std::map<std::string, PropertiesVariant>& vals,
                         bool skipSignal) :
    ThermalMode(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto ThermalMode::supported() const -> std::vector<std::string>
{
    return _supported;
}

int ThermalMode::_callback_get_Supported(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ThermalMode*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->supported()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ThermalMode::supported(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_supported != value)
    {
        _supported = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_ThermalMode_interface.property_changed(
                "Supported");
        }
    }

    return _supported;
}

auto ThermalMode::supported(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return supported(val, false);
}
int ThermalMode::_callback_set_Supported(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<ThermalMode*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->supported(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ThermalMode
{
static const auto _property_Supported = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto ThermalMode::current() const -> std::string
{
    return _current;
}

int ThermalMode::_callback_get_Current(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* reply, void* context,
                                       sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ThermalMode*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->current()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ThermalMode::current(std::string value, bool skipSignal) -> std::string
{
    if (_current != value)
    {
        _current = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_ThermalMode_interface.property_changed(
                "Current");
        }
    }

    return _current;
}

auto ThermalMode::current(std::string val) -> std::string
{
    return current(val, false);
}
int ThermalMode::_callback_set_Current(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* value, void* context,
                                       sd_bus_error* error)
{
    auto o = static_cast<ThermalMode*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->current(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ThermalMode
{
static const auto _property_Current =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void ThermalMode::setPropertyByName(const std::string& _name,
                                    const PropertiesVariant& val,
                                    bool skipSignal)
{
    if (_name == "Supported")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        supported(v, skipSignal);
        return;
    }
    if (_name == "Current")
    {
        auto& v = std::get<std::string>(val);
        current(v, skipSignal);
        return;
    }
}

auto ThermalMode::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "Supported")
    {
        return supported();
    }
    if (_name == "Current")
    {
        return current();
    }

    return PropertiesVariant();
}

const vtable::vtable_t ThermalMode::_vtable[] = {
    vtable::start(),
    vtable::property("Supported",
                     details::ThermalMode::_property_Supported.data(),
                     _callback_get_Supported, vtable::property_::const_),
    vtable::property("Current", details::ThermalMode::_property_Current.data(),
                     _callback_get_Current, _callback_set_Current,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Control/FieldMode/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

FieldMode::FieldMode(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_FieldMode_interface(bus, path, _interface,
                                                     _vtable, this),
    _intf(bus.getInterface())
{
}

FieldMode::FieldMode(bus::bus& bus, const char* path,
                     const std::map<std::string, PropertiesVariant>& vals,
                     bool skipSignal) :
    FieldMode(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto FieldMode::fieldModeEnabled() const -> bool
{
    return _fieldModeEnabled;
}

int FieldMode::_callback_get_FieldModeEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<FieldMode*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->fieldModeEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto FieldMode::fieldModeEnabled(bool value, bool skipSignal) -> bool
{
    if (_fieldModeEnabled != value)
    {
        _fieldModeEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_FieldMode_interface.property_changed(
                "FieldModeEnabled");
        }
    }

    return _fieldModeEnabled;
}

auto FieldMode::fieldModeEnabled(bool val) -> bool
{
    return fieldModeEnabled(val, false);
}
int FieldMode::_callback_set_FieldModeEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<FieldMode*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->fieldModeEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace FieldMode
{
static const auto _property_FieldModeEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void FieldMode::setPropertyByName(const std::string& _name,
                                  const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "FieldModeEnabled")
    {
        auto& v = std::get<bool>(val);
        fieldModeEnabled(v, skipSignal);
        return;
    }
}

auto FieldMode::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "FieldModeEnabled")
    {
        return fieldModeEnabled();
    }

    return PropertiesVariant();
}

const vtable::vtable_t FieldMode::_vtable[] = {
    vtable::start(),
    vtable::property("FieldModeEnabled",
                     details::FieldMode::_property_FieldModeEnabled.data(),
                     _callback_get_FieldModeEnabled,
                     _callback_set_FieldModeEnabled,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Control/Host/NMI/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Host
{
namespace server
{

NMI::NMI(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Host_NMI_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

int NMI::_callback_NMI(sd_bus_message* msg, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<NMI*>(context);
        o->nMI();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace NMI
{
static const auto _param_NMI = utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_NMI = utility::tuple_to_array(std::make_tuple('\0'));
} // namespace NMI
} // namespace details

const vtable::vtable_t NMI::_vtable[] = {
    vtable::start(),

    vtable::method("NMI", details::NMI::_param_NMI.data(),
                   details::NMI::_return_NMI.data(), _callback_NMI),
    vtable::end()};

} // namespace server
} // namespace Host
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Host/TurboAllowed/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Host
{
namespace server
{

TurboAllowed::TurboAllowed(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Host_TurboAllowed_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

TurboAllowed::TurboAllowed(bus::bus& bus, const char* path,
                           const std::map<std::string, PropertiesVariant>& vals,
                           bool skipSignal) :
    TurboAllowed(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto TurboAllowed::turboAllowed() const -> bool
{
    return _turboAllowed;
}

int TurboAllowed::_callback_get_TurboAllowed(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<TurboAllowed*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->turboAllowed()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto TurboAllowed::turboAllowed(bool value, bool skipSignal) -> bool
{
    if (_turboAllowed != value)
    {
        _turboAllowed = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Host_TurboAllowed_interface
                .property_changed("TurboAllowed");
        }
    }

    return _turboAllowed;
}

auto TurboAllowed::turboAllowed(bool val) -> bool
{
    return turboAllowed(val, false);
}
int TurboAllowed::_callback_set_TurboAllowed(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<TurboAllowed*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->turboAllowed(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace TurboAllowed
{
static const auto _property_TurboAllowed =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void TurboAllowed::setPropertyByName(const std::string& _name,
                                     const PropertiesVariant& val,
                                     bool skipSignal)
{
    if (_name == "TurboAllowed")
    {
        auto& v = std::get<bool>(val);
        turboAllowed(v, skipSignal);
        return;
    }
}

auto TurboAllowed::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "TurboAllowed")
    {
        return turboAllowed();
    }

    return PropertiesVariant();
}

const vtable::vtable_t TurboAllowed::_vtable[] = {
    vtable::start(),
    vtable::property("TurboAllowed",
                     details::TurboAllowed::_property_TurboAllowed.data(),
                     _callback_get_TurboAllowed, _callback_set_TurboAllowed,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Host
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/FanSpeed/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

FanSpeed::FanSpeed(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_FanSpeed_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

FanSpeed::FanSpeed(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    FanSpeed(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto FanSpeed::target() const -> uint64_t
{
    return _target;
}

int FanSpeed::_callback_get_Target(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<FanSpeed*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->target()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto FanSpeed::target(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_target != value)
    {
        _target = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_FanSpeed_interface.property_changed(
                "Target");
        }
    }

    return _target;
}

auto FanSpeed::target(uint64_t val) -> uint64_t
{
    return target(val, false);
}
int FanSpeed::_callback_set_Target(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<FanSpeed*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->target(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace FanSpeed
{
static const auto _property_Target =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

void FanSpeed::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Target")
    {
        auto& v = std::get<uint64_t>(val);
        target(v, skipSignal);
        return;
    }
}

auto FanSpeed::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Target")
    {
        return target();
    }

    return PropertiesVariant();
}

const vtable::vtable_t FanSpeed::_vtable[] = {
    vtable::start(),
    vtable::property("Target", details::FanSpeed::_property_Target.data(),
                     _callback_get_Target, _callback_set_Target,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Security/RestrictionMode/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Security
{
namespace server
{

RestrictionMode::RestrictionMode(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Security_RestrictionMode_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

RestrictionMode::RestrictionMode(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    RestrictionMode(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto RestrictionMode::restrictionMode() const -> Modes
{
    return _restrictionMode;
}

int RestrictionMode::_callback_get_RestrictionMode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<RestrictionMode*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->restrictionMode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto RestrictionMode::restrictionMode(Modes value, bool skipSignal) -> Modes
{
    if (_restrictionMode != value)
    {
        _restrictionMode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Security_RestrictionMode_interface
                .property_changed("RestrictionMode");
        }
    }

    return _restrictionMode;
}

auto RestrictionMode::restrictionMode(Modes val) -> Modes
{
    return restrictionMode(val, false);
}
int RestrictionMode::_callback_set_RestrictionMode(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<RestrictionMode*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->restrictionMode(convertModesFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace RestrictionMode
{
static const auto _property_RestrictionMode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void RestrictionMode::setPropertyByName(const std::string& _name,
                                        const PropertiesVariant& val,
                                        bool skipSignal)
{
    if (_name == "RestrictionMode")
    {
        auto& v = std::get<Modes>(val);
        restrictionMode(v, skipSignal);
        return;
    }
}

auto RestrictionMode::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "RestrictionMode")
    {
        return restrictionMode();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for RestrictionMode::Modes */
static const std::tuple<const char*, RestrictionMode::Modes>
    mappingRestrictionModeModes[] = {
        std::make_tuple(
            "xyz.openbmc_project.Control.Security.RestrictionMode.Modes.None",
            RestrictionMode::Modes::None),
        std::make_tuple("xyz.openbmc_project.Control.Security.RestrictionMode."
                        "Modes.Whitelist",
                        RestrictionMode::Modes::Whitelist),
        std::make_tuple("xyz.openbmc_project.Control.Security.RestrictionMode."
                        "Modes.Blacklist",
                        RestrictionMode::Modes::Blacklist),
};

} // anonymous namespace

auto RestrictionMode::convertModesFromString(const std::string& s) -> Modes
{
    auto i = std::find_if(std::begin(mappingRestrictionModeModes),
                          std::end(mappingRestrictionModeModes), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingRestrictionModeModes) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(RestrictionMode::Modes v)
{
    auto i = std::find_if(std::begin(mappingRestrictionModeModes),
                          std::end(mappingRestrictionModeModes),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingRestrictionModeModes))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t RestrictionMode::_vtable[] = {
    vtable::start(),
    vtable::property("RestrictionMode",
                     details::RestrictionMode::_property_RestrictionMode.data(),
                     _callback_get_RestrictionMode,
                     _callback_set_RestrictionMode,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Security
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/MinimumShipLevel/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

MinimumShipLevel::MinimumShipLevel(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_MinimumShipLevel_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

MinimumShipLevel::MinimumShipLevel(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    MinimumShipLevel(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto MinimumShipLevel::minimumShipLevelRequired() const -> bool
{
    return _minimumShipLevelRequired;
}

int MinimumShipLevel::_callback_get_MinimumShipLevelRequired(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<MinimumShipLevel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->minimumShipLevelRequired()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto MinimumShipLevel::minimumShipLevelRequired(bool value, bool skipSignal)
    -> bool
{
    if (_minimumShipLevelRequired != value)
    {
        _minimumShipLevelRequired = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_MinimumShipLevel_interface
                .property_changed("MinimumShipLevelRequired");
        }
    }

    return _minimumShipLevelRequired;
}

auto MinimumShipLevel::minimumShipLevelRequired(bool val) -> bool
{
    return minimumShipLevelRequired(val, false);
}
int MinimumShipLevel::_callback_set_MinimumShipLevelRequired(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<MinimumShipLevel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->minimumShipLevelRequired(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace MinimumShipLevel
{
static const auto _property_MinimumShipLevelRequired =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void MinimumShipLevel::setPropertyByName(const std::string& _name,
                                         const PropertiesVariant& val,
                                         bool skipSignal)
{
    if (_name == "MinimumShipLevelRequired")
    {
        auto& v = std::get<bool>(val);
        minimumShipLevelRequired(v, skipSignal);
        return;
    }
}

auto MinimumShipLevel::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "MinimumShipLevelRequired")
    {
        return minimumShipLevelRequired();
    }

    return PropertiesVariant();
}

const vtable::vtable_t MinimumShipLevel::_vtable[] = {
    vtable::start(),
    vtable::property(
        "MinimumShipLevelRequired",
        details::MinimumShipLevel::_property_MinimumShipLevelRequired.data(),
        _callback_get_MinimumShipLevelRequired,
        _callback_set_MinimumShipLevelRequired,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Power/ACPIPowerState/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Power
{
namespace server
{

ACPIPowerState::ACPIPowerState(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Power_ACPIPowerState_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

ACPIPowerState::ACPIPowerState(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    ACPIPowerState(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto ACPIPowerState::sysACPIStatus() const -> ACPI
{
    return _sysACPIStatus;
}

int ACPIPowerState::_callback_get_SysACPIStatus(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ACPIPowerState*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->sysACPIStatus()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ACPIPowerState::sysACPIStatus(ACPI value, bool skipSignal) -> ACPI
{
    if (_sysACPIStatus != value)
    {
        _sysACPIStatus = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Power_ACPIPowerState_interface
                .property_changed("SysACPIStatus");
        }
    }

    return _sysACPIStatus;
}

auto ACPIPowerState::sysACPIStatus(ACPI val) -> ACPI
{
    return sysACPIStatus(val, false);
}
int ACPIPowerState::_callback_set_SysACPIStatus(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ACPIPowerState*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->sysACPIStatus(convertACPIFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ACPIPowerState
{
static const auto _property_SysACPIStatus =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto ACPIPowerState::devACPIStatus() const -> ACPI
{
    return _devACPIStatus;
}

int ACPIPowerState::_callback_get_DevACPIStatus(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ACPIPowerState*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->devACPIStatus()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ACPIPowerState::devACPIStatus(ACPI value, bool skipSignal) -> ACPI
{
    if (_devACPIStatus != value)
    {
        _devACPIStatus = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Power_ACPIPowerState_interface
                .property_changed("DevACPIStatus");
        }
    }

    return _devACPIStatus;
}

auto ACPIPowerState::devACPIStatus(ACPI val) -> ACPI
{
    return devACPIStatus(val, false);
}
int ACPIPowerState::_callback_set_DevACPIStatus(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ACPIPowerState*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->devACPIStatus(convertACPIFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ACPIPowerState
{
static const auto _property_DevACPIStatus =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void ACPIPowerState::setPropertyByName(const std::string& _name,
                                       const PropertiesVariant& val,
                                       bool skipSignal)
{
    if (_name == "SysACPIStatus")
    {
        auto& v = std::get<ACPI>(val);
        sysACPIStatus(v, skipSignal);
        return;
    }
    if (_name == "DevACPIStatus")
    {
        auto& v = std::get<ACPI>(val);
        devACPIStatus(v, skipSignal);
        return;
    }
}

auto ACPIPowerState::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "SysACPIStatus")
    {
        return sysACPIStatus();
    }
    if (_name == "DevACPIStatus")
    {
        return devACPIStatus();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for ACPIPowerState::ACPI */
static const std::tuple<const char*, ACPIPowerState::ACPI>
    mappingACPIPowerStateACPI[] = {
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.S0_G0_D0",
            ACPIPowerState::ACPI::S0_G0_D0),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.S1_D1",
            ACPIPowerState::ACPI::S1_D1),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.S2_D2",
            ACPIPowerState::ACPI::S2_D2),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.S3_D3",
            ACPIPowerState::ACPI::S3_D3),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.S4",
            ACPIPowerState::ACPI::S4),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.S5_G2",
            ACPIPowerState::ACPI::S5_G2),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.S4_S5",
            ACPIPowerState::ACPI::S4_S5),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.G3",
            ACPIPowerState::ACPI::G3),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.SLEEP",
            ACPIPowerState::ACPI::SLEEP),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.G1_SLEEP",
            ACPIPowerState::ACPI::G1_SLEEP),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.OVERRIDE",
            ACPIPowerState::ACPI::OVERRIDE),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.LEGACY_ON",
            ACPIPowerState::ACPI::LEGACY_ON),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.LEGACY_OFF",
            ACPIPowerState::ACPI::LEGACY_OFF),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.ACPIPowerState.ACPI.Unknown",
            ACPIPowerState::ACPI::Unknown),
};

} // anonymous namespace

auto ACPIPowerState::convertACPIFromString(const std::string& s) -> ACPI
{
    auto i = std::find_if(std::begin(mappingACPIPowerStateACPI),
                          std::end(mappingACPIPowerStateACPI), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingACPIPowerStateACPI) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(ACPIPowerState::ACPI v)
{
    auto i = std::find_if(std::begin(mappingACPIPowerStateACPI),
                          std::end(mappingACPIPowerStateACPI),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingACPIPowerStateACPI))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t ACPIPowerState::_vtable[] = {
    vtable::start(),
    vtable::property("SysACPIStatus",
                     details::ACPIPowerState::_property_SysACPIStatus.data(),
                     _callback_get_SysACPIStatus, _callback_set_SysACPIStatus,
                     vtable::property_::emits_change),
    vtable::property("DevACPIStatus",
                     details::ACPIPowerState::_property_DevACPIStatus.data(),
                     _callback_get_DevACPIStatus, _callback_set_DevACPIStatus,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Power
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Power/Cap/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Power
{
namespace server
{

Cap::Cap(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Power_Cap_interface(bus, path, _interface,
                                                     _vtable, this),
    _intf(bus.getInterface())
{
}

Cap::Cap(bus::bus& bus, const char* path,
         const std::map<std::string, PropertiesVariant>& vals,
         bool skipSignal) :
    Cap(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Cap::powerCap() const -> uint32_t
{
    return _powerCap;
}

int Cap::_callback_get_PowerCap(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* reply, void* context,
                                sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Cap*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->powerCap()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Cap::powerCap(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_powerCap != value)
    {
        _powerCap = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Power_Cap_interface.property_changed(
                "PowerCap");
        }
    }

    return _powerCap;
}

auto Cap::powerCap(uint32_t val) -> uint32_t
{
    return powerCap(val, false);
}
int Cap::_callback_set_PowerCap(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* value, void* context,
                                sd_bus_error* error)
{
    auto o = static_cast<Cap*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->powerCap(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Cap
{
static const auto _property_PowerCap =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto Cap::powerCapEnable() const -> bool
{
    return _powerCapEnable;
}

int Cap::_callback_get_PowerCapEnable(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Cap*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->powerCapEnable()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Cap::powerCapEnable(bool value, bool skipSignal) -> bool
{
    if (_powerCapEnable != value)
    {
        _powerCapEnable = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Power_Cap_interface.property_changed(
                "PowerCapEnable");
        }
    }

    return _powerCapEnable;
}

auto Cap::powerCapEnable(bool val) -> bool
{
    return powerCapEnable(val, false);
}
int Cap::_callback_set_PowerCapEnable(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Cap*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->powerCapEnable(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Cap
{
static const auto _property_PowerCapEnable =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Cap::setPropertyByName(const std::string& _name,
                            const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "PowerCap")
    {
        auto& v = std::get<uint32_t>(val);
        powerCap(v, skipSignal);
        return;
    }
    if (_name == "PowerCapEnable")
    {
        auto& v = std::get<bool>(val);
        powerCapEnable(v, skipSignal);
        return;
    }
}

auto Cap::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "PowerCap")
    {
        return powerCap();
    }
    if (_name == "PowerCapEnable")
    {
        return powerCapEnable();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Cap::_vtable[] = {
    vtable::start(),
    vtable::property("PowerCap", details::Cap::_property_PowerCap.data(),
                     _callback_get_PowerCap, _callback_set_PowerCap,
                     vtable::property_::emits_change),
    vtable::property("PowerCapEnable",
                     details::Cap::_property_PowerCapEnable.data(),
                     _callback_get_PowerCapEnable, _callback_set_PowerCapEnable,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Power
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Power/RestorePolicy/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Power
{
namespace server
{

RestorePolicy::RestorePolicy(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Power_RestorePolicy_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

RestorePolicy::RestorePolicy(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    RestorePolicy(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto RestorePolicy::powerRestorePolicy() const -> Policy
{
    return _powerRestorePolicy;
}

int RestorePolicy::_callback_get_PowerRestorePolicy(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<RestorePolicy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->powerRestorePolicy()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto RestorePolicy::powerRestorePolicy(Policy value, bool skipSignal) -> Policy
{
    if (_powerRestorePolicy != value)
    {
        _powerRestorePolicy = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Power_RestorePolicy_interface
                .property_changed("PowerRestorePolicy");
        }
    }

    return _powerRestorePolicy;
}

auto RestorePolicy::powerRestorePolicy(Policy val) -> Policy
{
    return powerRestorePolicy(val, false);
}
int RestorePolicy::_callback_set_PowerRestorePolicy(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<RestorePolicy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->powerRestorePolicy(convertPolicyFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace RestorePolicy
{
static const auto _property_PowerRestorePolicy =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void RestorePolicy::setPropertyByName(const std::string& _name,
                                      const PropertiesVariant& val,
                                      bool skipSignal)
{
    if (_name == "PowerRestorePolicy")
    {
        auto& v = std::get<Policy>(val);
        powerRestorePolicy(v, skipSignal);
        return;
    }
}

auto RestorePolicy::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "PowerRestorePolicy")
    {
        return powerRestorePolicy();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for RestorePolicy::Policy */
static const std::tuple<const char*, RestorePolicy::Policy>
    mappingRestorePolicyPolicy[] = {
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.RestorePolicy.Policy.AlwaysOn",
            RestorePolicy::Policy::AlwaysOn),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.RestorePolicy.Policy.AlwaysOff",
            RestorePolicy::Policy::AlwaysOff),
        std::make_tuple(
            "xyz.openbmc_project.Control.Power.RestorePolicy.Policy.Restore",
            RestorePolicy::Policy::Restore),
};

} // anonymous namespace

auto RestorePolicy::convertPolicyFromString(const std::string& s) -> Policy
{
    auto i = std::find_if(std::begin(mappingRestorePolicyPolicy),
                          std::end(mappingRestorePolicyPolicy), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingRestorePolicyPolicy) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(RestorePolicy::Policy v)
{
    auto i = std::find_if(std::begin(mappingRestorePolicyPolicy),
                          std::end(mappingRestorePolicyPolicy),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingRestorePolicyPolicy))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t RestorePolicy::_vtable[] = {
    vtable::start(),
    vtable::property(
        "PowerRestorePolicy",
        details::RestorePolicy::_property_PowerRestorePolicy.data(),
        _callback_get_PowerRestorePolicy, _callback_set_PowerRestorePolicy,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Power
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/FanRedundancy/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

FanRedundancy::FanRedundancy(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_FanRedundancy_interface(bus, path, _interface,
                                                         _vtable, this),
    _intf(bus.getInterface())
{
}

FanRedundancy::FanRedundancy(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    FanRedundancy(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto FanRedundancy::allowedFailures() const -> uint8_t
{
    return _allowedFailures;
}

int FanRedundancy::_callback_get_AllowedFailures(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<FanRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->allowedFailures()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto FanRedundancy::allowedFailures(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_allowedFailures != value)
    {
        _allowedFailures = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_FanRedundancy_interface
                .property_changed("AllowedFailures");
        }
    }

    return _allowedFailures;
}

auto FanRedundancy::allowedFailures(uint8_t val) -> uint8_t
{
    return allowedFailures(val, false);
}
int FanRedundancy::_callback_set_AllowedFailures(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<FanRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->allowedFailures(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace FanRedundancy
{
static const auto _property_AllowedFailures =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto FanRedundancy::collection() const
    -> std::vector<sdbusplus::message::object_path>
{
    return _collection;
}

int FanRedundancy::_callback_get_Collection(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<FanRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->collection()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto FanRedundancy::collection(
    std::vector<sdbusplus::message::object_path> value, bool skipSignal)
    -> std::vector<sdbusplus::message::object_path>
{
    if (_collection != value)
    {
        _collection = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_FanRedundancy_interface
                .property_changed("Collection");
        }
    }

    return _collection;
}

auto FanRedundancy::collection(std::vector<sdbusplus::message::object_path> val)
    -> std::vector<sdbusplus::message::object_path>
{
    return collection(val, false);
}
int FanRedundancy::_callback_set_Collection(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<FanRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<sdbusplus::message::object_path> v{};
        m.read(v);
        o->collection(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace FanRedundancy
{
static const auto _property_Collection = utility::tuple_to_array(
    message::types::type_id<std::vector<sdbusplus::message::object_path>>());
}
} // namespace details

auto FanRedundancy::status() const -> State
{
    return _status;
}

int FanRedundancy::_callback_get_Status(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<FanRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->status()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto FanRedundancy::status(State value, bool skipSignal) -> State
{
    if (_status != value)
    {
        _status = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_FanRedundancy_interface
                .property_changed("Status");
        }
    }

    return _status;
}

auto FanRedundancy::status(State val) -> State
{
    return status(val, false);
}
int FanRedundancy::_callback_set_Status(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<FanRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->status(convertStateFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace FanRedundancy
{
static const auto _property_Status =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void FanRedundancy::setPropertyByName(const std::string& _name,
                                      const PropertiesVariant& val,
                                      bool skipSignal)
{
    if (_name == "AllowedFailures")
    {
        auto& v = std::get<uint8_t>(val);
        allowedFailures(v, skipSignal);
        return;
    }
    if (_name == "Collection")
    {
        auto& v = std::get<std::vector<sdbusplus::message::object_path>>(val);
        collection(v, skipSignal);
        return;
    }
    if (_name == "Status")
    {
        auto& v = std::get<State>(val);
        status(v, skipSignal);
        return;
    }
}

auto FanRedundancy::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "AllowedFailures")
    {
        return allowedFailures();
    }
    if (_name == "Collection")
    {
        return collection();
    }
    if (_name == "Status")
    {
        return status();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for FanRedundancy::State */
static const std::tuple<const char*, FanRedundancy::State>
    mappingFanRedundancyState[] = {
        std::make_tuple("xyz.openbmc_project.Control.FanRedundancy.State.Full",
                        FanRedundancy::State::Full),
        std::make_tuple(
            "xyz.openbmc_project.Control.FanRedundancy.State.Degraded",
            FanRedundancy::State::Degraded),
        std::make_tuple(
            "xyz.openbmc_project.Control.FanRedundancy.State.Failed",
            FanRedundancy::State::Failed),
};

} // anonymous namespace

auto FanRedundancy::convertStateFromString(const std::string& s) -> State
{
    auto i = std::find_if(std::begin(mappingFanRedundancyState),
                          std::end(mappingFanRedundancyState), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingFanRedundancyState) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(FanRedundancy::State v)
{
    auto i = std::find_if(std::begin(mappingFanRedundancyState),
                          std::end(mappingFanRedundancyState),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingFanRedundancyState))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t FanRedundancy::_vtable[] = {
    vtable::start(),
    vtable::property("AllowedFailures",
                     details::FanRedundancy::_property_AllowedFailures.data(),
                     _callback_get_AllowedFailures, vtable::property_::const_),
    vtable::property("Collection",
                     details::FanRedundancy::_property_Collection.data(),
                     _callback_get_Collection, vtable::property_::const_),
    vtable::property("Status", details::FanRedundancy::_property_Status.data(),
                     _callback_get_Status, vtable::property_::const_),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/TPM/Policy/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace TPM
{
namespace server
{

Policy::Policy(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_TPM_Policy_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

Policy::Policy(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    Policy(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Policy::tPMEnable() const -> bool
{
    return _tPMEnable;
}

int Policy::_callback_get_TPMEnable(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* reply, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Policy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->tPMEnable()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Policy::tPMEnable(bool value, bool skipSignal) -> bool
{
    if (_tPMEnable != value)
    {
        _tPMEnable = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_TPM_Policy_interface.property_changed(
                "TPMEnable");
        }
    }

    return _tPMEnable;
}

auto Policy::tPMEnable(bool val) -> bool
{
    return tPMEnable(val, false);
}
int Policy::_callback_set_TPMEnable(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* value, void* context,
                                    sd_bus_error* error)
{
    auto o = static_cast<Policy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->tPMEnable(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Policy
{
static const auto _property_TPMEnable =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Policy::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "TPMEnable")
    {
        auto& v = std::get<bool>(val);
        tPMEnable(v, skipSignal);
        return;
    }
}

auto Policy::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "TPMEnable")
    {
        return tPMEnable();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Policy::_vtable[] = {
    vtable::start(),
    vtable::property("TPMEnable", details::Policy::_property_TPMEnable.data(),
                     _callback_get_TPMEnable, _callback_set_TPMEnable,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace TPM
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/FanPwm/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

FanPwm::FanPwm(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_FanPwm_interface(bus, path, _interface,
                                                  _vtable, this),
    _intf(bus.getInterface())
{
}

FanPwm::FanPwm(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    FanPwm(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto FanPwm::target() const -> uint64_t
{
    return _target;
}

int FanPwm::_callback_get_Target(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<FanPwm*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->target()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto FanPwm::target(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_target != value)
    {
        _target = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_FanPwm_interface.property_changed(
                "Target");
        }
    }

    return _target;
}

auto FanPwm::target(uint64_t val) -> uint64_t
{
    return target(val, false);
}
int FanPwm::_callback_set_Target(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<FanPwm*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->target(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace FanPwm
{
static const auto _property_Target =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

void FanPwm::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Target")
    {
        auto& v = std::get<uint64_t>(val);
        target(v, skipSignal);
        return;
    }
}

auto FanPwm::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Target")
    {
        return target();
    }

    return PropertiesVariant();
}

const vtable::vtable_t FanPwm::_vtable[] = {
    vtable::start(),
    vtable::property("Target", details::FanPwm::_property_Target.data(),
                     _callback_get_Target, _callback_set_Target,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/ChassisCapabilities/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

ChassisCapabilities::ChassisCapabilities(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_ChassisCapabilities_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

ChassisCapabilities::ChassisCapabilities(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    ChassisCapabilities(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto ChassisCapabilities::capabilitiesFlags() const -> uint8_t
{
    return _capabilitiesFlags;
}

int ChassisCapabilities::_callback_get_CapabilitiesFlags(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->capabilitiesFlags()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ChassisCapabilities::capabilitiesFlags(uint8_t value, bool skipSignal)
    -> uint8_t
{
    if (_capabilitiesFlags != value)
    {
        _capabilitiesFlags = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_ChassisCapabilities_interface
                .property_changed("CapabilitiesFlags");
        }
    }

    return _capabilitiesFlags;
}

auto ChassisCapabilities::capabilitiesFlags(uint8_t val) -> uint8_t
{
    return capabilitiesFlags(val, false);
}
int ChassisCapabilities::_callback_set_CapabilitiesFlags(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->capabilitiesFlags(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ChassisCapabilities
{
static const auto _property_CapabilitiesFlags =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto ChassisCapabilities::fRUDeviceAddress() const -> uint8_t
{
    return _fRUDeviceAddress;
}

int ChassisCapabilities::_callback_get_FRUDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->fRUDeviceAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ChassisCapabilities::fRUDeviceAddress(uint8_t value, bool skipSignal)
    -> uint8_t
{
    if (_fRUDeviceAddress != value)
    {
        _fRUDeviceAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_ChassisCapabilities_interface
                .property_changed("FRUDeviceAddress");
        }
    }

    return _fRUDeviceAddress;
}

auto ChassisCapabilities::fRUDeviceAddress(uint8_t val) -> uint8_t
{
    return fRUDeviceAddress(val, false);
}
int ChassisCapabilities::_callback_set_FRUDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->fRUDeviceAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ChassisCapabilities
{
static const auto _property_FRUDeviceAddress =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto ChassisCapabilities::sDRDeviceAddress() const -> uint8_t
{
    return _sDRDeviceAddress;
}

int ChassisCapabilities::_callback_get_SDRDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->sDRDeviceAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ChassisCapabilities::sDRDeviceAddress(uint8_t value, bool skipSignal)
    -> uint8_t
{
    if (_sDRDeviceAddress != value)
    {
        _sDRDeviceAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_ChassisCapabilities_interface
                .property_changed("SDRDeviceAddress");
        }
    }

    return _sDRDeviceAddress;
}

auto ChassisCapabilities::sDRDeviceAddress(uint8_t val) -> uint8_t
{
    return sDRDeviceAddress(val, false);
}
int ChassisCapabilities::_callback_set_SDRDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->sDRDeviceAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ChassisCapabilities
{
static const auto _property_SDRDeviceAddress =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto ChassisCapabilities::sELDeviceAddress() const -> uint8_t
{
    return _sELDeviceAddress;
}

int ChassisCapabilities::_callback_get_SELDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->sELDeviceAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ChassisCapabilities::sELDeviceAddress(uint8_t value, bool skipSignal)
    -> uint8_t
{
    if (_sELDeviceAddress != value)
    {
        _sELDeviceAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_ChassisCapabilities_interface
                .property_changed("SELDeviceAddress");
        }
    }

    return _sELDeviceAddress;
}

auto ChassisCapabilities::sELDeviceAddress(uint8_t val) -> uint8_t
{
    return sELDeviceAddress(val, false);
}
int ChassisCapabilities::_callback_set_SELDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->sELDeviceAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ChassisCapabilities
{
static const auto _property_SELDeviceAddress =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto ChassisCapabilities::sMDeviceAddress() const -> uint8_t
{
    return _sMDeviceAddress;
}

int ChassisCapabilities::_callback_get_SMDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->sMDeviceAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ChassisCapabilities::sMDeviceAddress(uint8_t value, bool skipSignal)
    -> uint8_t
{
    if (_sMDeviceAddress != value)
    {
        _sMDeviceAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_ChassisCapabilities_interface
                .property_changed("SMDeviceAddress");
        }
    }

    return _sMDeviceAddress;
}

auto ChassisCapabilities::sMDeviceAddress(uint8_t val) -> uint8_t
{
    return sMDeviceAddress(val, false);
}
int ChassisCapabilities::_callback_set_SMDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->sMDeviceAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ChassisCapabilities
{
static const auto _property_SMDeviceAddress =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto ChassisCapabilities::bridgeDeviceAddress() const -> uint8_t
{
    return _bridgeDeviceAddress;
}

int ChassisCapabilities::_callback_get_BridgeDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->bridgeDeviceAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ChassisCapabilities::bridgeDeviceAddress(uint8_t value, bool skipSignal)
    -> uint8_t
{
    if (_bridgeDeviceAddress != value)
    {
        _bridgeDeviceAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_ChassisCapabilities_interface
                .property_changed("BridgeDeviceAddress");
        }
    }

    return _bridgeDeviceAddress;
}

auto ChassisCapabilities::bridgeDeviceAddress(uint8_t val) -> uint8_t
{
    return bridgeDeviceAddress(val, false);
}
int ChassisCapabilities::_callback_set_BridgeDeviceAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ChassisCapabilities*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->bridgeDeviceAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ChassisCapabilities
{
static const auto _property_BridgeDeviceAddress =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

void ChassisCapabilities::setPropertyByName(const std::string& _name,
                                            const PropertiesVariant& val,
                                            bool skipSignal)
{
    if (_name == "CapabilitiesFlags")
    {
        auto& v = std::get<uint8_t>(val);
        capabilitiesFlags(v, skipSignal);
        return;
    }
    if (_name == "FRUDeviceAddress")
    {
        auto& v = std::get<uint8_t>(val);
        fRUDeviceAddress(v, skipSignal);
        return;
    }
    if (_name == "SDRDeviceAddress")
    {
        auto& v = std::get<uint8_t>(val);
        sDRDeviceAddress(v, skipSignal);
        return;
    }
    if (_name == "SELDeviceAddress")
    {
        auto& v = std::get<uint8_t>(val);
        sELDeviceAddress(v, skipSignal);
        return;
    }
    if (_name == "SMDeviceAddress")
    {
        auto& v = std::get<uint8_t>(val);
        sMDeviceAddress(v, skipSignal);
        return;
    }
    if (_name == "BridgeDeviceAddress")
    {
        auto& v = std::get<uint8_t>(val);
        bridgeDeviceAddress(v, skipSignal);
        return;
    }
}

auto ChassisCapabilities::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "CapabilitiesFlags")
    {
        return capabilitiesFlags();
    }
    if (_name == "FRUDeviceAddress")
    {
        return fRUDeviceAddress();
    }
    if (_name == "SDRDeviceAddress")
    {
        return sDRDeviceAddress();
    }
    if (_name == "SELDeviceAddress")
    {
        return sELDeviceAddress();
    }
    if (_name == "SMDeviceAddress")
    {
        return sMDeviceAddress();
    }
    if (_name == "BridgeDeviceAddress")
    {
        return bridgeDeviceAddress();
    }

    return PropertiesVariant();
}

const vtable::vtable_t ChassisCapabilities::_vtable[] = {
    vtable::start(),
    vtable::property(
        "CapabilitiesFlags",
        details::ChassisCapabilities::_property_CapabilitiesFlags.data(),
        _callback_get_CapabilitiesFlags, _callback_set_CapabilitiesFlags,
        vtable::property_::emits_change),
    vtable::property(
        "FRUDeviceAddress",
        details::ChassisCapabilities::_property_FRUDeviceAddress.data(),
        _callback_get_FRUDeviceAddress, _callback_set_FRUDeviceAddress,
        vtable::property_::emits_change),
    vtable::property(
        "SDRDeviceAddress",
        details::ChassisCapabilities::_property_SDRDeviceAddress.data(),
        _callback_get_SDRDeviceAddress, _callback_set_SDRDeviceAddress,
        vtable::property_::emits_change),
    vtable::property(
        "SELDeviceAddress",
        details::ChassisCapabilities::_property_SELDeviceAddress.data(),
        _callback_get_SELDeviceAddress, _callback_set_SELDeviceAddress,
        vtable::property_::emits_change),
    vtable::property(
        "SMDeviceAddress",
        details::ChassisCapabilities::_property_SMDeviceAddress.data(),
        _callback_get_SMDeviceAddress, _callback_set_SMDeviceAddress,
        vtable::property_::emits_change),
    vtable::property(
        "BridgeDeviceAddress",
        details::ChassisCapabilities::_property_BridgeDeviceAddress.data(),
        _callback_get_BridgeDeviceAddress, _callback_set_BridgeDeviceAddress,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/PowerSupplyRedundancy/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

PowerSupplyRedundancy::PowerSupplyRedundancy(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_PowerSupplyRedundancy_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

PowerSupplyRedundancy::PowerSupplyRedundancy(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    PowerSupplyRedundancy(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto PowerSupplyRedundancy::powerSupplyRedundancyEnabled() const -> bool
{
    return _powerSupplyRedundancyEnabled;
}

int PowerSupplyRedundancy::_callback_get_PowerSupplyRedundancyEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->powerSupplyRedundancyEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerSupplyRedundancy::powerSupplyRedundancyEnabled(bool value,
                                                         bool skipSignal)
    -> bool
{
    if (_powerSupplyRedundancyEnabled != value)
    {
        _powerSupplyRedundancyEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_PowerSupplyRedundancy_interface
                .property_changed("PowerSupplyRedundancyEnabled");
        }
    }

    return _powerSupplyRedundancyEnabled;
}

auto PowerSupplyRedundancy::powerSupplyRedundancyEnabled(bool val) -> bool
{
    return powerSupplyRedundancyEnabled(val, false);
}
int PowerSupplyRedundancy::_callback_set_PowerSupplyRedundancyEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->powerSupplyRedundancyEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerSupplyRedundancy
{
static const auto _property_PowerSupplyRedundancyEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto PowerSupplyRedundancy::rotationEnabled() const -> bool
{
    return _rotationEnabled;
}

int PowerSupplyRedundancy::_callback_get_RotationEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->rotationEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerSupplyRedundancy::rotationEnabled(bool value, bool skipSignal) -> bool
{
    if (_rotationEnabled != value)
    {
        _rotationEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_PowerSupplyRedundancy_interface
                .property_changed("RotationEnabled");
        }
    }

    return _rotationEnabled;
}

auto PowerSupplyRedundancy::rotationEnabled(bool val) -> bool
{
    return rotationEnabled(val, false);
}
int PowerSupplyRedundancy::_callback_set_RotationEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->rotationEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerSupplyRedundancy
{
static const auto _property_RotationEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto PowerSupplyRedundancy::rotationAlgorithm() const -> Algo
{
    return _rotationAlgorithm;
}

int PowerSupplyRedundancy::_callback_get_RotationAlgorithm(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->rotationAlgorithm()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerSupplyRedundancy::rotationAlgorithm(Algo value, bool skipSignal)
    -> Algo
{
    if (_rotationAlgorithm != value)
    {
        _rotationAlgorithm = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_PowerSupplyRedundancy_interface
                .property_changed("RotationAlgorithm");
        }
    }

    return _rotationAlgorithm;
}

auto PowerSupplyRedundancy::rotationAlgorithm(Algo val) -> Algo
{
    return rotationAlgorithm(val, false);
}
int PowerSupplyRedundancy::_callback_set_RotationAlgorithm(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->rotationAlgorithm(convertAlgoFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerSupplyRedundancy
{
static const auto _property_RotationAlgorithm =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PowerSupplyRedundancy::rotationRankOrder() const -> std::vector<uint8_t>
{
    return _rotationRankOrder;
}

int PowerSupplyRedundancy::_callback_get_RotationRankOrder(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->rotationRankOrder()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerSupplyRedundancy::rotationRankOrder(std::vector<uint8_t> value,
                                              bool skipSignal)
    -> std::vector<uint8_t>
{
    if (_rotationRankOrder != value)
    {
        _rotationRankOrder = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_PowerSupplyRedundancy_interface
                .property_changed("RotationRankOrder");
        }
    }

    return _rotationRankOrder;
}

auto PowerSupplyRedundancy::rotationRankOrder(std::vector<uint8_t> val)
    -> std::vector<uint8_t>
{
    return rotationRankOrder(val, false);
}
int PowerSupplyRedundancy::_callback_set_RotationRankOrder(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<uint8_t> v{};
        m.read(v);
        o->rotationRankOrder(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerSupplyRedundancy
{
static const auto _property_RotationRankOrder =
    utility::tuple_to_array(message::types::type_id<std::vector<uint8_t>>());
}
} // namespace details

auto PowerSupplyRedundancy::periodOfRotation() const -> uint32_t
{
    return _periodOfRotation;
}

int PowerSupplyRedundancy::_callback_get_PeriodOfRotation(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->periodOfRotation()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerSupplyRedundancy::periodOfRotation(uint32_t value, bool skipSignal)
    -> uint32_t
{
    if (_periodOfRotation != value)
    {
        _periodOfRotation = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_PowerSupplyRedundancy_interface
                .property_changed("PeriodOfRotation");
        }
    }

    return _periodOfRotation;
}

auto PowerSupplyRedundancy::periodOfRotation(uint32_t val) -> uint32_t
{
    return periodOfRotation(val, false);
}
int PowerSupplyRedundancy::_callback_set_PeriodOfRotation(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->periodOfRotation(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerSupplyRedundancy
{
static const auto _property_PeriodOfRotation =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto PowerSupplyRedundancy::coldRedundancyStatus() const -> Status
{
    return _coldRedundancyStatus;
}

int PowerSupplyRedundancy::_callback_get_ColdRedundancyStatus(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->coldRedundancyStatus()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerSupplyRedundancy::coldRedundancyStatus(Status value, bool skipSignal)
    -> Status
{
    if (_coldRedundancyStatus != value)
    {
        _coldRedundancyStatus = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_PowerSupplyRedundancy_interface
                .property_changed("ColdRedundancyStatus");
        }
    }

    return _coldRedundancyStatus;
}

auto PowerSupplyRedundancy::coldRedundancyStatus(Status val) -> Status
{
    return coldRedundancyStatus(val, false);
}
int PowerSupplyRedundancy::_callback_set_ColdRedundancyStatus(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->coldRedundancyStatus(convertStatusFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerSupplyRedundancy
{
static const auto _property_ColdRedundancyStatus =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PowerSupplyRedundancy::pSUNumber() const -> uint8_t
{
    return _pSUNumber;
}

int PowerSupplyRedundancy::_callback_get_PSUNumber(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->pSUNumber()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerSupplyRedundancy::pSUNumber(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_pSUNumber != value)
    {
        _pSUNumber = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_PowerSupplyRedundancy_interface
                .property_changed("PSUNumber");
        }
    }

    return _pSUNumber;
}

auto PowerSupplyRedundancy::pSUNumber(uint8_t val) -> uint8_t
{
    return pSUNumber(val, false);
}
int PowerSupplyRedundancy::_callback_set_PSUNumber(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PowerSupplyRedundancy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->pSUNumber(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerSupplyRedundancy
{
static const auto _property_PSUNumber =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

void PowerSupplyRedundancy::setPropertyByName(const std::string& _name,
                                              const PropertiesVariant& val,
                                              bool skipSignal)
{
    if (_name == "PowerSupplyRedundancyEnabled")
    {
        auto& v = std::get<bool>(val);
        powerSupplyRedundancyEnabled(v, skipSignal);
        return;
    }
    if (_name == "RotationEnabled")
    {
        auto& v = std::get<bool>(val);
        rotationEnabled(v, skipSignal);
        return;
    }
    if (_name == "RotationAlgorithm")
    {
        auto& v = std::get<Algo>(val);
        rotationAlgorithm(v, skipSignal);
        return;
    }
    if (_name == "RotationRankOrder")
    {
        auto& v = std::get<std::vector<uint8_t>>(val);
        rotationRankOrder(v, skipSignal);
        return;
    }
    if (_name == "PeriodOfRotation")
    {
        auto& v = std::get<uint32_t>(val);
        periodOfRotation(v, skipSignal);
        return;
    }
    if (_name == "ColdRedundancyStatus")
    {
        auto& v = std::get<Status>(val);
        coldRedundancyStatus(v, skipSignal);
        return;
    }
    if (_name == "PSUNumber")
    {
        auto& v = std::get<uint8_t>(val);
        pSUNumber(v, skipSignal);
        return;
    }
}

auto PowerSupplyRedundancy::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "PowerSupplyRedundancyEnabled")
    {
        return powerSupplyRedundancyEnabled();
    }
    if (_name == "RotationEnabled")
    {
        return rotationEnabled();
    }
    if (_name == "RotationAlgorithm")
    {
        return rotationAlgorithm();
    }
    if (_name == "RotationRankOrder")
    {
        return rotationRankOrder();
    }
    if (_name == "PeriodOfRotation")
    {
        return periodOfRotation();
    }
    if (_name == "ColdRedundancyStatus")
    {
        return coldRedundancyStatus();
    }
    if (_name == "PSUNumber")
    {
        return pSUNumber();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for PowerSupplyRedundancy::Algo */
static const std::tuple<const char*, PowerSupplyRedundancy::Algo>
    mappingPowerSupplyRedundancyAlgo[] = {
        std::make_tuple("xyz.openbmc_project.Control.PowerSupplyRedundancy."
                        "Algo.bmcSpecific",
                        PowerSupplyRedundancy::Algo::bmcSpecific),
        std::make_tuple("xyz.openbmc_project.Control.PowerSupplyRedundancy."
                        "Algo.userSpecific",
                        PowerSupplyRedundancy::Algo::userSpecific),
};

} // anonymous namespace

auto PowerSupplyRedundancy::convertAlgoFromString(const std::string& s) -> Algo
{
    auto i =
        std::find_if(std::begin(mappingPowerSupplyRedundancyAlgo),
                     std::end(mappingPowerSupplyRedundancyAlgo), [&s](auto& e) {
                         return 0 == strcmp(s.c_str(), std::get<0>(e));
                     });
    if (std::end(mappingPowerSupplyRedundancyAlgo) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(PowerSupplyRedundancy::Algo v)
{
    auto i = std::find_if(std::begin(mappingPowerSupplyRedundancyAlgo),
                          std::end(mappingPowerSupplyRedundancyAlgo),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingPowerSupplyRedundancyAlgo))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for PowerSupplyRedundancy::Status */
static const std::tuple<const char*, PowerSupplyRedundancy::Status>
    mappingPowerSupplyRedundancyStatus[] = {
        std::make_tuple("xyz.openbmc_project.Control.PowerSupplyRedundancy."
                        "Status.inProgress",
                        PowerSupplyRedundancy::Status::inProgress),
        std::make_tuple("xyz.openbmc_project.Control.PowerSupplyRedundancy."
                        "Status.completed",
                        PowerSupplyRedundancy::Status::completed),
};

} // anonymous namespace

auto PowerSupplyRedundancy::convertStatusFromString(const std::string& s)
    -> Status
{
    auto i = std::find_if(
        std::begin(mappingPowerSupplyRedundancyStatus),
        std::end(mappingPowerSupplyRedundancyStatus),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingPowerSupplyRedundancyStatus) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(PowerSupplyRedundancy::Status v)
{
    auto i = std::find_if(std::begin(mappingPowerSupplyRedundancyStatus),
                          std::end(mappingPowerSupplyRedundancyStatus),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingPowerSupplyRedundancyStatus))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t PowerSupplyRedundancy::_vtable[] = {
    vtable::start(),
    vtable::property(
        "PowerSupplyRedundancyEnabled",
        details::PowerSupplyRedundancy::_property_PowerSupplyRedundancyEnabled
            .data(),
        _callback_get_PowerSupplyRedundancyEnabled, vtable::property_::const_),
    vtable::property(
        "RotationEnabled",
        details::PowerSupplyRedundancy::_property_RotationEnabled.data(),
        _callback_get_RotationEnabled, _callback_set_RotationEnabled,
        vtable::property_::emits_change),
    vtable::property(
        "RotationAlgorithm",
        details::PowerSupplyRedundancy::_property_RotationAlgorithm.data(),
        _callback_get_RotationAlgorithm, _callback_set_RotationAlgorithm,
        vtable::property_::emits_change),
    vtable::property(
        "RotationRankOrder",
        details::PowerSupplyRedundancy::_property_RotationRankOrder.data(),
        _callback_get_RotationRankOrder, _callback_set_RotationRankOrder,
        vtable::property_::emits_change),
    vtable::property(
        "PeriodOfRotation",
        details::PowerSupplyRedundancy::_property_PeriodOfRotation.data(),
        _callback_get_PeriodOfRotation, _callback_set_PeriodOfRotation,
        vtable::property_::emits_change),
    vtable::property(
        "ColdRedundancyStatus",
        details::PowerSupplyRedundancy::_property_ColdRedundancyStatus.data(),
        _callback_get_ColdRedundancyStatus, _callback_set_ColdRedundancyStatus,
        vtable::property_::emits_change),
    vtable::property("PSUNumber",
                     details::PowerSupplyRedundancy::_property_PSUNumber.data(),
                     _callback_get_PSUNumber, _callback_set_PSUNumber,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Host/error.hpp>
#include <xyz/openbmc_project/Control/Host/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

Host::Host(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Host_interface(bus, path, _interface, _vtable,
                                                this),
    _intf(bus.getInterface())
{
}

int Host::_callback_Execute(sd_bus_message* msg, void* context,
                            sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string command{};

        m.read(command);

        auto o = static_cast<Host*>(context);
        o->execute(convertCommandFromString(command));

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Control::Host::Error::
               CommandNotSupported& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Host
{
static const auto _param_Execute =
    utility::tuple_to_array(message::types::type_id<std::string>());
static const auto _return_Execute =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Host
} // namespace details

void Host::commandComplete(Command command, Result result)
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_Control_Host_interface;
    auto m = i.new_signal("CommandComplete");

    m.append(convertForMessage(command), convertForMessage(result));
    m.signal_send();
}

namespace details
{
namespace Host
{
static const auto _signal_CommandComplete = utility::tuple_to_array(
    message::types::type_id<std::string, std::string>());
}
} // namespace details

namespace
{
/** String to enum mapping for Host::Command */
static const std::tuple<const char*, Host::Command> mappingHostCommand[] = {
    std::make_tuple("xyz.openbmc_project.Control.Host.Command.SoftOff",
                    Host::Command::SoftOff),
    std::make_tuple("xyz.openbmc_project.Control.Host.Command.Heartbeat",
                    Host::Command::Heartbeat),
};

} // anonymous namespace

auto Host::convertCommandFromString(const std::string& s) -> Command
{
    auto i = std::find_if(
        std::begin(mappingHostCommand), std::end(mappingHostCommand),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingHostCommand) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Host::Command v)
{
    auto i = std::find_if(std::begin(mappingHostCommand),
                          std::end(mappingHostCommand),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingHostCommand))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Host::Result */
static const std::tuple<const char*, Host::Result> mappingHostResult[] = {
    std::make_tuple("xyz.openbmc_project.Control.Host.Result.Success",
                    Host::Result::Success),
    std::make_tuple("xyz.openbmc_project.Control.Host.Result.Failure",
                    Host::Result::Failure),
};

} // anonymous namespace

auto Host::convertResultFromString(const std::string& s) -> Result
{
    auto i = std::find_if(
        std::begin(mappingHostResult), std::end(mappingHostResult),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingHostResult) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Host::Result v)
{
    auto i =
        std::find_if(std::begin(mappingHostResult), std::end(mappingHostResult),
                     [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingHostResult))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Host::_vtable[] = {
    vtable::start(),

    vtable::method("Execute", details::Host::_param_Execute.data(),
                   details::Host::_return_Execute.data(), _callback_Execute),

    vtable::signal("CommandComplete",
                   details::Host::_signal_CommandComplete.data()),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Boot/RebootAttempts/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Boot
{
namespace server
{

RebootAttempts::RebootAttempts(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Boot_RebootAttempts_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

RebootAttempts::RebootAttempts(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    RebootAttempts(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto RebootAttempts::attemptsLeft() const -> uint32_t
{
    return _attemptsLeft;
}

int RebootAttempts::_callback_get_AttemptsLeft(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<RebootAttempts*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->attemptsLeft()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto RebootAttempts::attemptsLeft(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_attemptsLeft != value)
    {
        _attemptsLeft = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Boot_RebootAttempts_interface
                .property_changed("AttemptsLeft");
        }
    }

    return _attemptsLeft;
}

auto RebootAttempts::attemptsLeft(uint32_t val) -> uint32_t
{
    return attemptsLeft(val, false);
}
int RebootAttempts::_callback_set_AttemptsLeft(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<RebootAttempts*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->attemptsLeft(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace RebootAttempts
{
static const auto _property_AttemptsLeft =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

void RebootAttempts::setPropertyByName(const std::string& _name,
                                       const PropertiesVariant& val,
                                       bool skipSignal)
{
    if (_name == "AttemptsLeft")
    {
        auto& v = std::get<uint32_t>(val);
        attemptsLeft(v, skipSignal);
        return;
    }
}

auto RebootAttempts::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "AttemptsLeft")
    {
        return attemptsLeft();
    }

    return PropertiesVariant();
}

const vtable::vtable_t RebootAttempts::_vtable[] = {
    vtable::start(),
    vtable::property("AttemptsLeft",
                     details::RebootAttempts::_property_AttemptsLeft.data(),
                     _callback_get_AttemptsLeft, _callback_set_AttemptsLeft,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Boot
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Boot/Source/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Boot
{
namespace server
{

Source::Source(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Boot_Source_interface(bus, path, _interface,
                                                       _vtable, this),
    _intf(bus.getInterface())
{
}

Source::Source(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    Source(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Source::bootSource() const -> Sources
{
    return _bootSource;
}

int Source::_callback_get_BootSource(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Source*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->bootSource()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Source::bootSource(Sources value, bool skipSignal) -> Sources
{
    if (_bootSource != value)
    {
        _bootSource = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Boot_Source_interface.property_changed(
                "BootSource");
        }
    }

    return _bootSource;
}

auto Source::bootSource(Sources val) -> Sources
{
    return bootSource(val, false);
}
int Source::_callback_set_BootSource(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<Source*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->bootSource(convertSourcesFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Source
{
static const auto _property_BootSource =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Source::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "BootSource")
    {
        auto& v = std::get<Sources>(val);
        bootSource(v, skipSignal);
        return;
    }
}

auto Source::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "BootSource")
    {
        return bootSource();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Source::Sources */
static const std::tuple<const char*, Source::Sources> mappingSourceSources[] = {
    std::make_tuple("xyz.openbmc_project.Control.Boot.Source.Sources.Disk",
                    Source::Sources::Disk),
    std::make_tuple(
        "xyz.openbmc_project.Control.Boot.Source.Sources.ExternalMedia",
        Source::Sources::ExternalMedia),
    std::make_tuple("xyz.openbmc_project.Control.Boot.Source.Sources.Network",
                    Source::Sources::Network),
    std::make_tuple("xyz.openbmc_project.Control.Boot.Source.Sources.Default",
                    Source::Sources::Default),
    std::make_tuple(
        "xyz.openbmc_project.Control.Boot.Source.Sources.RemovableMedia",
        Source::Sources::RemovableMedia),
};

} // anonymous namespace

auto Source::convertSourcesFromString(const std::string& s) -> Sources
{
    auto i = std::find_if(
        std::begin(mappingSourceSources), std::end(mappingSourceSources),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingSourceSources) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Source::Sources v)
{
    auto i = std::find_if(std::begin(mappingSourceSources),
                          std::end(mappingSourceSources),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingSourceSources))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Source::_vtable[] = {
    vtable::start(),
    vtable::property("BootSource", details::Source::_property_BootSource.data(),
                     _callback_get_BootSource, _callback_set_BootSource,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Boot
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Boot/RebootPolicy/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Boot
{
namespace server
{

RebootPolicy::RebootPolicy(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Boot_RebootPolicy_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

RebootPolicy::RebootPolicy(bus::bus& bus, const char* path,
                           const std::map<std::string, PropertiesVariant>& vals,
                           bool skipSignal) :
    RebootPolicy(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto RebootPolicy::autoReboot() const -> bool
{
    return _autoReboot;
}

int RebootPolicy::_callback_get_AutoReboot(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<RebootPolicy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->autoReboot()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto RebootPolicy::autoReboot(bool value, bool skipSignal) -> bool
{
    if (_autoReboot != value)
    {
        _autoReboot = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Boot_RebootPolicy_interface
                .property_changed("AutoReboot");
        }
    }

    return _autoReboot;
}

auto RebootPolicy::autoReboot(bool val) -> bool
{
    return autoReboot(val, false);
}
int RebootPolicy::_callback_set_AutoReboot(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<RebootPolicy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->autoReboot(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace RebootPolicy
{
static const auto _property_AutoReboot =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void RebootPolicy::setPropertyByName(const std::string& _name,
                                     const PropertiesVariant& val,
                                     bool skipSignal)
{
    if (_name == "AutoReboot")
    {
        auto& v = std::get<bool>(val);
        autoReboot(v, skipSignal);
        return;
    }
}

auto RebootPolicy::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "AutoReboot")
    {
        return autoReboot();
    }

    return PropertiesVariant();
}

const vtable::vtable_t RebootPolicy::_vtable[] = {
    vtable::start(),
    vtable::property("AutoReboot",
                     details::RebootPolicy::_property_AutoReboot.data(),
                     _callback_get_AutoReboot, _callback_set_AutoReboot,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Boot
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Boot/Mode/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Boot
{
namespace server
{

Mode::Mode(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Boot_Mode_interface(bus, path, _interface,
                                                     _vtable, this),
    _intf(bus.getInterface())
{
}

Mode::Mode(bus::bus& bus, const char* path,
           const std::map<std::string, PropertiesVariant>& vals,
           bool skipSignal) :
    Mode(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Mode::bootMode() const -> Modes
{
    return _bootMode;
}

int Mode::_callback_get_BootMode(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Mode*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->bootMode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Mode::bootMode(Modes value, bool skipSignal) -> Modes
{
    if (_bootMode != value)
    {
        _bootMode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Boot_Mode_interface.property_changed(
                "BootMode");
        }
    }

    return _bootMode;
}

auto Mode::bootMode(Modes val) -> Modes
{
    return bootMode(val, false);
}
int Mode::_callback_set_BootMode(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<Mode*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->bootMode(convertModesFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Mode
{
static const auto _property_BootMode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Mode::setPropertyByName(const std::string& _name,
                             const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "BootMode")
    {
        auto& v = std::get<Modes>(val);
        bootMode(v, skipSignal);
        return;
    }
}

auto Mode::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "BootMode")
    {
        return bootMode();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Mode::Modes */
static const std::tuple<const char*, Mode::Modes> mappingModeModes[] = {
    std::make_tuple("xyz.openbmc_project.Control.Boot.Mode.Modes.Regular",
                    Mode::Modes::Regular),
    std::make_tuple("xyz.openbmc_project.Control.Boot.Mode.Modes.Safe",
                    Mode::Modes::Safe),
    std::make_tuple("xyz.openbmc_project.Control.Boot.Mode.Modes.Setup",
                    Mode::Modes::Setup),
};

} // anonymous namespace

auto Mode::convertModesFromString(const std::string& s) -> Modes
{
    auto i = std::find_if(
        std::begin(mappingModeModes), std::end(mappingModeModes),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingModeModes) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Mode::Modes v)
{
    auto i =
        std::find_if(std::begin(mappingModeModes), std::end(mappingModeModes),
                     [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingModeModes))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Mode::_vtable[] = {
    vtable::start(),
    vtable::property("BootMode", details::Mode::_property_BootMode.data(),
                     _callback_get_BootMode, _callback_set_BootMode,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Boot
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Control/Mode/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace server
{

Mode::Mode(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Control_Mode_interface(bus, path, _interface, _vtable,
                                                this),
    _intf(bus.getInterface())
{
}

Mode::Mode(bus::bus& bus, const char* path,
           const std::map<std::string, PropertiesVariant>& vals,
           bool skipSignal) :
    Mode(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Mode::manual() const -> bool
{
    return _manual;
}

int Mode::_callback_get_Manual(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Mode*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->manual()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Mode::manual(bool value, bool skipSignal) -> bool
{
    if (_manual != value)
    {
        _manual = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Mode_interface.property_changed(
                "Manual");
        }
    }

    return _manual;
}

auto Mode::manual(bool val) -> bool
{
    return manual(val, false);
}
int Mode::_callback_set_Manual(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<Mode*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->manual(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Mode
{
static const auto _property_Manual =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Mode::failSafe() const -> bool
{
    return _failSafe;
}

int Mode::_callback_get_FailSafe(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Mode*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->failSafe()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Mode::failSafe(bool value, bool skipSignal) -> bool
{
    if (_failSafe != value)
    {
        _failSafe = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Control_Mode_interface.property_changed(
                "FailSafe");
        }
    }

    return _failSafe;
}

auto Mode::failSafe(bool val) -> bool
{
    return failSafe(val, false);
}
int Mode::_callback_set_FailSafe(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<Mode*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->failSafe(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Mode
{
static const auto _property_FailSafe =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Mode::setPropertyByName(const std::string& _name,
                             const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Manual")
    {
        auto& v = std::get<bool>(val);
        manual(v, skipSignal);
        return;
    }
    if (_name == "FailSafe")
    {
        auto& v = std::get<bool>(val);
        failSafe(v, skipSignal);
        return;
    }
}

auto Mode::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Manual")
    {
        return manual();
    }
    if (_name == "FailSafe")
    {
        return failSafe();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Mode::_vtable[] = {
    vtable::start(),
    vtable::property("Manual", details::Mode::_property_Manual.data(),
                     _callback_get_Manual, _callback_set_Manual,
                     vtable::property_::emits_change),
    vtable::property("FailSafe", details::Mode::_property_FailSafe.data(),
                     _callback_get_FailSafe, _callback_set_FailSafe,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Software/ActivationBlocksTransition/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace server
{

ActivationBlocksTransition::ActivationBlocksTransition(bus::bus& bus,
                                                       const char* path) :
    _xyz_openbmc_project_Software_ActivationBlocksTransition_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

const vtable::vtable_t ActivationBlocksTransition::_vtable[] = {vtable::start(),
                                                                vtable::end()};

} // namespace server
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Software/ActivationProgress/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace server
{

ActivationProgress::ActivationProgress(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Software_ActivationProgress_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

ActivationProgress::ActivationProgress(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    ActivationProgress(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto ActivationProgress::progress() const -> uint8_t
{
    return _progress;
}

int ActivationProgress::_callback_get_Progress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ActivationProgress*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->progress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ActivationProgress::progress(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_progress != value)
    {
        _progress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Software_ActivationProgress_interface
                .property_changed("Progress");
        }
    }

    return _progress;
}

auto ActivationProgress::progress(uint8_t val) -> uint8_t
{
    return progress(val, false);
}
int ActivationProgress::_callback_set_Progress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ActivationProgress*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->progress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ActivationProgress
{
static const auto _property_Progress =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

void ActivationProgress::setPropertyByName(const std::string& _name,
                                           const PropertiesVariant& val,
                                           bool skipSignal)
{
    if (_name == "Progress")
    {
        auto& v = std::get<uint8_t>(val);
        progress(v, skipSignal);
        return;
    }
}

auto ActivationProgress::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "Progress")
    {
        return progress();
    }

    return PropertiesVariant();
}

const vtable::vtable_t ActivationProgress::_vtable[] = {
    vtable::start(),
    vtable::property("Progress",
                     details::ActivationProgress::_property_Progress.data(),
                     _callback_get_Progress, _callback_set_Progress,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Software/RedundancyPriority/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace server
{

RedundancyPriority::RedundancyPriority(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Software_RedundancyPriority_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

RedundancyPriority::RedundancyPriority(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    RedundancyPriority(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto RedundancyPriority::priority() const -> uint8_t
{
    return _priority;
}

int RedundancyPriority::_callback_get_Priority(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<RedundancyPriority*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->priority()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto RedundancyPriority::priority(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_priority != value)
    {
        _priority = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Software_RedundancyPriority_interface
                .property_changed("Priority");
        }
    }

    return _priority;
}

auto RedundancyPriority::priority(uint8_t val) -> uint8_t
{
    return priority(val, false);
}
int RedundancyPriority::_callback_set_Priority(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<RedundancyPriority*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->priority(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace RedundancyPriority
{
static const auto _property_Priority =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

void RedundancyPriority::setPropertyByName(const std::string& _name,
                                           const PropertiesVariant& val,
                                           bool skipSignal)
{
    if (_name == "Priority")
    {
        auto& v = std::get<uint8_t>(val);
        priority(v, skipSignal);
        return;
    }
}

auto RedundancyPriority::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "Priority")
    {
        return priority();
    }

    return PropertiesVariant();
}

const vtable::vtable_t RedundancyPriority::_vtable[] = {
    vtable::start(),
    vtable::property("Priority",
                     details::RedundancyPriority::_property_Priority.data(),
                     _callback_get_Priority, _callback_set_Priority,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Software/ExtendedVersion/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace server
{

ExtendedVersion::ExtendedVersion(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Software_ExtendedVersion_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

ExtendedVersion::ExtendedVersion(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    ExtendedVersion(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto ExtendedVersion::extendedVersion() const -> std::string
{
    return _extendedVersion;
}

int ExtendedVersion::_callback_get_ExtendedVersion(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ExtendedVersion*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->extendedVersion()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ExtendedVersion::extendedVersion(std::string value, bool skipSignal)
    -> std::string
{
    if (_extendedVersion != value)
    {
        _extendedVersion = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Software_ExtendedVersion_interface
                .property_changed("ExtendedVersion");
        }
    }

    return _extendedVersion;
}

auto ExtendedVersion::extendedVersion(std::string val) -> std::string
{
    return extendedVersion(val, false);
}
int ExtendedVersion::_callback_set_ExtendedVersion(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ExtendedVersion*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->extendedVersion(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ExtendedVersion
{
static const auto _property_ExtendedVersion =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void ExtendedVersion::setPropertyByName(const std::string& _name,
                                        const PropertiesVariant& val,
                                        bool skipSignal)
{
    if (_name == "ExtendedVersion")
    {
        auto& v = std::get<std::string>(val);
        extendedVersion(v, skipSignal);
        return;
    }
}

auto ExtendedVersion::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "ExtendedVersion")
    {
        return extendedVersion();
    }

    return PropertiesVariant();
}

const vtable::vtable_t ExtendedVersion::_vtable[] = {
    vtable::start(),
    vtable::property("ExtendedVersion",
                     details::ExtendedVersion::_property_ExtendedVersion.data(),
                     _callback_get_ExtendedVersion,
                     _callback_set_ExtendedVersion,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Software/ApplyTime/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace server
{

ApplyTime::ApplyTime(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Software_ApplyTime_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

ApplyTime::ApplyTime(bus::bus& bus, const char* path,
                     const std::map<std::string, PropertiesVariant>& vals,
                     bool skipSignal) :
    ApplyTime(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto ApplyTime::requestedApplyTime() const -> RequestedApplyTimes
{
    return _requestedApplyTime;
}

int ApplyTime::_callback_get_RequestedApplyTime(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ApplyTime*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->requestedApplyTime()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ApplyTime::requestedApplyTime(RequestedApplyTimes value, bool skipSignal)
    -> RequestedApplyTimes
{
    if (_requestedApplyTime != value)
    {
        _requestedApplyTime = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Software_ApplyTime_interface.property_changed(
                "RequestedApplyTime");
        }
    }

    return _requestedApplyTime;
}

auto ApplyTime::requestedApplyTime(RequestedApplyTimes val)
    -> RequestedApplyTimes
{
    return requestedApplyTime(val, false);
}
int ApplyTime::_callback_set_RequestedApplyTime(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<ApplyTime*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->requestedApplyTime(convertRequestedApplyTimesFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ApplyTime
{
static const auto _property_RequestedApplyTime =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void ApplyTime::setPropertyByName(const std::string& _name,
                                  const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "RequestedApplyTime")
    {
        auto& v = std::get<RequestedApplyTimes>(val);
        requestedApplyTime(v, skipSignal);
        return;
    }
}

auto ApplyTime::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "RequestedApplyTime")
    {
        return requestedApplyTime();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for ApplyTime::RequestedApplyTimes */
static const std::tuple<const char*, ApplyTime::RequestedApplyTimes>
    mappingApplyTimeRequestedApplyTimes[] = {
        std::make_tuple("xyz.openbmc_project.Software.ApplyTime."
                        "RequestedApplyTimes.Immediate",
                        ApplyTime::RequestedApplyTimes::Immediate),
        std::make_tuple("xyz.openbmc_project.Software.ApplyTime."
                        "RequestedApplyTimes.OnReset",
                        ApplyTime::RequestedApplyTimes::OnReset),
};

} // anonymous namespace

auto ApplyTime::convertRequestedApplyTimesFromString(const std::string& s)
    -> RequestedApplyTimes
{
    auto i = std::find_if(
        std::begin(mappingApplyTimeRequestedApplyTimes),
        std::end(mappingApplyTimeRequestedApplyTimes),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingApplyTimeRequestedApplyTimes) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(ApplyTime::RequestedApplyTimes v)
{
    auto i = std::find_if(std::begin(mappingApplyTimeRequestedApplyTimes),
                          std::end(mappingApplyTimeRequestedApplyTimes),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingApplyTimeRequestedApplyTimes))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t ApplyTime::_vtable[] = {
    vtable::start(),
    vtable::property("RequestedApplyTime",
                     details::ApplyTime::_property_RequestedApplyTime.data(),
                     _callback_get_RequestedApplyTime,
                     _callback_set_RequestedApplyTime,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Software/Version/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace server
{

Version::Version(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Software_Version_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

Version::Version(bus::bus& bus, const char* path,
                 const std::map<std::string, PropertiesVariant>& vals,
                 bool skipSignal) :
    Version(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Version::version() const -> std::string
{
    return _version;
}

int Version::_callback_get_Version(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Version*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->version()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Version::version(std::string value, bool skipSignal) -> std::string
{
    if (_version != value)
    {
        _version = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Software_Version_interface.property_changed(
                "Version");
        }
    }

    return _version;
}

auto Version::version(std::string val) -> std::string
{
    return version(val, false);
}
int Version::_callback_set_Version(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Version*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->version(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Version
{
static const auto _property_Version =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Version::purpose() const -> VersionPurpose
{
    return _purpose;
}

int Version::_callback_get_Purpose(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Version*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->purpose()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Version::purpose(VersionPurpose value, bool skipSignal) -> VersionPurpose
{
    if (_purpose != value)
    {
        _purpose = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Software_Version_interface.property_changed(
                "Purpose");
        }
    }

    return _purpose;
}

auto Version::purpose(VersionPurpose val) -> VersionPurpose
{
    return purpose(val, false);
}
int Version::_callback_set_Purpose(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Version*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->purpose(convertVersionPurposeFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Version
{
static const auto _property_Purpose =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Version::setPropertyByName(const std::string& _name,
                                const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Version")
    {
        auto& v = std::get<std::string>(val);
        version(v, skipSignal);
        return;
    }
    if (_name == "Purpose")
    {
        auto& v = std::get<VersionPurpose>(val);
        purpose(v, skipSignal);
        return;
    }
}

auto Version::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Version")
    {
        return version();
    }
    if (_name == "Purpose")
    {
        return purpose();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Version::VersionPurpose */
static const std::tuple<const char*, Version::VersionPurpose>
    mappingVersionVersionPurpose[] = {
        std::make_tuple(
            "xyz.openbmc_project.Software.Version.VersionPurpose.Unknown",
            Version::VersionPurpose::Unknown),
        std::make_tuple(
            "xyz.openbmc_project.Software.Version.VersionPurpose.Other",
            Version::VersionPurpose::Other),
        std::make_tuple(
            "xyz.openbmc_project.Software.Version.VersionPurpose.System",
            Version::VersionPurpose::System),
        std::make_tuple(
            "xyz.openbmc_project.Software.Version.VersionPurpose.BMC",
            Version::VersionPurpose::BMC),
        std::make_tuple(
            "xyz.openbmc_project.Software.Version.VersionPurpose.Host",
            Version::VersionPurpose::Host),
        std::make_tuple(
            "xyz.openbmc_project.Software.Version.VersionPurpose.PSU",
            Version::VersionPurpose::PSU),
};

} // anonymous namespace

auto Version::convertVersionPurposeFromString(const std::string& s)
    -> VersionPurpose
{
    auto i =
        std::find_if(std::begin(mappingVersionVersionPurpose),
                     std::end(mappingVersionVersionPurpose), [&s](auto& e) {
                         return 0 == strcmp(s.c_str(), std::get<0>(e));
                     });
    if (std::end(mappingVersionVersionPurpose) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Version::VersionPurpose v)
{
    auto i = std::find_if(std::begin(mappingVersionVersionPurpose),
                          std::end(mappingVersionVersionPurpose),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingVersionVersionPurpose))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Version::_vtable[] = {
    vtable::start(),
    vtable::property("Version", details::Version::_property_Version.data(),
                     _callback_get_Version, _callback_set_Version,
                     vtable::property_::emits_change),
    vtable::property("Purpose", details::Version::_property_Purpose.data(),
                     _callback_get_Purpose, _callback_set_Purpose,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Software/Activation/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace server
{

Activation::Activation(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Software_Activation_interface(bus, path, _interface,
                                                       _vtable, this),
    _intf(bus.getInterface())
{
}

Activation::Activation(bus::bus& bus, const char* path,
                       const std::map<std::string, PropertiesVariant>& vals,
                       bool skipSignal) :
    Activation(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Activation::activation() const -> Activations
{
    return _activation;
}

int Activation::_callback_get_Activation(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Activation*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->activation()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Activation::activation(Activations value, bool skipSignal) -> Activations
{
    if (_activation != value)
    {
        _activation = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Software_Activation_interface.property_changed(
                "Activation");
        }
    }

    return _activation;
}

auto Activation::activation(Activations val) -> Activations
{
    return activation(val, false);
}
int Activation::_callback_set_Activation(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Activation*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->activation(convertActivationsFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Activation
{
static const auto _property_Activation =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Activation::requestedActivation() const -> RequestedActivations
{
    return _requestedActivation;
}

int Activation::_callback_get_RequestedActivation(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Activation*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->requestedActivation()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Activation::requestedActivation(RequestedActivations value,
                                     bool skipSignal) -> RequestedActivations
{
    if (_requestedActivation != value)
    {
        _requestedActivation = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Software_Activation_interface.property_changed(
                "RequestedActivation");
        }
    }

    return _requestedActivation;
}

auto Activation::requestedActivation(RequestedActivations val)
    -> RequestedActivations
{
    return requestedActivation(val, false);
}
int Activation::_callback_set_RequestedActivation(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Activation*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->requestedActivation(convertRequestedActivationsFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Activation
{
static const auto _property_RequestedActivation =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Activation::setPropertyByName(const std::string& _name,
                                   const PropertiesVariant& val,
                                   bool skipSignal)
{
    if (_name == "Activation")
    {
        auto& v = std::get<Activations>(val);
        activation(v, skipSignal);
        return;
    }
    if (_name == "RequestedActivation")
    {
        auto& v = std::get<RequestedActivations>(val);
        requestedActivation(v, skipSignal);
        return;
    }
}

auto Activation::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "Activation")
    {
        return activation();
    }
    if (_name == "RequestedActivation")
    {
        return requestedActivation();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Activation::Activations */
static const std::tuple<const char*, Activation::Activations>
    mappingActivationActivations[] = {
        std::make_tuple(
            "xyz.openbmc_project.Software.Activation.Activations.NotReady",
            Activation::Activations::NotReady),
        std::make_tuple(
            "xyz.openbmc_project.Software.Activation.Activations.Invalid",
            Activation::Activations::Invalid),
        std::make_tuple(
            "xyz.openbmc_project.Software.Activation.Activations.Ready",
            Activation::Activations::Ready),
        std::make_tuple(
            "xyz.openbmc_project.Software.Activation.Activations.Activating",
            Activation::Activations::Activating),
        std::make_tuple(
            "xyz.openbmc_project.Software.Activation.Activations.Active",
            Activation::Activations::Active),
        std::make_tuple(
            "xyz.openbmc_project.Software.Activation.Activations.Failed",
            Activation::Activations::Failed),
};

} // anonymous namespace

auto Activation::convertActivationsFromString(const std::string& s)
    -> Activations
{
    auto i =
        std::find_if(std::begin(mappingActivationActivations),
                     std::end(mappingActivationActivations), [&s](auto& e) {
                         return 0 == strcmp(s.c_str(), std::get<0>(e));
                     });
    if (std::end(mappingActivationActivations) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Activation::Activations v)
{
    auto i = std::find_if(std::begin(mappingActivationActivations),
                          std::end(mappingActivationActivations),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingActivationActivations))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Activation::RequestedActivations */
static const std::tuple<const char*, Activation::RequestedActivations>
    mappingActivationRequestedActivations[] = {
        std::make_tuple(
            "xyz.openbmc_project.Software.Activation.RequestedActivations.None",
            Activation::RequestedActivations::None),
        std::make_tuple("xyz.openbmc_project.Software.Activation."
                        "RequestedActivations.Active",
                        Activation::RequestedActivations::Active),
};

} // anonymous namespace

auto Activation::convertRequestedActivationsFromString(const std::string& s)
    -> RequestedActivations
{
    auto i = std::find_if(
        std::begin(mappingActivationRequestedActivations),
        std::end(mappingActivationRequestedActivations),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingActivationRequestedActivations) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Activation::RequestedActivations v)
{
    auto i = std::find_if(std::begin(mappingActivationRequestedActivations),
                          std::end(mappingActivationRequestedActivations),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingActivationRequestedActivations))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Activation::_vtable[] = {
    vtable::start(),
    vtable::property("Activation",
                     details::Activation::_property_Activation.data(),
                     _callback_get_Activation, _callback_set_Activation,
                     vtable::property_::emits_change),
    vtable::property("RequestedActivation",
                     details::Activation::_property_RequestedActivation.data(),
                     _callback_get_RequestedActivation,
                     _callback_set_RequestedActivation,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Collection/DeleteAll/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Collection
{
namespace server
{

DeleteAll::DeleteAll(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Collection_DeleteAll_interface(bus, path, _interface,
                                                        _vtable, this),
    _intf(bus.getInterface())
{
}

int DeleteAll::_callback_DeleteAll(sd_bus_message* msg, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<DeleteAll*>(context);
        o->deleteAll();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace DeleteAll
{
static const auto _param_DeleteAll =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_DeleteAll =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace DeleteAll
} // namespace details

const vtable::vtable_t DeleteAll::_vtable[] = {
    vtable::start(),

    vtable::method("DeleteAll", details::DeleteAll::_param_DeleteAll.data(),
                   details::DeleteAll::_return_DeleteAll.data(),
                   _callback_DeleteAll),
    vtable::end()};

} // namespace server
} // namespace Collection
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Logging/Event/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Logging
{
namespace server
{

Event::Event(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Logging_Event_interface(bus, path, _interface, _vtable,
                                                 this),
    _intf(bus.getInterface())
{
}

Event::Event(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Event(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Event::timestamp() const -> uint64_t
{
    return _timestamp;
}

int Event::_callback_get_Timestamp(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Event*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->timestamp()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Event::timestamp(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_timestamp != value)
    {
        _timestamp = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Event_interface.property_changed(
                "Timestamp");
        }
    }

    return _timestamp;
}

auto Event::timestamp(uint64_t val) -> uint64_t
{
    return timestamp(val, false);
}
int Event::_callback_set_Timestamp(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Event*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->timestamp(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Event
{
static const auto _property_Timestamp =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

auto Event::message() const -> std::string
{
    return _message;
}

int Event::_callback_get_Message(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Event*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->message()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Event::message(std::string value, bool skipSignal) -> std::string
{
    if (_message != value)
    {
        _message = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Event_interface.property_changed(
                "Message");
        }
    }

    return _message;
}

auto Event::message(std::string val) -> std::string
{
    return message(val, false);
}
int Event::_callback_set_Message(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<Event*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->message(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Event
{
static const auto _property_Message =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Event::additionalData() const -> std::vector<std::string>
{
    return _additionalData;
}

int Event::_callback_get_AdditionalData(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Event*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->additionalData()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Event::additionalData(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_additionalData != value)
    {
        _additionalData = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Event_interface.property_changed(
                "AdditionalData");
        }
    }

    return _additionalData;
}

auto Event::additionalData(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return additionalData(val, false);
}
int Event::_callback_set_AdditionalData(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Event*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->additionalData(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Event
{
static const auto _property_AdditionalData = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

void Event::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Timestamp")
    {
        auto& v = std::get<uint64_t>(val);
        timestamp(v, skipSignal);
        return;
    }
    if (_name == "Message")
    {
        auto& v = std::get<std::string>(val);
        message(v, skipSignal);
        return;
    }
    if (_name == "AdditionalData")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        additionalData(v, skipSignal);
        return;
    }
}

auto Event::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Timestamp")
    {
        return timestamp();
    }
    if (_name == "Message")
    {
        return message();
    }
    if (_name == "AdditionalData")
    {
        return additionalData();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Event::_vtable[] = {
    vtable::start(),
    vtable::property("Timestamp", details::Event::_property_Timestamp.data(),
                     _callback_get_Timestamp, _callback_set_Timestamp,
                     vtable::property_::emits_change),
    vtable::property("Message", details::Event::_property_Message.data(),
                     _callback_get_Message, _callback_set_Message,
                     vtable::property_::emits_change),
    vtable::property("AdditionalData",
                     details::Event::_property_AdditionalData.data(),
                     _callback_get_AdditionalData, _callback_set_AdditionalData,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Logging
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Logging/Create/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Logging
{
namespace server
{

Create::Create(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Logging_Create_interface(bus, path, _interface,
                                                  _vtable, this),
    _intf(bus.getInterface())
{
}

int Create::_callback_Create(sd_bus_message* msg, void* context,
                             sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string message{};
        std::string severity{};
        std::map<std::string, std::string> additionalData{};

        m.read(message, severity, additionalData);

        auto o = static_cast<Create*>(context);
        o->create(message,
                  xyz::openbmc_project::Logging::server::Entry::
                      convertLevelFromString(severity),
                  additionalData);

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Create
{
static const auto _param_Create = utility::tuple_to_array(
    message::types::type_id<std::string, std::string,
                            std::map<std::string, std::string>>());
static const auto _return_Create =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Create
} // namespace details

const vtable::vtable_t Create::_vtable[] = {
    vtable::start(),

    vtable::method("Create", details::Create::_param_Create.data(),
                   details::Create::_return_Create.data(), _callback_Create),
    vtable::end()};

} // namespace server
} // namespace Logging
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Logging/IPMI/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Logging
{
namespace server
{

IPMI::IPMI(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Logging_IPMI_interface(bus, path, _interface, _vtable,
                                                this),
    _intf(bus.getInterface())
{
}

int IPMI::_callback_IpmiSelAdd(sd_bus_message* msg, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string message{};
        sdbusplus::message::object_path path{};
        std::vector<uint8_t> sELData{};
        bool assert{};
        uint16_t generatorID{};

        m.read(message, path, sELData, assert, generatorID);

        auto o = static_cast<IPMI*>(context);
        auto r = o->ipmiSelAdd(message, path, sELData, assert, generatorID);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace IPMI
{
static const auto _param_IpmiSelAdd = utility::tuple_to_array(
    message::types::type_id<std::string, sdbusplus::message::object_path,
                            std::vector<uint8_t>, bool, uint16_t>());
static const auto _return_IpmiSelAdd =
    utility::tuple_to_array(message::types::type_id<uint16_t>());
} // namespace IPMI
} // namespace details

int IPMI::_callback_IpmiSelAddOem(sd_bus_message* msg, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string message{};
        std::vector<uint8_t> sELData{};
        uint8_t recordType{};

        m.read(message, sELData, recordType);

        auto o = static_cast<IPMI*>(context);
        auto r = o->ipmiSelAddOem(message, sELData, recordType);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace IPMI
{
static const auto _param_IpmiSelAddOem = utility::tuple_to_array(
    message::types::type_id<std::string, std::vector<uint8_t>, uint8_t>());
static const auto _return_IpmiSelAddOem =
    utility::tuple_to_array(message::types::type_id<uint16_t>());
} // namespace IPMI
} // namespace details

const vtable::vtable_t IPMI::_vtable[] = {
    vtable::start(),

    vtable::method("IpmiSelAdd", details::IPMI::_param_IpmiSelAdd.data(),
                   details::IPMI::_return_IpmiSelAdd.data(),
                   _callback_IpmiSelAdd),

    vtable::method("IpmiSelAddOem", details::IPMI::_param_IpmiSelAddOem.data(),
                   details::IPMI::_return_IpmiSelAddOem.data(),
                   _callback_IpmiSelAddOem),
    vtable::end()};

} // namespace server
} // namespace Logging
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Logging/Entry/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Logging
{
namespace server
{

Entry::Entry(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Logging_Entry_interface(bus, path, _interface, _vtable,
                                                 this),
    _intf(bus.getInterface())
{
}

Entry::Entry(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Entry(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Entry::id() const -> uint32_t
{
    return _id;
}

int Entry::_callback_get_Id(sd_bus* bus, const char* path,
                            const char* interface, const char* property,
                            sd_bus_message* reply, void* context,
                            sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->id()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Entry::id(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_id != value)
    {
        _id = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Entry_interface.property_changed("Id");
        }
    }

    return _id;
}

auto Entry::id(uint32_t val) -> uint32_t
{
    return id(val, false);
}
int Entry::_callback_set_Id(sd_bus* bus, const char* path,
                            const char* interface, const char* property,
                            sd_bus_message* value, void* context,
                            sd_bus_error* error)
{
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->id(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Entry
{
static const auto _property_Id =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto Entry::timestamp() const -> uint64_t
{
    return _timestamp;
}

int Entry::_callback_get_Timestamp(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->timestamp()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Entry::timestamp(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_timestamp != value)
    {
        _timestamp = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Entry_interface.property_changed(
                "Timestamp");
        }
    }

    return _timestamp;
}

auto Entry::timestamp(uint64_t val) -> uint64_t
{
    return timestamp(val, false);
}
int Entry::_callback_set_Timestamp(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->timestamp(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Entry
{
static const auto _property_Timestamp =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

auto Entry::severity() const -> Level
{
    return _severity;
}

int Entry::_callback_get_Severity(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->severity()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Entry::severity(Level value, bool skipSignal) -> Level
{
    if (_severity != value)
    {
        _severity = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Entry_interface.property_changed(
                "Severity");
        }
    }

    return _severity;
}

auto Entry::severity(Level val) -> Level
{
    return severity(val, false);
}
int Entry::_callback_set_Severity(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->severity(convertLevelFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Entry
{
static const auto _property_Severity =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Entry::message() const -> std::string
{
    return _message;
}

int Entry::_callback_get_Message(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->message()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Entry::message(std::string value, bool skipSignal) -> std::string
{
    if (_message != value)
    {
        _message = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Entry_interface.property_changed(
                "Message");
        }
    }

    return _message;
}

auto Entry::message(std::string val) -> std::string
{
    return message(val, false);
}
int Entry::_callback_set_Message(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->message(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Entry
{
static const auto _property_Message =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Entry::additionalData() const -> std::vector<std::string>
{
    return _additionalData;
}

int Entry::_callback_get_AdditionalData(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->additionalData()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Entry::additionalData(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_additionalData != value)
    {
        _additionalData = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Entry_interface.property_changed(
                "AdditionalData");
        }
    }

    return _additionalData;
}

auto Entry::additionalData(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return additionalData(val, false);
}
int Entry::_callback_set_AdditionalData(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->additionalData(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Entry
{
static const auto _property_AdditionalData = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto Entry::resolved() const -> bool
{
    return _resolved;
}

int Entry::_callback_get_Resolved(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->resolved()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Entry::resolved(bool value, bool skipSignal) -> bool
{
    if (_resolved != value)
    {
        _resolved = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Logging_Entry_interface.property_changed(
                "Resolved");
        }
    }

    return _resolved;
}

auto Entry::resolved(bool val) -> bool
{
    return resolved(val, false);
}
int Entry::_callback_set_Resolved(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->resolved(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Entry
{
static const auto _property_Resolved =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Entry::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Id")
    {
        auto& v = std::get<uint32_t>(val);
        id(v, skipSignal);
        return;
    }
    if (_name == "Timestamp")
    {
        auto& v = std::get<uint64_t>(val);
        timestamp(v, skipSignal);
        return;
    }
    if (_name == "Severity")
    {
        auto& v = std::get<Level>(val);
        severity(v, skipSignal);
        return;
    }
    if (_name == "Message")
    {
        auto& v = std::get<std::string>(val);
        message(v, skipSignal);
        return;
    }
    if (_name == "AdditionalData")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        additionalData(v, skipSignal);
        return;
    }
    if (_name == "Resolved")
    {
        auto& v = std::get<bool>(val);
        resolved(v, skipSignal);
        return;
    }
}

auto Entry::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Id")
    {
        return id();
    }
    if (_name == "Timestamp")
    {
        return timestamp();
    }
    if (_name == "Severity")
    {
        return severity();
    }
    if (_name == "Message")
    {
        return message();
    }
    if (_name == "AdditionalData")
    {
        return additionalData();
    }
    if (_name == "Resolved")
    {
        return resolved();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Entry::Level */
static const std::tuple<const char*, Entry::Level> mappingEntryLevel[] = {
    std::make_tuple("xyz.openbmc_project.Logging.Entry.Level.Emergency",
                    Entry::Level::Emergency),
    std::make_tuple("xyz.openbmc_project.Logging.Entry.Level.Alert",
                    Entry::Level::Alert),
    std::make_tuple("xyz.openbmc_project.Logging.Entry.Level.Critical",
                    Entry::Level::Critical),
    std::make_tuple("xyz.openbmc_project.Logging.Entry.Level.Error",
                    Entry::Level::Error),
    std::make_tuple("xyz.openbmc_project.Logging.Entry.Level.Warning",
                    Entry::Level::Warning),
    std::make_tuple("xyz.openbmc_project.Logging.Entry.Level.Notice",
                    Entry::Level::Notice),
    std::make_tuple("xyz.openbmc_project.Logging.Entry.Level.Informational",
                    Entry::Level::Informational),
    std::make_tuple("xyz.openbmc_project.Logging.Entry.Level.Debug",
                    Entry::Level::Debug),
};

} // anonymous namespace

auto Entry::convertLevelFromString(const std::string& s) -> Level
{
    auto i = std::find_if(
        std::begin(mappingEntryLevel), std::end(mappingEntryLevel),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingEntryLevel) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Entry::Level v)
{
    auto i =
        std::find_if(std::begin(mappingEntryLevel), std::end(mappingEntryLevel),
                     [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingEntryLevel))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Entry::_vtable[] = {
    vtable::start(),
    vtable::property("Id", details::Entry::_property_Id.data(),
                     _callback_get_Id, _callback_set_Id,
                     vtable::property_::emits_change),
    vtable::property("Timestamp", details::Entry::_property_Timestamp.data(),
                     _callback_get_Timestamp, _callback_set_Timestamp,
                     vtable::property_::emits_change),
    vtable::property("Severity", details::Entry::_property_Severity.data(),
                     _callback_get_Severity, _callback_set_Severity,
                     vtable::property_::emits_change),
    vtable::property("Message", details::Entry::_property_Message.data(),
                     _callback_get_Message, _callback_set_Message,
                     vtable::property_::emits_change),
    vtable::property("AdditionalData",
                     details::Entry::_property_AdditionalData.data(),
                     _callback_get_AdditionalData, _callback_set_AdditionalData,
                     vtable::property_::emits_change),
    vtable::property("Resolved", details::Entry::_property_Resolved.data(),
                     _callback_get_Resolved, _callback_set_Resolved,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Logging
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Network/IP/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace server
{

IP::IP(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_IP_interface(bus, path, _interface, _vtable,
                                              this),
    _intf(bus.getInterface())
{
}

IP::IP(bus::bus& bus, const char* path,
       const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    IP(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto IP::address() const -> std::string
{
    return _address;
}

int IP::_callback_get_Address(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* reply, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->address()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto IP::address(std::string value, bool skipSignal) -> std::string
{
    if (_address != value)
    {
        _address = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_IP_interface.property_changed(
                "Address");
        }
    }

    return _address;
}

auto IP::address(std::string val) -> std::string
{
    return address(val, false);
}
int IP::_callback_set_Address(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* value, void* context,
                              sd_bus_error* error)
{
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->address(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace IP
{
static const auto _property_Address =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto IP::prefixLength() const -> uint8_t
{
    return _prefixLength;
}

int IP::_callback_get_PrefixLength(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->prefixLength()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto IP::prefixLength(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_prefixLength != value)
    {
        _prefixLength = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_IP_interface.property_changed(
                "PrefixLength");
        }
    }

    return _prefixLength;
}

auto IP::prefixLength(uint8_t val) -> uint8_t
{
    return prefixLength(val, false);
}
int IP::_callback_set_PrefixLength(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->prefixLength(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace IP
{
static const auto _property_PrefixLength =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto IP::origin() const -> AddressOrigin
{
    return _origin;
}

int IP::_callback_get_Origin(sd_bus* bus, const char* path,
                             const char* interface, const char* property,
                             sd_bus_message* reply, void* context,
                             sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->origin()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto IP::origin(AddressOrigin value, bool skipSignal) -> AddressOrigin
{
    if (_origin != value)
    {
        _origin = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_IP_interface.property_changed(
                "Origin");
        }
    }

    return _origin;
}

auto IP::origin(AddressOrigin val) -> AddressOrigin
{
    return origin(val, false);
}
int IP::_callback_set_Origin(sd_bus* bus, const char* path,
                             const char* interface, const char* property,
                             sd_bus_message* value, void* context,
                             sd_bus_error* error)
{
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->origin(convertAddressOriginFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace IP
{
static const auto _property_Origin =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto IP::gateway() const -> std::string
{
    return _gateway;
}

int IP::_callback_get_Gateway(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* reply, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->gateway()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto IP::gateway(std::string value, bool skipSignal) -> std::string
{
    if (_gateway != value)
    {
        _gateway = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_IP_interface.property_changed(
                "Gateway");
        }
    }

    return _gateway;
}

auto IP::gateway(std::string val) -> std::string
{
    return gateway(val, false);
}
int IP::_callback_set_Gateway(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* value, void* context,
                              sd_bus_error* error)
{
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->gateway(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace IP
{
static const auto _property_Gateway =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto IP::type() const -> Protocol
{
    return _type;
}

int IP::_callback_get_Type(sd_bus* bus, const char* path, const char* interface,
                           const char* property, sd_bus_message* reply,
                           void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->type()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto IP::type(Protocol value, bool skipSignal) -> Protocol
{
    if (_type != value)
    {
        _type = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_IP_interface.property_changed("Type");
        }
    }

    return _type;
}

auto IP::type(Protocol val) -> Protocol
{
    return type(val, false);
}
int IP::_callback_set_Type(sd_bus* bus, const char* path, const char* interface,
                           const char* property, sd_bus_message* value,
                           void* context, sd_bus_error* error)
{
    auto o = static_cast<IP*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->type(convertProtocolFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace IP
{
static const auto _property_Type =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void IP::setPropertyByName(const std::string& _name,
                           const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Address")
    {
        auto& v = std::get<std::string>(val);
        address(v, skipSignal);
        return;
    }
    if (_name == "PrefixLength")
    {
        auto& v = std::get<uint8_t>(val);
        prefixLength(v, skipSignal);
        return;
    }
    if (_name == "Origin")
    {
        auto& v = std::get<AddressOrigin>(val);
        origin(v, skipSignal);
        return;
    }
    if (_name == "Gateway")
    {
        auto& v = std::get<std::string>(val);
        gateway(v, skipSignal);
        return;
    }
    if (_name == "Type")
    {
        auto& v = std::get<Protocol>(val);
        type(v, skipSignal);
        return;
    }
}

auto IP::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Address")
    {
        return address();
    }
    if (_name == "PrefixLength")
    {
        return prefixLength();
    }
    if (_name == "Origin")
    {
        return origin();
    }
    if (_name == "Gateway")
    {
        return gateway();
    }
    if (_name == "Type")
    {
        return type();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for IP::Protocol */
static const std::tuple<const char*, IP::Protocol> mappingIPProtocol[] = {
    std::make_tuple("xyz.openbmc_project.Network.IP.Protocol.IPv4",
                    IP::Protocol::IPv4),
    std::make_tuple("xyz.openbmc_project.Network.IP.Protocol.IPv6",
                    IP::Protocol::IPv6),
};

} // anonymous namespace

auto IP::convertProtocolFromString(const std::string& s) -> Protocol
{
    auto i = std::find_if(
        std::begin(mappingIPProtocol), std::end(mappingIPProtocol),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingIPProtocol) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(IP::Protocol v)
{
    auto i =
        std::find_if(std::begin(mappingIPProtocol), std::end(mappingIPProtocol),
                     [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingIPProtocol))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for IP::AddressOrigin */
static const std::tuple<const char*, IP::AddressOrigin>
    mappingIPAddressOrigin[] = {
        std::make_tuple("xyz.openbmc_project.Network.IP.AddressOrigin.Static",
                        IP::AddressOrigin::Static),
        std::make_tuple("xyz.openbmc_project.Network.IP.AddressOrigin.DHCP",
                        IP::AddressOrigin::DHCP),
        std::make_tuple(
            "xyz.openbmc_project.Network.IP.AddressOrigin.LinkLocal",
            IP::AddressOrigin::LinkLocal),
        std::make_tuple("xyz.openbmc_project.Network.IP.AddressOrigin.SLAAC",
                        IP::AddressOrigin::SLAAC),
};

} // anonymous namespace

auto IP::convertAddressOriginFromString(const std::string& s) -> AddressOrigin
{
    auto i = std::find_if(
        std::begin(mappingIPAddressOrigin), std::end(mappingIPAddressOrigin),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingIPAddressOrigin) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(IP::AddressOrigin v)
{
    auto i = std::find_if(std::begin(mappingIPAddressOrigin),
                          std::end(mappingIPAddressOrigin),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingIPAddressOrigin))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t IP::_vtable[] = {
    vtable::start(),
    vtable::property("Address", details::IP::_property_Address.data(),
                     _callback_get_Address, _callback_set_Address,
                     vtable::property_::emits_change),
    vtable::property("PrefixLength", details::IP::_property_PrefixLength.data(),
                     _callback_get_PrefixLength, _callback_set_PrefixLength,
                     vtable::property_::emits_change),
    vtable::property("Origin", details::IP::_property_Origin.data(),
                     _callback_get_Origin, _callback_set_Origin,
                     vtable::property_::emits_change),
    vtable::property("Gateway", details::IP::_property_Gateway.data(),
                     _callback_get_Gateway, _callback_set_Gateway,
                     vtable::property_::emits_change),
    vtable::property("Type", details::IP::_property_Type.data(),
                     _callback_get_Type, _callback_set_Type,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Network/Neighbor/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace server
{

Neighbor::Neighbor(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_Neighbor_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

Neighbor::Neighbor(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    Neighbor(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Neighbor::iPAddress() const -> std::string
{
    return _iPAddress;
}

int Neighbor::_callback_get_IPAddress(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Neighbor*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->iPAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Neighbor::iPAddress(std::string value, bool skipSignal) -> std::string
{
    if (_iPAddress != value)
    {
        _iPAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Neighbor_interface.property_changed(
                "IPAddress");
        }
    }

    return _iPAddress;
}

auto Neighbor::iPAddress(std::string val) -> std::string
{
    return iPAddress(val, false);
}
int Neighbor::_callback_set_IPAddress(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Neighbor*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->iPAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Neighbor
{
static const auto _property_IPAddress =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Neighbor::mACAddress() const -> std::string
{
    return _mACAddress;
}

int Neighbor::_callback_get_MACAddress(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* reply, void* context,
                                       sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Neighbor*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->mACAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Neighbor::mACAddress(std::string value, bool skipSignal) -> std::string
{
    if (_mACAddress != value)
    {
        _mACAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Neighbor_interface.property_changed(
                "MACAddress");
        }
    }

    return _mACAddress;
}

auto Neighbor::mACAddress(std::string val) -> std::string
{
    return mACAddress(val, false);
}
int Neighbor::_callback_set_MACAddress(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* value, void* context,
                                       sd_bus_error* error)
{
    auto o = static_cast<Neighbor*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->mACAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Neighbor
{
static const auto _property_MACAddress =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Neighbor::state() const -> State
{
    return _state;
}

int Neighbor::_callback_get_State(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Neighbor*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->state()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Neighbor::state(State value, bool skipSignal) -> State
{
    if (_state != value)
    {
        _state = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Neighbor_interface.property_changed(
                "State");
        }
    }

    return _state;
}

auto Neighbor::state(State val) -> State
{
    return state(val, false);
}
int Neighbor::_callback_set_State(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Neighbor*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->state(convertStateFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Neighbor
{
static const auto _property_State =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Neighbor::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "IPAddress")
    {
        auto& v = std::get<std::string>(val);
        iPAddress(v, skipSignal);
        return;
    }
    if (_name == "MACAddress")
    {
        auto& v = std::get<std::string>(val);
        mACAddress(v, skipSignal);
        return;
    }
    if (_name == "State")
    {
        auto& v = std::get<State>(val);
        state(v, skipSignal);
        return;
    }
}

auto Neighbor::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "IPAddress")
    {
        return iPAddress();
    }
    if (_name == "MACAddress")
    {
        return mACAddress();
    }
    if (_name == "State")
    {
        return state();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Neighbor::State */
static const std::tuple<const char*, Neighbor::State> mappingNeighborState[] = {
    std::make_tuple("xyz.openbmc_project.Network.Neighbor.State.Incomplete",
                    Neighbor::State::Incomplete),
    std::make_tuple("xyz.openbmc_project.Network.Neighbor.State.Reachable",
                    Neighbor::State::Reachable),
    std::make_tuple("xyz.openbmc_project.Network.Neighbor.State.Stale",
                    Neighbor::State::Stale),
    std::make_tuple("xyz.openbmc_project.Network.Neighbor.State.Invalid",
                    Neighbor::State::Invalid),
    std::make_tuple("xyz.openbmc_project.Network.Neighbor.State.Permanent",
                    Neighbor::State::Permanent),
};

} // anonymous namespace

auto Neighbor::convertStateFromString(const std::string& s) -> State
{
    auto i = std::find_if(
        std::begin(mappingNeighborState), std::end(mappingNeighborState),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingNeighborState) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Neighbor::State v)
{
    auto i = std::find_if(std::begin(mappingNeighborState),
                          std::end(mappingNeighborState),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingNeighborState))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Neighbor::_vtable[] = {
    vtable::start(),
    vtable::property("IPAddress", details::Neighbor::_property_IPAddress.data(),
                     _callback_get_IPAddress, _callback_set_IPAddress,
                     vtable::property_::emits_change),
    vtable::property("MACAddress",
                     details::Neighbor::_property_MACAddress.data(),
                     _callback_get_MACAddress, _callback_set_MACAddress,
                     vtable::property_::emits_change),
    vtable::property("State", details::Neighbor::_property_State.data(),
                     _callback_get_State, _callback_set_State,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Network/Experimental/Bond/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace Experimental
{
namespace server
{

Bond::Bond(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_Experimental_Bond_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Bond::Bond(bus::bus& bus, const char* path,
           const std::map<std::string, PropertiesVariant>& vals,
           bool skipSignal) :
    Bond(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Bond::interfaceName() const -> std::string
{
    return _interfaceName;
}

int Bond::_callback_get_InterfaceName(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Bond*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->interfaceName()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Bond::interfaceName(std::string value, bool skipSignal) -> std::string
{
    if (_interfaceName != value)
    {
        _interfaceName = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Bond_interface
                .property_changed("InterfaceName");
        }
    }

    return _interfaceName;
}

auto Bond::interfaceName(std::string val) -> std::string
{
    return interfaceName(val, false);
}
int Bond::_callback_set_InterfaceName(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Bond*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->interfaceName(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Bond
{
static const auto _property_InterfaceName =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Bond::bondedInterfaces() const -> std::vector<std::string>
{
    return _bondedInterfaces;
}

int Bond::_callback_get_BondedInterfaces(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Bond*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->bondedInterfaces()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Bond::bondedInterfaces(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_bondedInterfaces != value)
    {
        _bondedInterfaces = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Bond_interface
                .property_changed("BondedInterfaces");
        }
    }

    return _bondedInterfaces;
}

auto Bond::bondedInterfaces(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return bondedInterfaces(val, false);
}
int Bond::_callback_set_BondedInterfaces(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Bond*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->bondedInterfaces(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Bond
{
static const auto _property_BondedInterfaces = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto Bond::mode() const -> BondingMode
{
    return _mode;
}

int Bond::_callback_get_Mode(sd_bus* bus, const char* path,
                             const char* interface, const char* property,
                             sd_bus_message* reply, void* context,
                             sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Bond*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->mode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Bond::mode(BondingMode value, bool skipSignal) -> BondingMode
{
    if (_mode != value)
    {
        _mode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Bond_interface
                .property_changed("Mode");
        }
    }

    return _mode;
}

auto Bond::mode(BondingMode val) -> BondingMode
{
    return mode(val, false);
}
int Bond::_callback_set_Mode(sd_bus* bus, const char* path,
                             const char* interface, const char* property,
                             sd_bus_message* value, void* context,
                             sd_bus_error* error)
{
    auto o = static_cast<Bond*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->mode(convertBondingModeFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Bond
{
static const auto _property_Mode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Bond::transmitHashPolicy() const -> HashPolicy
{
    return _transmitHashPolicy;
}

int Bond::_callback_get_TransmitHashPolicy(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Bond*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->transmitHashPolicy()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Bond::transmitHashPolicy(HashPolicy value, bool skipSignal) -> HashPolicy
{
    if (_transmitHashPolicy != value)
    {
        _transmitHashPolicy = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Bond_interface
                .property_changed("TransmitHashPolicy");
        }
    }

    return _transmitHashPolicy;
}

auto Bond::transmitHashPolicy(HashPolicy val) -> HashPolicy
{
    return transmitHashPolicy(val, false);
}
int Bond::_callback_set_TransmitHashPolicy(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<Bond*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->transmitHashPolicy(convertHashPolicyFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Bond
{
static const auto _property_TransmitHashPolicy =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Bond::setPropertyByName(const std::string& _name,
                             const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "InterfaceName")
    {
        auto& v = std::get<std::string>(val);
        interfaceName(v, skipSignal);
        return;
    }
    if (_name == "BondedInterfaces")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        bondedInterfaces(v, skipSignal);
        return;
    }
    if (_name == "Mode")
    {
        auto& v = std::get<BondingMode>(val);
        mode(v, skipSignal);
        return;
    }
    if (_name == "TransmitHashPolicy")
    {
        auto& v = std::get<HashPolicy>(val);
        transmitHashPolicy(v, skipSignal);
        return;
    }
}

auto Bond::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "InterfaceName")
    {
        return interfaceName();
    }
    if (_name == "BondedInterfaces")
    {
        return bondedInterfaces();
    }
    if (_name == "Mode")
    {
        return mode();
    }
    if (_name == "TransmitHashPolicy")
    {
        return transmitHashPolicy();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Bond::BondingMode */
static const std::tuple<const char*, Bond::BondingMode>
    mappingBondBondingMode[] = {
        std::make_tuple("xyz.openbmc_project.Network.Experimental.Bond."
                        "BondingMode.RoundRobin",
                        Bond::BondingMode::RoundRobin),
        std::make_tuple("xyz.openbmc_project.Network.Experimental.Bond."
                        "BondingMode.ActiveBackup",
                        Bond::BondingMode::ActiveBackup),
        std::make_tuple(
            "xyz.openbmc_project.Network.Experimental.Bond.BondingMode.XOR",
            Bond::BondingMode::XOR),
        std::make_tuple("xyz.openbmc_project.Network.Experimental.Bond."
                        "BondingMode.Broadcast",
                        Bond::BondingMode::Broadcast),
        std::make_tuple(
            "xyz.openbmc_project.Network.Experimental.Bond.BondingMode.Dynamic",
            Bond::BondingMode::Dynamic),
        std::make_tuple(
            "xyz.openbmc_project.Network.Experimental.Bond.BondingMode.TLB",
            Bond::BondingMode::TLB),
        std::make_tuple(
            "xyz.openbmc_project.Network.Experimental.Bond.BondingMode.ALB",
            Bond::BondingMode::ALB),
};

} // anonymous namespace

auto Bond::convertBondingModeFromString(const std::string& s) -> BondingMode
{
    auto i = std::find_if(
        std::begin(mappingBondBondingMode), std::end(mappingBondBondingMode),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingBondBondingMode) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Bond::BondingMode v)
{
    auto i = std::find_if(std::begin(mappingBondBondingMode),
                          std::end(mappingBondBondingMode),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingBondBondingMode))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Bond::HashPolicy */
static const std::tuple<const char*, Bond::HashPolicy> mappingBondHashPolicy[] =
    {
        std::make_tuple(
            "xyz.openbmc_project.Network.Experimental.Bond.HashPolicy.Layer2",
            Bond::HashPolicy::Layer2),
        std::make_tuple("xyz.openbmc_project.Network.Experimental.Bond."
                        "HashPolicy.Layer2Plus3",
                        Bond::HashPolicy::Layer2Plus3),
        std::make_tuple("xyz.openbmc_project.Network.Experimental.Bond."
                        "HashPolicy.Layer3Plus4",
                        Bond::HashPolicy::Layer3Plus4),
        std::make_tuple("xyz.openbmc_project.Network.Experimental.Bond."
                        "HashPolicy.Encap2Plus3",
                        Bond::HashPolicy::Encap2Plus3),
        std::make_tuple("xyz.openbmc_project.Network.Experimental.Bond."
                        "HashPolicy.Encap3Plus4",
                        Bond::HashPolicy::Encap3Plus4),
};

} // anonymous namespace

auto Bond::convertHashPolicyFromString(const std::string& s) -> HashPolicy
{
    auto i = std::find_if(
        std::begin(mappingBondHashPolicy), std::end(mappingBondHashPolicy),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingBondHashPolicy) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Bond::HashPolicy v)
{
    auto i = std::find_if(std::begin(mappingBondHashPolicy),
                          std::end(mappingBondHashPolicy),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingBondHashPolicy))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Bond::_vtable[] = {
    vtable::start(),
    vtable::property("InterfaceName",
                     details::Bond::_property_InterfaceName.data(),
                     _callback_get_InterfaceName, _callback_set_InterfaceName,
                     vtable::property_::emits_change),
    vtable::property(
        "BondedInterfaces", details::Bond::_property_BondedInterfaces.data(),
        _callback_get_BondedInterfaces, _callback_set_BondedInterfaces,
        vtable::property_::emits_change),
    vtable::property("Mode", details::Bond::_property_Mode.data(),
                     _callback_get_Mode, _callback_set_Mode,
                     vtable::property_::emits_change),
    vtable::property("TransmitHashPolicy",
                     details::Bond::_property_TransmitHashPolicy.data(),
                     _callback_get_TransmitHashPolicy,
                     _callback_set_TransmitHashPolicy,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Experimental
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Network/Experimental/Tunnel/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace Experimental
{
namespace server
{

Tunnel::Tunnel(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_Experimental_Tunnel_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Tunnel::Tunnel(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    Tunnel(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Tunnel::interfaceName() const -> std::string
{
    return _interfaceName;
}

int Tunnel::_callback_get_InterfaceName(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->interfaceName()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::interfaceName(std::string value, bool skipSignal) -> std::string
{
    if (_interfaceName != value)
    {
        _interfaceName = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("InterfaceName");
        }
    }

    return _interfaceName;
}

auto Tunnel::interfaceName(std::string val) -> std::string
{
    return interfaceName(val, false);
}
int Tunnel::_callback_set_InterfaceName(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->interfaceName(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_InterfaceName =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Tunnel::local() const -> std::string
{
    return _local;
}

int Tunnel::_callback_get_Local(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* reply, void* context,
                                sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->local()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::local(std::string value, bool skipSignal) -> std::string
{
    if (_local != value)
    {
        _local = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("Local");
        }
    }

    return _local;
}

auto Tunnel::local(std::string val) -> std::string
{
    return local(val, false);
}
int Tunnel::_callback_set_Local(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* value, void* context,
                                sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->local(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_Local =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Tunnel::remote() const -> std::string
{
    return _remote;
}

int Tunnel::_callback_get_Remote(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->remote()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::remote(std::string value, bool skipSignal) -> std::string
{
    if (_remote != value)
    {
        _remote = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("Remote");
        }
    }

    return _remote;
}

auto Tunnel::remote(std::string val) -> std::string
{
    return remote(val, false);
}
int Tunnel::_callback_set_Remote(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->remote(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_Remote =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Tunnel::tOS() const -> uint32_t
{
    return _tOS;
}

int Tunnel::_callback_get_TOS(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* reply, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->tOS()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::tOS(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_tOS != value)
    {
        _tOS = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("TOS");
        }
    }

    return _tOS;
}

auto Tunnel::tOS(uint32_t val) -> uint32_t
{
    return tOS(val, false);
}
int Tunnel::_callback_set_TOS(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* value, void* context,
                              sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->tOS(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_TOS =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto Tunnel::tTL() const -> uint32_t
{
    return _tTL;
}

int Tunnel::_callback_get_TTL(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* reply, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->tTL()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::tTL(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_tTL != value)
    {
        _tTL = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("TTL");
        }
    }

    return _tTL;
}

auto Tunnel::tTL(uint32_t val) -> uint32_t
{
    return tTL(val, false);
}
int Tunnel::_callback_set_TTL(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* value, void* context,
                              sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->tTL(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_TTL =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto Tunnel::discoverPathMTU() const -> bool
{
    return _discoverPathMTU;
}

int Tunnel::_callback_get_DiscoverPathMTU(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* reply, void* context,
                                          sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->discoverPathMTU()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::discoverPathMTU(bool value, bool skipSignal) -> bool
{
    if (_discoverPathMTU != value)
    {
        _discoverPathMTU = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("DiscoverPathMTU");
        }
    }

    return _discoverPathMTU;
}

auto Tunnel::discoverPathMTU(bool val) -> bool
{
    return discoverPathMTU(val, false);
}
int Tunnel::_callback_set_DiscoverPathMTU(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* value, void* context,
                                          sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->discoverPathMTU(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_DiscoverPathMTU =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Tunnel::iPv6FlowLabel() const -> uint32_t
{
    return _iPv6FlowLabel;
}

int Tunnel::_callback_get_IPv6FlowLabel(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->iPv6FlowLabel()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::iPv6FlowLabel(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_iPv6FlowLabel != value)
    {
        _iPv6FlowLabel = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("IPv6FlowLabel");
        }
    }

    return _iPv6FlowLabel;
}

auto Tunnel::iPv6FlowLabel(uint32_t val) -> uint32_t
{
    return iPv6FlowLabel(val, false);
}
int Tunnel::_callback_set_IPv6FlowLabel(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->iPv6FlowLabel(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_IPv6FlowLabel =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto Tunnel::copyDSCP() const -> bool
{
    return _copyDSCP;
}

int Tunnel::_callback_get_CopyDSCP(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->copyDSCP()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::copyDSCP(bool value, bool skipSignal) -> bool
{
    if (_copyDSCP != value)
    {
        _copyDSCP = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("CopyDSCP");
        }
    }

    return _copyDSCP;
}

auto Tunnel::copyDSCP(bool val) -> bool
{
    return copyDSCP(val, false);
}
int Tunnel::_callback_set_CopyDSCP(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->copyDSCP(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_CopyDSCP =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Tunnel::encapsulationLimit() const -> uint32_t
{
    return _encapsulationLimit;
}

int Tunnel::_callback_get_EncapsulationLimit(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->encapsulationLimit()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::encapsulationLimit(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_encapsulationLimit != value)
    {
        _encapsulationLimit = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("EncapsulationLimit");
        }
    }

    return _encapsulationLimit;
}

auto Tunnel::encapsulationLimit(uint32_t val) -> uint32_t
{
    return encapsulationLimit(val, false);
}
int Tunnel::_callback_set_EncapsulationLimit(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->encapsulationLimit(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_EncapsulationLimit =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto Tunnel::key() const -> std::string
{
    return _key;
}

int Tunnel::_callback_get_Key(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* reply, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->key()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::key(std::string value, bool skipSignal) -> std::string
{
    if (_key != value)
    {
        _key = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("Key");
        }
    }

    return _key;
}

auto Tunnel::key(std::string val) -> std::string
{
    return key(val, false);
}
int Tunnel::_callback_set_Key(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* value, void* context,
                              sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->key(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_Key =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Tunnel::inputKey() const -> std::string
{
    return _inputKey;
}

int Tunnel::_callback_get_InputKey(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->inputKey()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::inputKey(std::string value, bool skipSignal) -> std::string
{
    if (_inputKey != value)
    {
        _inputKey = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("InputKey");
        }
    }

    return _inputKey;
}

auto Tunnel::inputKey(std::string val) -> std::string
{
    return inputKey(val, false);
}
int Tunnel::_callback_set_InputKey(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->inputKey(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_InputKey =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Tunnel::outputKey() const -> std::string
{
    return _outputKey;
}

int Tunnel::_callback_get_OutputKey(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* reply, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->outputKey()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::outputKey(std::string value, bool skipSignal) -> std::string
{
    if (_outputKey != value)
    {
        _outputKey = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("OutputKey");
        }
    }

    return _outputKey;
}

auto Tunnel::outputKey(std::string val) -> std::string
{
    return outputKey(val, false);
}
int Tunnel::_callback_set_OutputKey(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* value, void* context,
                                    sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->outputKey(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_OutputKey =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Tunnel::mode() const -> IPv6Tunnel
{
    return _mode;
}

int Tunnel::_callback_get_Mode(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->mode()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Tunnel::mode(IPv6Tunnel value, bool skipSignal) -> IPv6Tunnel
{
    if (_mode != value)
    {
        _mode = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Experimental_Tunnel_interface
                .property_changed("Mode");
        }
    }

    return _mode;
}

auto Tunnel::mode(IPv6Tunnel val) -> IPv6Tunnel
{
    return mode(val, false);
}
int Tunnel::_callback_set_Mode(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<Tunnel*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->mode(convertIPv6TunnelFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Tunnel
{
static const auto _property_Mode =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Tunnel::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "InterfaceName")
    {
        auto& v = std::get<std::string>(val);
        interfaceName(v, skipSignal);
        return;
    }
    if (_name == "Local")
    {
        auto& v = std::get<std::string>(val);
        local(v, skipSignal);
        return;
    }
    if (_name == "Remote")
    {
        auto& v = std::get<std::string>(val);
        remote(v, skipSignal);
        return;
    }
    if (_name == "TOS")
    {
        auto& v = std::get<uint32_t>(val);
        tOS(v, skipSignal);
        return;
    }
    if (_name == "TTL")
    {
        auto& v = std::get<uint32_t>(val);
        tTL(v, skipSignal);
        return;
    }
    if (_name == "DiscoverPathMTU")
    {
        auto& v = std::get<bool>(val);
        discoverPathMTU(v, skipSignal);
        return;
    }
    if (_name == "IPv6FlowLabel")
    {
        auto& v = std::get<uint32_t>(val);
        iPv6FlowLabel(v, skipSignal);
        return;
    }
    if (_name == "CopyDSCP")
    {
        auto& v = std::get<bool>(val);
        copyDSCP(v, skipSignal);
        return;
    }
    if (_name == "EncapsulationLimit")
    {
        auto& v = std::get<uint32_t>(val);
        encapsulationLimit(v, skipSignal);
        return;
    }
    if (_name == "Key")
    {
        auto& v = std::get<std::string>(val);
        key(v, skipSignal);
        return;
    }
    if (_name == "InputKey")
    {
        auto& v = std::get<std::string>(val);
        inputKey(v, skipSignal);
        return;
    }
    if (_name == "OutputKey")
    {
        auto& v = std::get<std::string>(val);
        outputKey(v, skipSignal);
        return;
    }
    if (_name == "Mode")
    {
        auto& v = std::get<IPv6Tunnel>(val);
        mode(v, skipSignal);
        return;
    }
}

auto Tunnel::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "InterfaceName")
    {
        return interfaceName();
    }
    if (_name == "Local")
    {
        return local();
    }
    if (_name == "Remote")
    {
        return remote();
    }
    if (_name == "TOS")
    {
        return tOS();
    }
    if (_name == "TTL")
    {
        return tTL();
    }
    if (_name == "DiscoverPathMTU")
    {
        return discoverPathMTU();
    }
    if (_name == "IPv6FlowLabel")
    {
        return iPv6FlowLabel();
    }
    if (_name == "CopyDSCP")
    {
        return copyDSCP();
    }
    if (_name == "EncapsulationLimit")
    {
        return encapsulationLimit();
    }
    if (_name == "Key")
    {
        return key();
    }
    if (_name == "InputKey")
    {
        return inputKey();
    }
    if (_name == "OutputKey")
    {
        return outputKey();
    }
    if (_name == "Mode")
    {
        return mode();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Tunnel::IPv6Tunnel */
static const std::tuple<const char*, Tunnel::IPv6Tunnel>
    mappingTunnelIPv6Tunnel[] = {
        std::make_tuple(
            "xyz.openbmc_project.Network.Experimental.Tunnel.IPv6Tunnel.ip6ip6",
            Tunnel::IPv6Tunnel::ip6ip6),
        std::make_tuple(
            "xyz.openbmc_project.Network.Experimental.Tunnel.IPv6Tunnel.ipip6",
            Tunnel::IPv6Tunnel::ipip6),
        std::make_tuple(
            "xyz.openbmc_project.Network.Experimental.Tunnel.IPv6Tunnel.any",
            Tunnel::IPv6Tunnel::any),
};

} // anonymous namespace

auto Tunnel::convertIPv6TunnelFromString(const std::string& s) -> IPv6Tunnel
{
    auto i = std::find_if(
        std::begin(mappingTunnelIPv6Tunnel), std::end(mappingTunnelIPv6Tunnel),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingTunnelIPv6Tunnel) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Tunnel::IPv6Tunnel v)
{
    auto i = std::find_if(std::begin(mappingTunnelIPv6Tunnel),
                          std::end(mappingTunnelIPv6Tunnel),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingTunnelIPv6Tunnel))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Tunnel::_vtable[] = {
    vtable::start(),
    vtable::property("InterfaceName",
                     details::Tunnel::_property_InterfaceName.data(),
                     _callback_get_InterfaceName, _callback_set_InterfaceName,
                     vtable::property_::emits_change),
    vtable::property("Local", details::Tunnel::_property_Local.data(),
                     _callback_get_Local, _callback_set_Local,
                     vtable::property_::emits_change),
    vtable::property("Remote", details::Tunnel::_property_Remote.data(),
                     _callback_get_Remote, _callback_set_Remote,
                     vtable::property_::emits_change),
    vtable::property("TOS", details::Tunnel::_property_TOS.data(),
                     _callback_get_TOS, _callback_set_TOS,
                     vtable::property_::emits_change),
    vtable::property("TTL", details::Tunnel::_property_TTL.data(),
                     _callback_get_TTL, _callback_set_TTL,
                     vtable::property_::emits_change),
    vtable::property(
        "DiscoverPathMTU", details::Tunnel::_property_DiscoverPathMTU.data(),
        _callback_get_DiscoverPathMTU, _callback_set_DiscoverPathMTU,
        vtable::property_::emits_change),
    vtable::property("IPv6FlowLabel",
                     details::Tunnel::_property_IPv6FlowLabel.data(),
                     _callback_get_IPv6FlowLabel, _callback_set_IPv6FlowLabel,
                     vtable::property_::emits_change),
    vtable::property("CopyDSCP", details::Tunnel::_property_CopyDSCP.data(),
                     _callback_get_CopyDSCP, _callback_set_CopyDSCP,
                     vtable::property_::emits_change),
    vtable::property("EncapsulationLimit",
                     details::Tunnel::_property_EncapsulationLimit.data(),
                     _callback_get_EncapsulationLimit,
                     _callback_set_EncapsulationLimit,
                     vtable::property_::emits_change),
    vtable::property("Key", details::Tunnel::_property_Key.data(),
                     _callback_get_Key, _callback_set_Key,
                     vtable::property_::emits_change),
    vtable::property("InputKey", details::Tunnel::_property_InputKey.data(),
                     _callback_get_InputKey, _callback_set_InputKey,
                     vtable::property_::emits_change),
    vtable::property("OutputKey", details::Tunnel::_property_OutputKey.data(),
                     _callback_get_OutputKey, _callback_set_OutputKey,
                     vtable::property_::emits_change),
    vtable::property("Mode", details::Tunnel::_property_Mode.data(),
                     _callback_get_Mode, _callback_set_Mode,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Experimental
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Network/SystemConfiguration/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace server
{

SystemConfiguration::SystemConfiguration(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_SystemConfiguration_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

SystemConfiguration::SystemConfiguration(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    SystemConfiguration(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto SystemConfiguration::hostName() const -> std::string
{
    return _hostName;
}

int SystemConfiguration::_callback_get_HostName(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SystemConfiguration*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->hostName()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SystemConfiguration::hostName(std::string value, bool skipSignal)
    -> std::string
{
    if (_hostName != value)
    {
        _hostName = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_SystemConfiguration_interface
                .property_changed("HostName");
        }
    }

    return _hostName;
}

auto SystemConfiguration::hostName(std::string val) -> std::string
{
    return hostName(val, false);
}
int SystemConfiguration::_callback_set_HostName(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<SystemConfiguration*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->hostName(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SystemConfiguration
{
static const auto _property_HostName =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto SystemConfiguration::defaultGateway() const -> std::string
{
    return _defaultGateway;
}

int SystemConfiguration::_callback_get_DefaultGateway(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SystemConfiguration*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->defaultGateway()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SystemConfiguration::defaultGateway(std::string value, bool skipSignal)
    -> std::string
{
    if (_defaultGateway != value)
    {
        _defaultGateway = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_SystemConfiguration_interface
                .property_changed("DefaultGateway");
        }
    }

    return _defaultGateway;
}

auto SystemConfiguration::defaultGateway(std::string val) -> std::string
{
    return defaultGateway(val, false);
}
int SystemConfiguration::_callback_set_DefaultGateway(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<SystemConfiguration*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->defaultGateway(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SystemConfiguration
{
static const auto _property_DefaultGateway =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto SystemConfiguration::defaultGateway6() const -> std::string
{
    return _defaultGateway6;
}

int SystemConfiguration::_callback_get_DefaultGateway6(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SystemConfiguration*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->defaultGateway6()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SystemConfiguration::defaultGateway6(std::string value, bool skipSignal)
    -> std::string
{
    if (_defaultGateway6 != value)
    {
        _defaultGateway6 = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_SystemConfiguration_interface
                .property_changed("DefaultGateway6");
        }
    }

    return _defaultGateway6;
}

auto SystemConfiguration::defaultGateway6(std::string val) -> std::string
{
    return defaultGateway6(val, false);
}
int SystemConfiguration::_callback_set_DefaultGateway6(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<SystemConfiguration*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->defaultGateway6(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SystemConfiguration
{
static const auto _property_DefaultGateway6 =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void SystemConfiguration::setPropertyByName(const std::string& _name,
                                            const PropertiesVariant& val,
                                            bool skipSignal)
{
    if (_name == "HostName")
    {
        auto& v = std::get<std::string>(val);
        hostName(v, skipSignal);
        return;
    }
    if (_name == "DefaultGateway")
    {
        auto& v = std::get<std::string>(val);
        defaultGateway(v, skipSignal);
        return;
    }
    if (_name == "DefaultGateway6")
    {
        auto& v = std::get<std::string>(val);
        defaultGateway6(v, skipSignal);
        return;
    }
}

auto SystemConfiguration::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "HostName")
    {
        return hostName();
    }
    if (_name == "DefaultGateway")
    {
        return defaultGateway();
    }
    if (_name == "DefaultGateway6")
    {
        return defaultGateway6();
    }

    return PropertiesVariant();
}

const vtable::vtable_t SystemConfiguration::_vtable[] = {
    vtable::start(),
    vtable::property("HostName",
                     details::SystemConfiguration::_property_HostName.data(),
                     _callback_get_HostName, _callback_set_HostName,
                     vtable::property_::emits_change),
    vtable::property(
        "DefaultGateway",
        details::SystemConfiguration::_property_DefaultGateway.data(),
        _callback_get_DefaultGateway, _callback_set_DefaultGateway,
        vtable::property_::emits_change),
    vtable::property(
        "DefaultGateway6",
        details::SystemConfiguration::_property_DefaultGateway6.data(),
        _callback_get_DefaultGateway6, _callback_set_DefaultGateway6,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Network/MACAddress/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace server
{

MACAddress::MACAddress(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_MACAddress_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

MACAddress::MACAddress(bus::bus& bus, const char* path,
                       const std::map<std::string, PropertiesVariant>& vals,
                       bool skipSignal) :
    MACAddress(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto MACAddress::mACAddress() const -> std::string
{
    return _mACAddress;
}

int MACAddress::_callback_get_MACAddress(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<MACAddress*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->mACAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto MACAddress::mACAddress(std::string value, bool skipSignal) -> std::string
{
    if (_mACAddress != value)
    {
        _mACAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_MACAddress_interface.property_changed(
                "MACAddress");
        }
    }

    return _mACAddress;
}

auto MACAddress::mACAddress(std::string val) -> std::string
{
    return mACAddress(val, false);
}
int MACAddress::_callback_set_MACAddress(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<MACAddress*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->mACAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace MACAddress
{
static const auto _property_MACAddress =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void MACAddress::setPropertyByName(const std::string& _name,
                                   const PropertiesVariant& val,
                                   bool skipSignal)
{
    if (_name == "MACAddress")
    {
        auto& v = std::get<std::string>(val);
        mACAddress(v, skipSignal);
        return;
    }
}

auto MACAddress::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "MACAddress")
    {
        return mACAddress();
    }

    return PropertiesVariant();
}

const vtable::vtable_t MACAddress::_vtable[] = {
    vtable::start(),
    vtable::property("MACAddress",
                     details::MACAddress::_property_MACAddress.data(),
                     _callback_get_MACAddress, _callback_set_MACAddress,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Network/DHCPConfiguration/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace server
{

DHCPConfiguration::DHCPConfiguration(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_DHCPConfiguration_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

DHCPConfiguration::DHCPConfiguration(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    DHCPConfiguration(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto DHCPConfiguration::dNSEnabled() const -> bool
{
    return _dNSEnabled;
}

int DHCPConfiguration::_callback_get_DNSEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<DHCPConfiguration*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->dNSEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto DHCPConfiguration::dNSEnabled(bool value, bool skipSignal) -> bool
{
    if (_dNSEnabled != value)
    {
        _dNSEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_DHCPConfiguration_interface
                .property_changed("DNSEnabled");
        }
    }

    return _dNSEnabled;
}

auto DHCPConfiguration::dNSEnabled(bool val) -> bool
{
    return dNSEnabled(val, false);
}
int DHCPConfiguration::_callback_set_DNSEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<DHCPConfiguration*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->dNSEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace DHCPConfiguration
{
static const auto _property_DNSEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto DHCPConfiguration::nTPEnabled() const -> bool
{
    return _nTPEnabled;
}

int DHCPConfiguration::_callback_get_NTPEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<DHCPConfiguration*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->nTPEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto DHCPConfiguration::nTPEnabled(bool value, bool skipSignal) -> bool
{
    if (_nTPEnabled != value)
    {
        _nTPEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_DHCPConfiguration_interface
                .property_changed("NTPEnabled");
        }
    }

    return _nTPEnabled;
}

auto DHCPConfiguration::nTPEnabled(bool val) -> bool
{
    return nTPEnabled(val, false);
}
int DHCPConfiguration::_callback_set_NTPEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<DHCPConfiguration*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->nTPEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace DHCPConfiguration
{
static const auto _property_NTPEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto DHCPConfiguration::hostNameEnabled() const -> bool
{
    return _hostNameEnabled;
}

int DHCPConfiguration::_callback_get_HostNameEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<DHCPConfiguration*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->hostNameEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto DHCPConfiguration::hostNameEnabled(bool value, bool skipSignal) -> bool
{
    if (_hostNameEnabled != value)
    {
        _hostNameEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_DHCPConfiguration_interface
                .property_changed("HostNameEnabled");
        }
    }

    return _hostNameEnabled;
}

auto DHCPConfiguration::hostNameEnabled(bool val) -> bool
{
    return hostNameEnabled(val, false);
}
int DHCPConfiguration::_callback_set_HostNameEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<DHCPConfiguration*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->hostNameEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace DHCPConfiguration
{
static const auto _property_HostNameEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto DHCPConfiguration::sendHostNameEnabled() const -> bool
{
    return _sendHostNameEnabled;
}

int DHCPConfiguration::_callback_get_SendHostNameEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<DHCPConfiguration*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->sendHostNameEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto DHCPConfiguration::sendHostNameEnabled(bool value, bool skipSignal) -> bool
{
    if (_sendHostNameEnabled != value)
    {
        _sendHostNameEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_DHCPConfiguration_interface
                .property_changed("SendHostNameEnabled");
        }
    }

    return _sendHostNameEnabled;
}

auto DHCPConfiguration::sendHostNameEnabled(bool val) -> bool
{
    return sendHostNameEnabled(val, false);
}
int DHCPConfiguration::_callback_set_SendHostNameEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<DHCPConfiguration*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->sendHostNameEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace DHCPConfiguration
{
static const auto _property_SendHostNameEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void DHCPConfiguration::setPropertyByName(const std::string& _name,
                                          const PropertiesVariant& val,
                                          bool skipSignal)
{
    if (_name == "DNSEnabled")
    {
        auto& v = std::get<bool>(val);
        dNSEnabled(v, skipSignal);
        return;
    }
    if (_name == "NTPEnabled")
    {
        auto& v = std::get<bool>(val);
        nTPEnabled(v, skipSignal);
        return;
    }
    if (_name == "HostNameEnabled")
    {
        auto& v = std::get<bool>(val);
        hostNameEnabled(v, skipSignal);
        return;
    }
    if (_name == "SendHostNameEnabled")
    {
        auto& v = std::get<bool>(val);
        sendHostNameEnabled(v, skipSignal);
        return;
    }
}

auto DHCPConfiguration::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "DNSEnabled")
    {
        return dNSEnabled();
    }
    if (_name == "NTPEnabled")
    {
        return nTPEnabled();
    }
    if (_name == "HostNameEnabled")
    {
        return hostNameEnabled();
    }
    if (_name == "SendHostNameEnabled")
    {
        return sendHostNameEnabled();
    }

    return PropertiesVariant();
}

const vtable::vtable_t DHCPConfiguration::_vtable[] = {
    vtable::start(),
    vtable::property("DNSEnabled",
                     details::DHCPConfiguration::_property_DNSEnabled.data(),
                     _callback_get_DNSEnabled, _callback_set_DNSEnabled,
                     vtable::property_::emits_change),
    vtable::property("NTPEnabled",
                     details::DHCPConfiguration::_property_NTPEnabled.data(),
                     _callback_get_NTPEnabled, _callback_set_NTPEnabled,
                     vtable::property_::emits_change),
    vtable::property(
        "HostNameEnabled",
        details::DHCPConfiguration::_property_HostNameEnabled.data(),
        _callback_get_HostNameEnabled, _callback_set_HostNameEnabled,
        vtable::property_::emits_change),
    vtable::property(
        "SendHostNameEnabled",
        details::DHCPConfiguration::_property_SendHostNameEnabled.data(),
        _callback_get_SendHostNameEnabled, _callback_set_SendHostNameEnabled,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Network/Client/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace server
{

Client::Client(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_Client_interface(bus, path, _interface,
                                                  _vtable, this),
    _intf(bus.getInterface())
{
}

Client::Client(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    Client(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Client::address() const -> std::string
{
    return _address;
}

int Client::_callback_get_Address(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Client*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->address()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Client::address(std::string value, bool skipSignal) -> std::string
{
    if (_address != value)
    {
        _address = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Client_interface.property_changed(
                "Address");
        }
    }

    return _address;
}

auto Client::address(std::string val) -> std::string
{
    return address(val, false);
}
int Client::_callback_set_Address(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Client*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->address(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Client
{
static const auto _property_Address =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Client::port() const -> uint16_t
{
    return _port;
}

int Client::_callback_get_Port(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Client*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->port()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Client::port(uint16_t value, bool skipSignal) -> uint16_t
{
    if (_port != value)
    {
        _port = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_Client_interface.property_changed(
                "Port");
        }
    }

    return _port;
}

auto Client::port(uint16_t val) -> uint16_t
{
    return port(val, false);
}
int Client::_callback_set_Port(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<Client*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint16_t v{};
        m.read(v);
        o->port(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Client
{
static const auto _property_Port =
    utility::tuple_to_array(message::types::type_id<uint16_t>());
}
} // namespace details

void Client::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Address")
    {
        auto& v = std::get<std::string>(val);
        address(v, skipSignal);
        return;
    }
    if (_name == "Port")
    {
        auto& v = std::get<uint16_t>(val);
        port(v, skipSignal);
        return;
    }
}

auto Client::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Address")
    {
        return address();
    }
    if (_name == "Port")
    {
        return port();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Client::_vtable[] = {
    vtable::start(),
    vtable::property("Address", details::Client::_property_Address.data(),
                     _callback_get_Address, _callback_set_Address,
                     vtable::property_::emits_change),
    vtable::property("Port", details::Client::_property_Port.data(),
                     _callback_get_Port, _callback_set_Port,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Network/EthernetInterface/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace server
{

EthernetInterface::EthernetInterface(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_EthernetInterface_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

EthernetInterface::EthernetInterface(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    EthernetInterface(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto EthernetInterface::interfaceName() const -> std::string
{
    return _interfaceName;
}

int EthernetInterface::_callback_get_InterfaceName(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->interfaceName()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::interfaceName(std::string value, bool skipSignal)
    -> std::string
{
    if (_interfaceName != value)
    {
        _interfaceName = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("InterfaceName");
        }
    }

    return _interfaceName;
}

auto EthernetInterface::interfaceName(std::string val) -> std::string
{
    return interfaceName(val, false);
}
int EthernetInterface::_callback_set_InterfaceName(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->interfaceName(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_InterfaceName =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto EthernetInterface::speed() const -> uint32_t
{
    return _speed;
}

int EthernetInterface::_callback_get_Speed(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->speed()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::speed(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_speed != value)
    {
        _speed = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("Speed");
        }
    }

    return _speed;
}

auto EthernetInterface::speed(uint32_t val) -> uint32_t
{
    return speed(val, false);
}
int EthernetInterface::_callback_set_Speed(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->speed(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_Speed =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto EthernetInterface::autoNeg() const -> bool
{
    return _autoNeg;
}

int EthernetInterface::_callback_get_AutoNeg(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->autoNeg()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::autoNeg(bool value, bool skipSignal) -> bool
{
    if (_autoNeg != value)
    {
        _autoNeg = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("AutoNeg");
        }
    }

    return _autoNeg;
}

auto EthernetInterface::autoNeg(bool val) -> bool
{
    return autoNeg(val, false);
}
int EthernetInterface::_callback_set_AutoNeg(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->autoNeg(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_AutoNeg =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto EthernetInterface::domainName() const -> std::vector<std::string>
{
    return _domainName;
}

int EthernetInterface::_callback_get_DomainName(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->domainName()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::domainName(std::vector<std::string> value,
                                   bool skipSignal) -> std::vector<std::string>
{
    if (_domainName != value)
    {
        _domainName = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("DomainName");
        }
    }

    return _domainName;
}

auto EthernetInterface::domainName(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return domainName(val, false);
}
int EthernetInterface::_callback_set_DomainName(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->domainName(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_DomainName = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto EthernetInterface::dHCPEnabled() const -> bool
{
    return _dHCPEnabled;
}

int EthernetInterface::_callback_get_DHCPEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->dHCPEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::dHCPEnabled(bool value, bool skipSignal) -> bool
{
    if (_dHCPEnabled != value)
    {
        _dHCPEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("DHCPEnabled");
        }
    }

    return _dHCPEnabled;
}

auto EthernetInterface::dHCPEnabled(bool val) -> bool
{
    return dHCPEnabled(val, false);
}
int EthernetInterface::_callback_set_DHCPEnabled(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->dHCPEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_DHCPEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto EthernetInterface::nameservers() const -> std::vector<std::string>
{
    return _nameservers;
}

int EthernetInterface::_callback_get_Nameservers(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->nameservers()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::nameservers(std::vector<std::string> value,
                                    bool skipSignal) -> std::vector<std::string>
{
    if (_nameservers != value)
    {
        _nameservers = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("Nameservers");
        }
    }

    return _nameservers;
}

auto EthernetInterface::nameservers(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return nameservers(val, false);
}
int EthernetInterface::_callback_set_Nameservers(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->nameservers(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_Nameservers = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto EthernetInterface::nTPServers() const -> std::vector<std::string>
{
    return _nTPServers;
}

int EthernetInterface::_callback_get_NTPServers(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->nTPServers()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::nTPServers(std::vector<std::string> value,
                                   bool skipSignal) -> std::vector<std::string>
{
    if (_nTPServers != value)
    {
        _nTPServers = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("NTPServers");
        }
    }

    return _nTPServers;
}

auto EthernetInterface::nTPServers(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return nTPServers(val, false);
}
int EthernetInterface::_callback_set_NTPServers(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->nTPServers(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_NTPServers = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto EthernetInterface::linkLocalAutoConf() const -> LinkLocalConf
{
    return _linkLocalAutoConf;
}

int EthernetInterface::_callback_get_LinkLocalAutoConf(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->linkLocalAutoConf()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::linkLocalAutoConf(LinkLocalConf value, bool skipSignal)
    -> LinkLocalConf
{
    if (_linkLocalAutoConf != value)
    {
        _linkLocalAutoConf = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("LinkLocalAutoConf");
        }
    }

    return _linkLocalAutoConf;
}

auto EthernetInterface::linkLocalAutoConf(LinkLocalConf val) -> LinkLocalConf
{
    return linkLocalAutoConf(val, false);
}
int EthernetInterface::_callback_set_LinkLocalAutoConf(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->linkLocalAutoConf(convertLinkLocalConfFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_LinkLocalAutoConf =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto EthernetInterface::iPv6AcceptRA() const -> bool
{
    return _iPv6AcceptRA;
}

int EthernetInterface::_callback_get_IPv6AcceptRA(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->iPv6AcceptRA()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EthernetInterface::iPv6AcceptRA(bool value, bool skipSignal) -> bool
{
    if (_iPv6AcceptRA != value)
    {
        _iPv6AcceptRA = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_EthernetInterface_interface
                .property_changed("IPv6AcceptRA");
        }
    }

    return _iPv6AcceptRA;
}

auto EthernetInterface::iPv6AcceptRA(bool val) -> bool
{
    return iPv6AcceptRA(val, false);
}
int EthernetInterface::_callback_set_IPv6AcceptRA(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<EthernetInterface*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->iPv6AcceptRA(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EthernetInterface
{
static const auto _property_IPv6AcceptRA =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void EthernetInterface::setPropertyByName(const std::string& _name,
                                          const PropertiesVariant& val,
                                          bool skipSignal)
{
    if (_name == "InterfaceName")
    {
        auto& v = std::get<std::string>(val);
        interfaceName(v, skipSignal);
        return;
    }
    if (_name == "Speed")
    {
        auto& v = std::get<uint32_t>(val);
        speed(v, skipSignal);
        return;
    }
    if (_name == "AutoNeg")
    {
        auto& v = std::get<bool>(val);
        autoNeg(v, skipSignal);
        return;
    }
    if (_name == "DomainName")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        domainName(v, skipSignal);
        return;
    }
    if (_name == "DHCPEnabled")
    {
        auto& v = std::get<bool>(val);
        dHCPEnabled(v, skipSignal);
        return;
    }
    if (_name == "Nameservers")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        nameservers(v, skipSignal);
        return;
    }
    if (_name == "NTPServers")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        nTPServers(v, skipSignal);
        return;
    }
    if (_name == "LinkLocalAutoConf")
    {
        auto& v = std::get<LinkLocalConf>(val);
        linkLocalAutoConf(v, skipSignal);
        return;
    }
    if (_name == "IPv6AcceptRA")
    {
        auto& v = std::get<bool>(val);
        iPv6AcceptRA(v, skipSignal);
        return;
    }
}

auto EthernetInterface::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "InterfaceName")
    {
        return interfaceName();
    }
    if (_name == "Speed")
    {
        return speed();
    }
    if (_name == "AutoNeg")
    {
        return autoNeg();
    }
    if (_name == "DomainName")
    {
        return domainName();
    }
    if (_name == "DHCPEnabled")
    {
        return dHCPEnabled();
    }
    if (_name == "Nameservers")
    {
        return nameservers();
    }
    if (_name == "NTPServers")
    {
        return nTPServers();
    }
    if (_name == "LinkLocalAutoConf")
    {
        return linkLocalAutoConf();
    }
    if (_name == "IPv6AcceptRA")
    {
        return iPv6AcceptRA();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for EthernetInterface::LinkLocalConf */
static const std::tuple<const char*, EthernetInterface::LinkLocalConf>
    mappingEthernetInterfaceLinkLocalConf[] = {
        std::make_tuple(
            "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf.both",
            EthernetInterface::LinkLocalConf::both),
        std::make_tuple(
            "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf.v4",
            EthernetInterface::LinkLocalConf::v4),
        std::make_tuple(
            "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf.v6",
            EthernetInterface::LinkLocalConf::v6),
        std::make_tuple(
            "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf.none",
            EthernetInterface::LinkLocalConf::none),
};

} // anonymous namespace

auto EthernetInterface::convertLinkLocalConfFromString(const std::string& s)
    -> LinkLocalConf
{
    auto i = std::find_if(
        std::begin(mappingEthernetInterfaceLinkLocalConf),
        std::end(mappingEthernetInterfaceLinkLocalConf),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingEthernetInterfaceLinkLocalConf) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(EthernetInterface::LinkLocalConf v)
{
    auto i = std::find_if(std::begin(mappingEthernetInterfaceLinkLocalConf),
                          std::end(mappingEthernetInterfaceLinkLocalConf),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingEthernetInterfaceLinkLocalConf))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t EthernetInterface::_vtable[] = {
    vtable::start(),
    vtable::property("InterfaceName",
                     details::EthernetInterface::_property_InterfaceName.data(),
                     _callback_get_InterfaceName, _callback_set_InterfaceName,
                     vtable::property_::emits_change),
    vtable::property("Speed",
                     details::EthernetInterface::_property_Speed.data(),
                     _callback_get_Speed, _callback_set_Speed,
                     vtable::property_::emits_change),
    vtable::property("AutoNeg",
                     details::EthernetInterface::_property_AutoNeg.data(),
                     _callback_get_AutoNeg, _callback_set_AutoNeg,
                     vtable::property_::emits_change),
    vtable::property("DomainName",
                     details::EthernetInterface::_property_DomainName.data(),
                     _callback_get_DomainName, _callback_set_DomainName,
                     vtable::property_::emits_change),
    vtable::property("DHCPEnabled",
                     details::EthernetInterface::_property_DHCPEnabled.data(),
                     _callback_get_DHCPEnabled, _callback_set_DHCPEnabled,
                     vtable::property_::emits_change),
    vtable::property("Nameservers",
                     details::EthernetInterface::_property_Nameservers.data(),
                     _callback_get_Nameservers, _callback_set_Nameservers,
                     vtable::property_::emits_change),
    vtable::property("NTPServers",
                     details::EthernetInterface::_property_NTPServers.data(),
                     _callback_get_NTPServers, _callback_set_NTPServers,
                     vtable::property_::emits_change),
    vtable::property(
        "LinkLocalAutoConf",
        details::EthernetInterface::_property_LinkLocalAutoConf.data(),
        _callback_get_LinkLocalAutoConf, _callback_set_LinkLocalAutoConf,
        vtable::property_::emits_change),
    vtable::property("IPv6AcceptRA",
                     details::EthernetInterface::_property_IPv6AcceptRA.data(),
                     _callback_get_IPv6AcceptRA, _callback_set_IPv6AcceptRA,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Network/VLAN/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Network
{
namespace server
{

VLAN::VLAN(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Network_VLAN_interface(bus, path, _interface, _vtable,
                                                this),
    _intf(bus.getInterface())
{
}

VLAN::VLAN(bus::bus& bus, const char* path,
           const std::map<std::string, PropertiesVariant>& vals,
           bool skipSignal) :
    VLAN(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto VLAN::interfaceName() const -> std::string
{
    return _interfaceName;
}

int VLAN::_callback_get_InterfaceName(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<VLAN*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->interfaceName()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto VLAN::interfaceName(std::string value, bool skipSignal) -> std::string
{
    if (_interfaceName != value)
    {
        _interfaceName = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_VLAN_interface.property_changed(
                "InterfaceName");
        }
    }

    return _interfaceName;
}

auto VLAN::interfaceName(std::string val) -> std::string
{
    return interfaceName(val, false);
}
int VLAN::_callback_set_InterfaceName(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<VLAN*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->interfaceName(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace VLAN
{
static const auto _property_InterfaceName =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto VLAN::id() const -> uint32_t
{
    return _id;
}

int VLAN::_callback_get_Id(sd_bus* bus, const char* path, const char* interface,
                           const char* property, sd_bus_message* reply,
                           void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<VLAN*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->id()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto VLAN::id(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_id != value)
    {
        _id = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Network_VLAN_interface.property_changed("Id");
        }
    }

    return _id;
}

auto VLAN::id(uint32_t val) -> uint32_t
{
    return id(val, false);
}
int VLAN::_callback_set_Id(sd_bus* bus, const char* path, const char* interface,
                           const char* property, sd_bus_message* value,
                           void* context, sd_bus_error* error)
{
    auto o = static_cast<VLAN*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->id(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace VLAN
{
static const auto _property_Id =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

void VLAN::setPropertyByName(const std::string& _name,
                             const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "InterfaceName")
    {
        auto& v = std::get<std::string>(val);
        interfaceName(v, skipSignal);
        return;
    }
    if (_name == "Id")
    {
        auto& v = std::get<uint32_t>(val);
        id(v, skipSignal);
        return;
    }
}

auto VLAN::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "InterfaceName")
    {
        return interfaceName();
    }
    if (_name == "Id")
    {
        return id();
    }

    return PropertiesVariant();
}

const vtable::vtable_t VLAN::_vtable[] = {
    vtable::start(),
    vtable::property("InterfaceName",
                     details::VLAN::_property_InterfaceName.data(),
                     _callback_get_InterfaceName, _callback_set_InterfaceName,
                     vtable::property_::emits_change),
    vtable::property("Id", details::VLAN::_property_Id.data(), _callback_get_Id,
                     _callback_set_Id, vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Network
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/UUID/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace server
{

UUID::UUID(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Common_UUID_interface(bus, path, _interface, _vtable,
                                               this),
    _intf(bus.getInterface())
{
}

UUID::UUID(bus::bus& bus, const char* path,
           const std::map<std::string, PropertiesVariant>& vals,
           bool skipSignal) :
    UUID(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto UUID::uUID() const -> std::string
{
    return _uUID;
}

int UUID::_callback_get_UUID(sd_bus* bus, const char* path,
                             const char* interface, const char* property,
                             sd_bus_message* reply, void* context,
                             sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<UUID*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->uUID()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto UUID::uUID(std::string value, bool skipSignal) -> std::string
{
    if (_uUID != value)
    {
        _uUID = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Common_UUID_interface.property_changed("UUID");
        }
    }

    return _uUID;
}

auto UUID::uUID(std::string val) -> std::string
{
    return uUID(val, false);
}
int UUID::_callback_set_UUID(sd_bus* bus, const char* path,
                             const char* interface, const char* property,
                             sd_bus_message* value, void* context,
                             sd_bus_error* error)
{
    auto o = static_cast<UUID*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->uUID(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace UUID
{
static const auto _property_UUID =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void UUID::setPropertyByName(const std::string& _name,
                             const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "UUID")
    {
        auto& v = std::get<std::string>(val);
        uUID(v, skipSignal);
        return;
    }
}

auto UUID::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "UUID")
    {
        return uUID();
    }

    return PropertiesVariant();
}

const vtable::vtable_t UUID::_vtable[] = {
    vtable::start(),
    vtable::property("UUID", details::UUID::_property_UUID.data(),
                     _callback_get_UUID, _callback_set_UUID,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/TFTP/server.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace server
{

TFTP::TFTP(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Common_TFTP_interface(bus, path, _interface, _vtable,
                                               this),
    _intf(bus.getInterface())
{
}

int TFTP::_callback_DownloadViaTFTP(sd_bus_message* msg, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string fileName{};
        std::string serverAddress{};

        m.read(fileName, serverAddress);

        auto o = static_cast<TFTP*>(context);
        o->downloadViaTFTP(fileName, serverAddress);

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace TFTP
{
static const auto _param_DownloadViaTFTP = utility::tuple_to_array(
    message::types::type_id<std::string, std::string>());
static const auto _return_DownloadViaTFTP =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace TFTP
} // namespace details

const vtable::vtable_t TFTP::_vtable[] = {
    vtable::start(),

    vtable::method("DownloadViaTFTP",
                   details::TFTP::_param_DownloadViaTFTP.data(),
                   details::TFTP::_return_DownloadViaTFTP.data(),
                   _callback_DownloadViaTFTP),
    vtable::end()};

} // namespace server
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/ObjectPath/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace server
{

ObjectPath::ObjectPath(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Common_ObjectPath_interface(bus, path, _interface,
                                                     _vtable, this),
    _intf(bus.getInterface())
{
}

ObjectPath::ObjectPath(bus::bus& bus, const char* path,
                       const std::map<std::string, PropertiesVariant>& vals,
                       bool skipSignal) :
    ObjectPath(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto ObjectPath::path() const -> std::string
{
    return _path;
}

int ObjectPath::_callback_get_Path(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<ObjectPath*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->path()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto ObjectPath::path(std::string value, bool skipSignal) -> std::string
{
    if (_path != value)
    {
        _path = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Common_ObjectPath_interface.property_changed(
                "Path");
        }
    }

    return _path;
}

auto ObjectPath::path(std::string val) -> std::string
{
    return path(val, false);
}
int ObjectPath::_callback_set_Path(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<ObjectPath*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->path(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace ObjectPath
{
static const auto _property_Path =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void ObjectPath::setPropertyByName(const std::string& _name,
                                   const PropertiesVariant& val,
                                   bool skipSignal)
{
    if (_name == "Path")
    {
        auto& v = std::get<std::string>(val);
        path(v, skipSignal);
        return;
    }
}

auto ObjectPath::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "Path")
    {
        return path();
    }

    return PropertiesVariant();
}

const vtable::vtable_t ObjectPath::_vtable[] = {
    vtable::start(),
    vtable::property("Path", details::ObjectPath::_property_Path.data(),
                     _callback_get_Path, _callback_set_Path,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/FactoryReset/server.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace server
{

FactoryReset::FactoryReset(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Common_FactoryReset_interface(bus, path, _interface,
                                                       _vtable, this),
    _intf(bus.getInterface())
{
}

int FactoryReset::_callback_Reset(sd_bus_message* msg, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<FactoryReset*>(context);
        o->reset();

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace FactoryReset
{
static const auto _param_Reset = utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_Reset =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace FactoryReset
} // namespace details

const vtable::vtable_t FactoryReset::_vtable[] = {
    vtable::start(),

    vtable::method("Reset", details::FactoryReset::_param_Reset.data(),
                   details::FactoryReset::_return_Reset.data(),
                   _callback_Reset),
    vtable::end()};

} // namespace server
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/FilePath/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace server
{

FilePath::FilePath(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Common_FilePath_interface(bus, path, _interface,
                                                   _vtable, this),
    _intf(bus.getInterface())
{
}

FilePath::FilePath(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    FilePath(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto FilePath::path() const -> std::string
{
    return _path;
}

int FilePath::_callback_get_Path(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<FilePath*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->path()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto FilePath::path(std::string value, bool skipSignal) -> std::string
{
    if (_path != value)
    {
        _path = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Common_FilePath_interface.property_changed(
                "Path");
        }
    }

    return _path;
}

auto FilePath::path(std::string val) -> std::string
{
    return path(val, false);
}
int FilePath::_callback_set_Path(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<FilePath*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->path(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace FilePath
{
static const auto _property_Path =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void FilePath::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Path")
    {
        auto& v = std::get<std::string>(val);
        path(v, skipSignal);
        return;
    }
}

auto FilePath::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Path")
    {
        return path();
    }

    return PropertiesVariant();
}

const vtable::vtable_t FilePath::_vtable[] = {
    vtable::start(),
    vtable::property("Path", details::FilePath::_property_Path.data(),
                     _callback_get_Path, _callback_set_Path,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/State/OperatingSystem/Status/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace OperatingSystem
{
namespace server
{

Status::Status(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_OperatingSystem_Status_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Status::Status(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    Status(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Status::operatingSystemState() const -> OSStatus
{
    return _operatingSystemState;
}

int Status::_callback_get_OperatingSystemState(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->operatingSystemState()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::operatingSystemState(OSStatus value, bool skipSignal) -> OSStatus
{
    if (_operatingSystemState != value)
    {
        _operatingSystemState = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_OperatingSystem_Status_interface
                .property_changed("OperatingSystemState");
        }
    }

    return _operatingSystemState;
}

auto Status::operatingSystemState(OSStatus val) -> OSStatus
{
    return operatingSystemState(val, false);
}
int Status::_callback_set_OperatingSystemState(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->operatingSystemState(convertOSStatusFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_OperatingSystemState =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Status::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "OperatingSystemState")
    {
        auto& v = std::get<OSStatus>(val);
        operatingSystemState(v, skipSignal);
        return;
    }
}

auto Status::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "OperatingSystemState")
    {
        return operatingSystemState();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Status::OSStatus */
static const std::tuple<const char*, Status::OSStatus> mappingStatusOSStatus[] =
    {
        std::make_tuple(
            "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.CBoot",
            Status::OSStatus::CBoot),
        std::make_tuple(
            "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.PXEBoot",
            Status::OSStatus::PXEBoot),
        std::make_tuple("xyz.openbmc_project.State.OperatingSystem.Status."
                        "OSStatus.DiagBoot",
                        Status::OSStatus::DiagBoot),
        std::make_tuple("xyz.openbmc_project.State.OperatingSystem.Status."
                        "OSStatus.CDROMBoot",
                        Status::OSStatus::CDROMBoot),
        std::make_tuple(
            "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.ROMBoot",
            Status::OSStatus::ROMBoot),
        std::make_tuple("xyz.openbmc_project.State.OperatingSystem.Status."
                        "OSStatus.BootComplete",
                        Status::OSStatus::BootComplete),
        std::make_tuple("xyz.openbmc_project.State.OperatingSystem.Status."
                        "OSStatus.Inactive",
                        Status::OSStatus::Inactive),
        std::make_tuple(
            "xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby",
            Status::OSStatus::Standby),
};

} // anonymous namespace

auto Status::convertOSStatusFromString(const std::string& s) -> OSStatus
{
    auto i = std::find_if(
        std::begin(mappingStatusOSStatus), std::end(mappingStatusOSStatus),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingStatusOSStatus) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Status::OSStatus v)
{
    auto i = std::find_if(std::begin(mappingStatusOSStatus),
                          std::end(mappingStatusOSStatus),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingStatusOSStatus))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Status::_vtable[] = {
    vtable::start(),
    vtable::property("OperatingSystemState",
                     details::Status::_property_OperatingSystemState.data(),
                     _callback_get_OperatingSystemState,
                     _callback_set_OperatingSystemState,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace OperatingSystem
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/State/BMC/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace server
{

BMC::BMC(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_BMC_interface(bus, path, _interface, _vtable,
                                             this),
    _intf(bus.getInterface())
{
}

BMC::BMC(bus::bus& bus, const char* path,
         const std::map<std::string, PropertiesVariant>& vals,
         bool skipSignal) :
    BMC(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto BMC::requestedBMCTransition() const -> Transition
{
    return _requestedBMCTransition;
}

int BMC::_callback_get_RequestedBMCTransition(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<BMC*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->requestedBMCTransition()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto BMC::requestedBMCTransition(Transition value, bool skipSignal)
    -> Transition
{
    if (_requestedBMCTransition != value)
    {
        _requestedBMCTransition = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_BMC_interface.property_changed(
                "RequestedBMCTransition");
        }
    }

    return _requestedBMCTransition;
}

auto BMC::requestedBMCTransition(Transition val) -> Transition
{
    return requestedBMCTransition(val, false);
}
int BMC::_callback_set_RequestedBMCTransition(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<BMC*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->requestedBMCTransition(convertTransitionFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace BMC
{
static const auto _property_RequestedBMCTransition =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto BMC::currentBMCState() const -> BMCState
{
    return _currentBMCState;
}

int BMC::_callback_get_CurrentBMCState(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* reply, void* context,
                                       sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<BMC*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->currentBMCState()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto BMC::currentBMCState(BMCState value, bool skipSignal) -> BMCState
{
    if (_currentBMCState != value)
    {
        _currentBMCState = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_BMC_interface.property_changed(
                "CurrentBMCState");
        }
    }

    return _currentBMCState;
}

auto BMC::currentBMCState(BMCState val) -> BMCState
{
    return currentBMCState(val, false);
}
int BMC::_callback_set_CurrentBMCState(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* value, void* context,
                                       sd_bus_error* error)
{
    auto o = static_cast<BMC*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->currentBMCState(convertBMCStateFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace BMC
{
static const auto _property_CurrentBMCState =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto BMC::lastRebootTime() const -> uint64_t
{
    return _lastRebootTime;
}

int BMC::_callback_get_LastRebootTime(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<BMC*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->lastRebootTime()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto BMC::lastRebootTime(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_lastRebootTime != value)
    {
        _lastRebootTime = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_BMC_interface.property_changed(
                "LastRebootTime");
        }
    }

    return _lastRebootTime;
}

auto BMC::lastRebootTime(uint64_t val) -> uint64_t
{
    return lastRebootTime(val, false);
}
int BMC::_callback_set_LastRebootTime(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<BMC*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->lastRebootTime(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace BMC
{
static const auto _property_LastRebootTime =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

void BMC::setPropertyByName(const std::string& _name,
                            const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "RequestedBMCTransition")
    {
        auto& v = std::get<Transition>(val);
        requestedBMCTransition(v, skipSignal);
        return;
    }
    if (_name == "CurrentBMCState")
    {
        auto& v = std::get<BMCState>(val);
        currentBMCState(v, skipSignal);
        return;
    }
    if (_name == "LastRebootTime")
    {
        auto& v = std::get<uint64_t>(val);
        lastRebootTime(v, skipSignal);
        return;
    }
}

auto BMC::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "RequestedBMCTransition")
    {
        return requestedBMCTransition();
    }
    if (_name == "CurrentBMCState")
    {
        return currentBMCState();
    }
    if (_name == "LastRebootTime")
    {
        return lastRebootTime();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for BMC::Transition */
static const std::tuple<const char*, BMC::Transition> mappingBMCTransition[] = {
    std::make_tuple("xyz.openbmc_project.State.BMC.Transition.Reboot",
                    BMC::Transition::Reboot),
    std::make_tuple("xyz.openbmc_project.State.BMC.Transition.None",
                    BMC::Transition::None),
};

} // anonymous namespace

auto BMC::convertTransitionFromString(const std::string& s) -> Transition
{
    auto i = std::find_if(
        std::begin(mappingBMCTransition), std::end(mappingBMCTransition),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingBMCTransition) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(BMC::Transition v)
{
    auto i = std::find_if(std::begin(mappingBMCTransition),
                          std::end(mappingBMCTransition),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingBMCTransition))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for BMC::BMCState */
static const std::tuple<const char*, BMC::BMCState> mappingBMCBMCState[] = {
    std::make_tuple("xyz.openbmc_project.State.BMC.BMCState.Ready",
                    BMC::BMCState::Ready),
    std::make_tuple("xyz.openbmc_project.State.BMC.BMCState.NotReady",
                    BMC::BMCState::NotReady),
};

} // anonymous namespace

auto BMC::convertBMCStateFromString(const std::string& s) -> BMCState
{
    auto i = std::find_if(
        std::begin(mappingBMCBMCState), std::end(mappingBMCBMCState),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingBMCBMCState) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(BMC::BMCState v)
{
    auto i = std::find_if(std::begin(mappingBMCBMCState),
                          std::end(mappingBMCBMCState),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingBMCBMCState))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t BMC::_vtable[] = {
    vtable::start(),
    vtable::property("RequestedBMCTransition",
                     details::BMC::_property_RequestedBMCTransition.data(),
                     _callback_get_RequestedBMCTransition,
                     _callback_set_RequestedBMCTransition,
                     vtable::property_::emits_change),
    vtable::property(
        "CurrentBMCState", details::BMC::_property_CurrentBMCState.data(),
        _callback_get_CurrentBMCState, _callback_set_CurrentBMCState,
        vtable::property_::emits_change),
    vtable::property("LastRebootTime",
                     details::BMC::_property_LastRebootTime.data(),
                     _callback_get_LastRebootTime, _callback_set_LastRebootTime,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/State/PowerOnHours/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace server
{

PowerOnHours::PowerOnHours(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_PowerOnHours_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

PowerOnHours::PowerOnHours(bus::bus& bus, const char* path,
                           const std::map<std::string, PropertiesVariant>& vals,
                           bool skipSignal) :
    PowerOnHours(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto PowerOnHours::pOHCounter() const -> uint32_t
{
    return _pOHCounter;
}

int PowerOnHours::_callback_get_POHCounter(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PowerOnHours*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->pOHCounter()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PowerOnHours::pOHCounter(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_pOHCounter != value)
    {
        _pOHCounter = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_PowerOnHours_interface.property_changed(
                "POHCounter");
        }
    }

    return _pOHCounter;
}

auto PowerOnHours::pOHCounter(uint32_t val) -> uint32_t
{
    return pOHCounter(val, false);
}
int PowerOnHours::_callback_set_POHCounter(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<PowerOnHours*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->pOHCounter(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PowerOnHours
{
static const auto _property_POHCounter =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

void PowerOnHours::setPropertyByName(const std::string& _name,
                                     const PropertiesVariant& val,
                                     bool skipSignal)
{
    if (_name == "POHCounter")
    {
        auto& v = std::get<uint32_t>(val);
        pOHCounter(v, skipSignal);
        return;
    }
}

auto PowerOnHours::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "POHCounter")
    {
        return pOHCounter();
    }

    return PropertiesVariant();
}

const vtable::vtable_t PowerOnHours::_vtable[] = {
    vtable::start(),
    vtable::property("POHCounter",
                     details::PowerOnHours::_property_POHCounter.data(),
                     _callback_get_POHCounter, _callback_set_POHCounter,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/State/Chassis/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace server
{

Chassis::Chassis(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_Chassis_interface(bus, path, _interface, _vtable,
                                                 this),
    _intf(bus.getInterface())
{
}

Chassis::Chassis(bus::bus& bus, const char* path,
                 const std::map<std::string, PropertiesVariant>& vals,
                 bool skipSignal) :
    Chassis(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Chassis::requestedPowerTransition() const -> Transition
{
    return _requestedPowerTransition;
}

int Chassis::_callback_get_RequestedPowerTransition(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Chassis*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->requestedPowerTransition()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Chassis::requestedPowerTransition(Transition value, bool skipSignal)
    -> Transition
{
    if (_requestedPowerTransition != value)
    {
        _requestedPowerTransition = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Chassis_interface.property_changed(
                "RequestedPowerTransition");
        }
    }

    return _requestedPowerTransition;
}

auto Chassis::requestedPowerTransition(Transition val) -> Transition
{
    return requestedPowerTransition(val, false);
}
int Chassis::_callback_set_RequestedPowerTransition(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Chassis*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->requestedPowerTransition(convertTransitionFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Chassis
{
static const auto _property_RequestedPowerTransition =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Chassis::currentPowerState() const -> PowerState
{
    return _currentPowerState;
}

int Chassis::_callback_get_CurrentPowerState(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Chassis*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->currentPowerState()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Chassis::currentPowerState(PowerState value, bool skipSignal) -> PowerState
{
    if (_currentPowerState != value)
    {
        _currentPowerState = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Chassis_interface.property_changed(
                "CurrentPowerState");
        }
    }

    return _currentPowerState;
}

auto Chassis::currentPowerState(PowerState val) -> PowerState
{
    return currentPowerState(val, false);
}
int Chassis::_callback_set_CurrentPowerState(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<Chassis*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->currentPowerState(convertPowerStateFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Chassis
{
static const auto _property_CurrentPowerState =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Chassis::lastStateChangeTime() const -> uint64_t
{
    return _lastStateChangeTime;
}

int Chassis::_callback_get_LastStateChangeTime(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Chassis*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->lastStateChangeTime()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Chassis::lastStateChangeTime(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_lastStateChangeTime != value)
    {
        _lastStateChangeTime = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Chassis_interface.property_changed(
                "LastStateChangeTime");
        }
    }

    return _lastStateChangeTime;
}

auto Chassis::lastStateChangeTime(uint64_t val) -> uint64_t
{
    return lastStateChangeTime(val, false);
}
int Chassis::_callback_set_LastStateChangeTime(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Chassis*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->lastStateChangeTime(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Chassis
{
static const auto _property_LastStateChangeTime =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

void Chassis::setPropertyByName(const std::string& _name,
                                const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "RequestedPowerTransition")
    {
        auto& v = std::get<Transition>(val);
        requestedPowerTransition(v, skipSignal);
        return;
    }
    if (_name == "CurrentPowerState")
    {
        auto& v = std::get<PowerState>(val);
        currentPowerState(v, skipSignal);
        return;
    }
    if (_name == "LastStateChangeTime")
    {
        auto& v = std::get<uint64_t>(val);
        lastStateChangeTime(v, skipSignal);
        return;
    }
}

auto Chassis::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "RequestedPowerTransition")
    {
        return requestedPowerTransition();
    }
    if (_name == "CurrentPowerState")
    {
        return currentPowerState();
    }
    if (_name == "LastStateChangeTime")
    {
        return lastStateChangeTime();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Chassis::Transition */
static const std::tuple<const char*, Chassis::Transition>
    mappingChassisTransition[] = {
        std::make_tuple("xyz.openbmc_project.State.Chassis.Transition.Off",
                        Chassis::Transition::Off),
        std::make_tuple("xyz.openbmc_project.State.Chassis.Transition.On",
                        Chassis::Transition::On),
};

} // anonymous namespace

auto Chassis::convertTransitionFromString(const std::string& s) -> Transition
{
    auto i = std::find_if(std::begin(mappingChassisTransition),
                          std::end(mappingChassisTransition), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingChassisTransition) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Chassis::Transition v)
{
    auto i = std::find_if(std::begin(mappingChassisTransition),
                          std::end(mappingChassisTransition),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingChassisTransition))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Chassis::PowerState */
static const std::tuple<const char*, Chassis::PowerState>
    mappingChassisPowerState[] = {
        std::make_tuple("xyz.openbmc_project.State.Chassis.PowerState.Off",
                        Chassis::PowerState::Off),
        std::make_tuple("xyz.openbmc_project.State.Chassis.PowerState.On",
                        Chassis::PowerState::On),
};

} // anonymous namespace

auto Chassis::convertPowerStateFromString(const std::string& s) -> PowerState
{
    auto i = std::find_if(std::begin(mappingChassisPowerState),
                          std::end(mappingChassisPowerState), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingChassisPowerState) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Chassis::PowerState v)
{
    auto i = std::find_if(std::begin(mappingChassisPowerState),
                          std::end(mappingChassisPowerState),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingChassisPowerState))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Chassis::_vtable[] = {
    vtable::start(),
    vtable::property(
        "RequestedPowerTransition",
        details::Chassis::_property_RequestedPowerTransition.data(),
        _callback_get_RequestedPowerTransition,
        _callback_set_RequestedPowerTransition,
        vtable::property_::emits_change),
    vtable::property("CurrentPowerState",
                     details::Chassis::_property_CurrentPowerState.data(),
                     _callback_get_CurrentPowerState,
                     _callback_set_CurrentPowerState,
                     vtable::property_::emits_change),
    vtable::property("LastStateChangeTime",
                     details::Chassis::_property_LastStateChangeTime.data(),
                     _callback_get_LastStateChangeTime,
                     _callback_set_LastStateChangeTime,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/State/Watchdog/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace server
{

Watchdog::Watchdog(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_Watchdog_interface(bus, path, _interface,
                                                  _vtable, this),
    _intf(bus.getInterface())
{
}

Watchdog::Watchdog(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    Watchdog(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

int Watchdog::_callback_ResetTimeRemaining(sd_bus_message* msg, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool enableWatchdog{};

        m.read(enableWatchdog);

        auto o = static_cast<Watchdog*>(context);
        o->resetTimeRemaining(enableWatchdog);

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Watchdog
{
static const auto _param_ResetTimeRemaining =
    utility::tuple_to_array(message::types::type_id<bool>());
static const auto _return_ResetTimeRemaining =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Watchdog
} // namespace details

auto Watchdog::initialized() const -> bool
{
    return _initialized;
}

int Watchdog::_callback_get_Initialized(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->initialized()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Watchdog::initialized(bool value, bool skipSignal) -> bool
{
    if (_initialized != value)
    {
        _initialized = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Watchdog_interface.property_changed(
                "Initialized");
        }
    }

    return _initialized;
}

auto Watchdog::initialized(bool val) -> bool
{
    return initialized(val, false);
}
int Watchdog::_callback_set_Initialized(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->initialized(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Watchdog
{
static const auto _property_Initialized =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Watchdog::enabled() const -> bool
{
    return _enabled;
}

int Watchdog::_callback_get_Enabled(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* reply, void* context,
                                    sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->enabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Watchdog::enabled(bool value, bool skipSignal) -> bool
{
    if (_enabled != value)
    {
        _enabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Watchdog_interface.property_changed(
                "Enabled");
        }
    }

    return _enabled;
}

auto Watchdog::enabled(bool val) -> bool
{
    return enabled(val, false);
}
int Watchdog::_callback_set_Enabled(sd_bus* bus, const char* path,
                                    const char* interface, const char* property,
                                    sd_bus_message* value, void* context,
                                    sd_bus_error* error)
{
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->enabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Watchdog
{
static const auto _property_Enabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Watchdog::expireAction() const -> Action
{
    return _expireAction;
}

int Watchdog::_callback_get_ExpireAction(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->expireAction()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Watchdog::expireAction(Action value, bool skipSignal) -> Action
{
    if (_expireAction != value)
    {
        _expireAction = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Watchdog_interface.property_changed(
                "ExpireAction");
        }
    }

    return _expireAction;
}

auto Watchdog::expireAction(Action val) -> Action
{
    return expireAction(val, false);
}
int Watchdog::_callback_set_ExpireAction(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->expireAction(convertActionFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Watchdog
{
static const auto _property_ExpireAction =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Watchdog::interval() const -> uint64_t
{
    return _interval;
}

int Watchdog::_callback_get_Interval(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->interval()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Watchdog::interval(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_interval != value)
    {
        _interval = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Watchdog_interface.property_changed(
                "Interval");
        }
    }

    return _interval;
}

auto Watchdog::interval(uint64_t val) -> uint64_t
{
    return interval(val, false);
}
int Watchdog::_callback_set_Interval(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->interval(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Watchdog
{
static const auto _property_Interval =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

auto Watchdog::timeRemaining() const -> uint64_t
{
    return _timeRemaining;
}

int Watchdog::_callback_get_TimeRemaining(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* reply, void* context,
                                          sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->timeRemaining()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Watchdog::timeRemaining(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_timeRemaining != value)
    {
        _timeRemaining = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Watchdog_interface.property_changed(
                "TimeRemaining");
        }
    }

    return _timeRemaining;
}

auto Watchdog::timeRemaining(uint64_t val) -> uint64_t
{
    return timeRemaining(val, false);
}
int Watchdog::_callback_set_TimeRemaining(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* value, void* context,
                                          sd_bus_error* error)
{
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->timeRemaining(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Watchdog
{
static const auto _property_TimeRemaining =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

auto Watchdog::currentTimerUse() const -> TimerUse
{
    return _currentTimerUse;
}

int Watchdog::_callback_get_CurrentTimerUse(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->currentTimerUse()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Watchdog::currentTimerUse(TimerUse value, bool skipSignal) -> TimerUse
{
    if (_currentTimerUse != value)
    {
        _currentTimerUse = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Watchdog_interface.property_changed(
                "CurrentTimerUse");
        }
    }

    return _currentTimerUse;
}

auto Watchdog::currentTimerUse(TimerUse val) -> TimerUse
{
    return currentTimerUse(val, false);
}
int Watchdog::_callback_set_CurrentTimerUse(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->currentTimerUse(convertTimerUseFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Watchdog
{
static const auto _property_CurrentTimerUse =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Watchdog::expiredTimerUse() const -> TimerUse
{
    return _expiredTimerUse;
}

int Watchdog::_callback_get_ExpiredTimerUse(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->expiredTimerUse()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Watchdog::expiredTimerUse(TimerUse value, bool skipSignal) -> TimerUse
{
    if (_expiredTimerUse != value)
    {
        _expiredTimerUse = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Watchdog_interface.property_changed(
                "ExpiredTimerUse");
        }
    }

    return _expiredTimerUse;
}

auto Watchdog::expiredTimerUse(TimerUse val) -> TimerUse
{
    return expiredTimerUse(val, false);
}
int Watchdog::_callback_set_ExpiredTimerUse(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<Watchdog*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->expiredTimerUse(convertTimerUseFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Watchdog
{
static const auto _property_ExpiredTimerUse =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Watchdog::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Initialized")
    {
        auto& v = std::get<bool>(val);
        initialized(v, skipSignal);
        return;
    }
    if (_name == "Enabled")
    {
        auto& v = std::get<bool>(val);
        enabled(v, skipSignal);
        return;
    }
    if (_name == "ExpireAction")
    {
        auto& v = std::get<Action>(val);
        expireAction(v, skipSignal);
        return;
    }
    if (_name == "Interval")
    {
        auto& v = std::get<uint64_t>(val);
        interval(v, skipSignal);
        return;
    }
    if (_name == "TimeRemaining")
    {
        auto& v = std::get<uint64_t>(val);
        timeRemaining(v, skipSignal);
        return;
    }
    if (_name == "CurrentTimerUse")
    {
        auto& v = std::get<TimerUse>(val);
        currentTimerUse(v, skipSignal);
        return;
    }
    if (_name == "ExpiredTimerUse")
    {
        auto& v = std::get<TimerUse>(val);
        expiredTimerUse(v, skipSignal);
        return;
    }
}

auto Watchdog::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Initialized")
    {
        return initialized();
    }
    if (_name == "Enabled")
    {
        return enabled();
    }
    if (_name == "ExpireAction")
    {
        return expireAction();
    }
    if (_name == "Interval")
    {
        return interval();
    }
    if (_name == "TimeRemaining")
    {
        return timeRemaining();
    }
    if (_name == "CurrentTimerUse")
    {
        return currentTimerUse();
    }
    if (_name == "ExpiredTimerUse")
    {
        return expiredTimerUse();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Watchdog::Action */
static const std::tuple<const char*, Watchdog::Action> mappingWatchdogAction[] =
    {
        std::make_tuple("xyz.openbmc_project.State.Watchdog.Action.None",
                        Watchdog::Action::None),
        std::make_tuple("xyz.openbmc_project.State.Watchdog.Action.HardReset",
                        Watchdog::Action::HardReset),
        std::make_tuple("xyz.openbmc_project.State.Watchdog.Action.PowerOff",
                        Watchdog::Action::PowerOff),
        std::make_tuple("xyz.openbmc_project.State.Watchdog.Action.PowerCycle",
                        Watchdog::Action::PowerCycle),
};

} // anonymous namespace

auto Watchdog::convertActionFromString(const std::string& s) -> Action
{
    auto i = std::find_if(
        std::begin(mappingWatchdogAction), std::end(mappingWatchdogAction),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingWatchdogAction) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Watchdog::Action v)
{
    auto i = std::find_if(std::begin(mappingWatchdogAction),
                          std::end(mappingWatchdogAction),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingWatchdogAction))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Watchdog::TimerUse */
static const std::tuple<const char*, Watchdog::TimerUse>
    mappingWatchdogTimerUse[] = {
        std::make_tuple("xyz.openbmc_project.State.Watchdog.TimerUse.Reserved",
                        Watchdog::TimerUse::Reserved),
        std::make_tuple("xyz.openbmc_project.State.Watchdog.TimerUse.BIOSFRB2",
                        Watchdog::TimerUse::BIOSFRB2),
        std::make_tuple("xyz.openbmc_project.State.Watchdog.TimerUse.BIOSPOST",
                        Watchdog::TimerUse::BIOSPOST),
        std::make_tuple("xyz.openbmc_project.State.Watchdog.TimerUse.OSLoad",
                        Watchdog::TimerUse::OSLoad),
        std::make_tuple("xyz.openbmc_project.State.Watchdog.TimerUse.SMSOS",
                        Watchdog::TimerUse::SMSOS),
        std::make_tuple("xyz.openbmc_project.State.Watchdog.TimerUse.OEM",
                        Watchdog::TimerUse::OEM),
};

} // anonymous namespace

auto Watchdog::convertTimerUseFromString(const std::string& s) -> TimerUse
{
    auto i = std::find_if(
        std::begin(mappingWatchdogTimerUse), std::end(mappingWatchdogTimerUse),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingWatchdogTimerUse) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Watchdog::TimerUse v)
{
    auto i = std::find_if(std::begin(mappingWatchdogTimerUse),
                          std::end(mappingWatchdogTimerUse),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingWatchdogTimerUse))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Watchdog::_vtable[] = {
    vtable::start(),

    vtable::method("ResetTimeRemaining",
                   details::Watchdog::_param_ResetTimeRemaining.data(),
                   details::Watchdog::_return_ResetTimeRemaining.data(),
                   _callback_ResetTimeRemaining),
    vtable::property("Initialized",
                     details::Watchdog::_property_Initialized.data(),
                     _callback_get_Initialized, _callback_set_Initialized,
                     vtable::property_::emits_change),
    vtable::property("Enabled", details::Watchdog::_property_Enabled.data(),
                     _callback_get_Enabled, _callback_set_Enabled,
                     vtable::property_::emits_change),
    vtable::property("ExpireAction",
                     details::Watchdog::_property_ExpireAction.data(),
                     _callback_get_ExpireAction, _callback_set_ExpireAction,
                     vtable::property_::emits_change),
    vtable::property("Interval", details::Watchdog::_property_Interval.data(),
                     _callback_get_Interval, _callback_set_Interval,
                     vtable::property_::emits_change),
    vtable::property("TimeRemaining",
                     details::Watchdog::_property_TimeRemaining.data(),
                     _callback_get_TimeRemaining, _callback_set_TimeRemaining,
                     vtable::property_::emits_change),
    vtable::property(
        "CurrentTimerUse", details::Watchdog::_property_CurrentTimerUse.data(),
        _callback_get_CurrentTimerUse, _callback_set_CurrentTimerUse,
        vtable::property_::emits_change),
    vtable::property(
        "ExpiredTimerUse", details::Watchdog::_property_ExpiredTimerUse.data(),
        _callback_get_ExpiredTimerUse, _callback_set_ExpiredTimerUse,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/State/Host/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace server
{

Host::Host(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_Host_interface(bus, path, _interface, _vtable,
                                              this),
    _intf(bus.getInterface())
{
}

Host::Host(bus::bus& bus, const char* path,
           const std::map<std::string, PropertiesVariant>& vals,
           bool skipSignal) :
    Host(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Host::requestedHostTransition() const -> Transition
{
    return _requestedHostTransition;
}

int Host::_callback_get_RequestedHostTransition(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Host*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->requestedHostTransition()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Host::requestedHostTransition(Transition value, bool skipSignal)
    -> Transition
{
    if (_requestedHostTransition != value)
    {
        _requestedHostTransition = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Host_interface.property_changed(
                "RequestedHostTransition");
        }
    }

    return _requestedHostTransition;
}

auto Host::requestedHostTransition(Transition val) -> Transition
{
    return requestedHostTransition(val, false);
}
int Host::_callback_set_RequestedHostTransition(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Host*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->requestedHostTransition(convertTransitionFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Host
{
static const auto _property_RequestedHostTransition =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Host::currentHostState() const -> HostState
{
    return _currentHostState;
}

int Host::_callback_get_CurrentHostState(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Host*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->currentHostState()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Host::currentHostState(HostState value, bool skipSignal) -> HostState
{
    if (_currentHostState != value)
    {
        _currentHostState = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Host_interface.property_changed(
                "CurrentHostState");
        }
    }

    return _currentHostState;
}

auto Host::currentHostState(HostState val) -> HostState
{
    return currentHostState(val, false);
}
int Host::_callback_set_CurrentHostState(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Host*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->currentHostState(convertHostStateFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Host
{
static const auto _property_CurrentHostState =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Host::setPropertyByName(const std::string& _name,
                             const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "RequestedHostTransition")
    {
        auto& v = std::get<Transition>(val);
        requestedHostTransition(v, skipSignal);
        return;
    }
    if (_name == "CurrentHostState")
    {
        auto& v = std::get<HostState>(val);
        currentHostState(v, skipSignal);
        return;
    }
}

auto Host::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "RequestedHostTransition")
    {
        return requestedHostTransition();
    }
    if (_name == "CurrentHostState")
    {
        return currentHostState();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Host::Transition */
static const std::tuple<const char*, Host::Transition> mappingHostTransition[] =
    {
        std::make_tuple("xyz.openbmc_project.State.Host.Transition.Off",
                        Host::Transition::Off),
        std::make_tuple("xyz.openbmc_project.State.Host.Transition.On",
                        Host::Transition::On),
        std::make_tuple("xyz.openbmc_project.State.Host.Transition.Reboot",
                        Host::Transition::Reboot),
};

} // anonymous namespace

auto Host::convertTransitionFromString(const std::string& s) -> Transition
{
    auto i = std::find_if(
        std::begin(mappingHostTransition), std::end(mappingHostTransition),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingHostTransition) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Host::Transition v)
{
    auto i = std::find_if(std::begin(mappingHostTransition),
                          std::end(mappingHostTransition),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingHostTransition))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Host::HostState */
static const std::tuple<const char*, Host::HostState> mappingHostHostState[] = {
    std::make_tuple("xyz.openbmc_project.State.Host.HostState.Off",
                    Host::HostState::Off),
    std::make_tuple("xyz.openbmc_project.State.Host.HostState.Running",
                    Host::HostState::Running),
    std::make_tuple("xyz.openbmc_project.State.Host.HostState.Quiesced",
                    Host::HostState::Quiesced),
};

} // anonymous namespace

auto Host::convertHostStateFromString(const std::string& s) -> HostState
{
    auto i = std::find_if(
        std::begin(mappingHostHostState), std::end(mappingHostHostState),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingHostHostState) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Host::HostState v)
{
    auto i = std::find_if(std::begin(mappingHostHostState),
                          std::end(mappingHostHostState),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingHostHostState))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Host::_vtable[] = {
    vtable::start(),
    vtable::property("RequestedHostTransition",
                     details::Host::_property_RequestedHostTransition.data(),
                     _callback_get_RequestedHostTransition,
                     _callback_set_RequestedHostTransition,
                     vtable::property_::emits_change),
    vtable::property(
        "CurrentHostState", details::Host::_property_CurrentHostState.data(),
        _callback_get_CurrentHostState, _callback_set_CurrentHostState,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/State/Boot/Progress/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Boot
{
namespace server
{

Progress::Progress(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_Boot_Progress_interface(bus, path, _interface,
                                                       _vtable, this),
    _intf(bus.getInterface())
{
}

Progress::Progress(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    Progress(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Progress::bootProgress() const -> ProgressStages
{
    return _bootProgress;
}

int Progress::_callback_get_BootProgress(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Progress*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->bootProgress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Progress::bootProgress(ProgressStages value, bool skipSignal)
    -> ProgressStages
{
    if (_bootProgress != value)
    {
        _bootProgress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Boot_Progress_interface.property_changed(
                "BootProgress");
        }
    }

    return _bootProgress;
}

auto Progress::bootProgress(ProgressStages val) -> ProgressStages
{
    return bootProgress(val, false);
}
int Progress::_callback_set_BootProgress(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Progress*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->bootProgress(convertProgressStagesFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Progress
{
static const auto _property_BootProgress =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Progress::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "BootProgress")
    {
        auto& v = std::get<ProgressStages>(val);
        bootProgress(v, skipSignal);
        return;
    }
}

auto Progress::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "BootProgress")
    {
        return bootProgress();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Progress::ProgressStages */
static const std::tuple<const char*, Progress::ProgressStages>
    mappingProgressProgressStages[] = {
        std::make_tuple("xyz.openbmc_project.State.Boot.Progress."
                        "ProgressStages.Unspecified",
                        Progress::ProgressStages::Unspecified),
        std::make_tuple(
            "xyz.openbmc_project.State.Boot.Progress.ProgressStages.MemoryInit",
            Progress::ProgressStages::MemoryInit),
        std::make_tuple("xyz.openbmc_project.State.Boot.Progress."
                        "ProgressStages.SecondaryProcInit",
                        Progress::ProgressStages::SecondaryProcInit),
        std::make_tuple(
            "xyz.openbmc_project.State.Boot.Progress.ProgressStages.PCIInit",
            Progress::ProgressStages::PCIInit),
        std::make_tuple(
            "xyz.openbmc_project.State.Boot.Progress.ProgressStages.OSStart",
            Progress::ProgressStages::OSStart),
        std::make_tuple("xyz.openbmc_project.State.Boot.Progress."
                        "ProgressStages.MotherboardInit",
                        Progress::ProgressStages::MotherboardInit),
};

} // anonymous namespace

auto Progress::convertProgressStagesFromString(const std::string& s)
    -> ProgressStages
{
    auto i =
        std::find_if(std::begin(mappingProgressProgressStages),
                     std::end(mappingProgressProgressStages), [&s](auto& e) {
                         return 0 == strcmp(s.c_str(), std::get<0>(e));
                     });
    if (std::end(mappingProgressProgressStages) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Progress::ProgressStages v)
{
    auto i = std::find_if(std::begin(mappingProgressProgressStages),
                          std::end(mappingProgressProgressStages),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingProgressProgressStages))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Progress::_vtable[] = {
    vtable::start(),
    vtable::property("BootProgress",
                     details::Progress::_property_BootProgress.data(),
                     _callback_get_BootProgress, _callback_set_BootProgress,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Boot
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/State/Boot/Raw/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Boot
{
namespace server
{

Raw::Raw(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_Boot_Raw_interface(bus, path, _interface,
                                                  _vtable, this),
    _intf(bus.getInterface())
{
}

Raw::Raw(bus::bus& bus, const char* path,
         const std::map<std::string, PropertiesVariant>& vals,
         bool skipSignal) :
    Raw(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Raw::value() const -> uint64_t
{
    return _value;
}

int Raw::_callback_get_Value(sd_bus* bus, const char* path,
                             const char* interface, const char* property,
                             sd_bus_message* reply, void* context,
                             sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Raw*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->value()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Raw::value(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_value != value)
    {
        _value = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Boot_Raw_interface.property_changed(
                "Value");
        }
    }

    return _value;
}

auto Raw::value(uint64_t val) -> uint64_t
{
    return value(val, false);
}
int Raw::_callback_set_Value(sd_bus* bus, const char* path,
                             const char* interface, const char* property,
                             sd_bus_message* value, void* context,
                             sd_bus_error* error)
{
    auto o = static_cast<Raw*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->value(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Raw
{
static const auto _property_Value =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

void Raw::setPropertyByName(const std::string& _name,
                            const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Value")
    {
        auto& v = std::get<uint64_t>(val);
        value(v, skipSignal);
        return;
    }
}

auto Raw::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Value")
    {
        return value();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Raw::_vtable[] = {
    vtable::start(),
    vtable::property("Value", details::Raw::_property_Value.data(),
                     _callback_get_Value, _callback_set_Value,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Boot
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/State/Decorator/OperationalStatus/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Decorator
{
namespace server
{

OperationalStatus::OperationalStatus(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_State_Decorator_OperationalStatus_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

OperationalStatus::OperationalStatus(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    OperationalStatus(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto OperationalStatus::functional() const -> bool
{
    return _functional;
}

int OperationalStatus::_callback_get_Functional(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<OperationalStatus*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->functional()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto OperationalStatus::functional(bool value, bool skipSignal) -> bool
{
    if (_functional != value)
    {
        _functional = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_State_Decorator_OperationalStatus_interface
                .property_changed("Functional");
        }
    }

    return _functional;
}

auto OperationalStatus::functional(bool val) -> bool
{
    return functional(val, false);
}
int OperationalStatus::_callback_set_Functional(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<OperationalStatus*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->functional(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace OperationalStatus
{
static const auto _property_Functional =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void OperationalStatus::setPropertyByName(const std::string& _name,
                                          const PropertiesVariant& val,
                                          bool skipSignal)
{
    if (_name == "Functional")
    {
        auto& v = std::get<bool>(val);
        functional(v, skipSignal);
        return;
    }
}

auto OperationalStatus::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "Functional")
    {
        return functional();
    }

    return PropertiesVariant();
}

const vtable::vtable_t OperationalStatus::_vtable[] = {
    vtable::start(),
    vtable::property("Functional",
                     details::OperationalStatus::_property_Functional.data(),
                     _callback_get_Functional, _callback_set_Functional,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Decorator
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/User/Ldap/Create/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Ldap
{
namespace server
{

Create::Create(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_User_Ldap_Create_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

int Create::_callback_CreateConfig(sd_bus_message* msg, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string lDAPServerURI{};
        std::string lDAPBindDN{};
        std::string lDAPBaseDN{};
        std::string lDAPBINDDNpassword{};
        std::string lDAPSearchScope{};
        std::string lDAPType{};
        std::string groupNameAttribute{};
        std::string usernameAttribute{};

        m.read(lDAPServerURI, lDAPBindDN, lDAPBaseDN, lDAPBINDDNpassword,
               lDAPSearchScope, lDAPType, groupNameAttribute,
               usernameAttribute);

        auto o = static_cast<Create*>(context);
        auto r = o->createConfig(lDAPServerURI, lDAPBindDN, lDAPBaseDN,
                                 lDAPBINDDNpassword,
                                 convertSearchScopeFromString(lDAPSearchScope),
                                 convertTypeFromString(lDAPType),
                                 groupNameAttribute, usernameAttribute);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NoCACertificate& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Create
{
static const auto _param_CreateConfig = utility::tuple_to_array(
    message::types::type_id<std::string, std::string, std::string, std::string,
                            std::string, std::string, std::string,
                            std::string>());
static const auto _return_CreateConfig =
    utility::tuple_to_array(message::types::type_id<std::string>());
} // namespace Create
} // namespace details

namespace
{
/** String to enum mapping for Create::SearchScope */
static const std::tuple<const char*, Create::SearchScope>
    mappingCreateSearchScope[] = {
        std::make_tuple("xyz.openbmc_project.User.Ldap.Create.SearchScope.sub",
                        Create::SearchScope::sub),
        std::make_tuple("xyz.openbmc_project.User.Ldap.Create.SearchScope.one",
                        Create::SearchScope::one),
        std::make_tuple("xyz.openbmc_project.User.Ldap.Create.SearchScope.base",
                        Create::SearchScope::base),
};

} // anonymous namespace

auto Create::convertSearchScopeFromString(const std::string& s) -> SearchScope
{
    auto i = std::find_if(std::begin(mappingCreateSearchScope),
                          std::end(mappingCreateSearchScope), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingCreateSearchScope) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Create::SearchScope v)
{
    auto i = std::find_if(std::begin(mappingCreateSearchScope),
                          std::end(mappingCreateSearchScope),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingCreateSearchScope))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Create::Type */
static const std::tuple<const char*, Create::Type> mappingCreateType[] = {
    std::make_tuple("xyz.openbmc_project.User.Ldap.Create.Type.ActiveDirectory",
                    Create::Type::ActiveDirectory),
    std::make_tuple("xyz.openbmc_project.User.Ldap.Create.Type.OpenLdap",
                    Create::Type::OpenLdap),
};

} // anonymous namespace

auto Create::convertTypeFromString(const std::string& s) -> Type
{
    auto i = std::find_if(
        std::begin(mappingCreateType), std::end(mappingCreateType),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingCreateType) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Create::Type v)
{
    auto i =
        std::find_if(std::begin(mappingCreateType), std::end(mappingCreateType),
                     [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingCreateType))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Create::_vtable[] = {
    vtable::start(),

    vtable::method("CreateConfig", details::Create::_param_CreateConfig.data(),
                   details::Create::_return_CreateConfig.data(),
                   _callback_CreateConfig),
    vtable::end()};

} // namespace server
} // namespace Ldap
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/User/Ldap/Config/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Ldap
{
namespace server
{

Config::Config(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_User_Ldap_Config_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

Config::Config(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    Config(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Config::lDAPServerURI() const -> std::string
{
    return _lDAPServerURI;
}

int Config::_callback_get_LDAPServerURI(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->lDAPServerURI()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NoCACertificate& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Config::lDAPServerURI(std::string value, bool skipSignal) -> std::string
{
    if (_lDAPServerURI != value)
    {
        _lDAPServerURI = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Ldap_Config_interface.property_changed(
                "LDAPServerURI");
        }
    }

    return _lDAPServerURI;
}

auto Config::lDAPServerURI(std::string val) -> std::string
{
    return lDAPServerURI(val, false);
}
int Config::_callback_set_LDAPServerURI(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->lDAPServerURI(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NoCACertificate& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Config
{
static const auto _property_LDAPServerURI =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Config::lDAPBindDN() const -> std::string
{
    return _lDAPBindDN;
}

int Config::_callback_get_LDAPBindDN(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->lDAPBindDN()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Config::lDAPBindDN(std::string value, bool skipSignal) -> std::string
{
    if (_lDAPBindDN != value)
    {
        _lDAPBindDN = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Ldap_Config_interface.property_changed(
                "LDAPBindDN");
        }
    }

    return _lDAPBindDN;
}

auto Config::lDAPBindDN(std::string val) -> std::string
{
    return lDAPBindDN(val, false);
}
int Config::_callback_set_LDAPBindDN(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->lDAPBindDN(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Config
{
static const auto _property_LDAPBindDN =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Config::lDAPBindDNPassword() const -> std::string
{
    return _lDAPBindDNPassword;
}

int Config::_callback_get_LDAPBindDNPassword(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->lDAPBindDNPassword()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Config::lDAPBindDNPassword(std::string value, bool skipSignal)
    -> std::string
{
    if (_lDAPBindDNPassword != value)
    {
        _lDAPBindDNPassword = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Ldap_Config_interface.property_changed(
                "LDAPBindDNPassword");
        }
    }

    return _lDAPBindDNPassword;
}

auto Config::lDAPBindDNPassword(std::string val) -> std::string
{
    return lDAPBindDNPassword(val, false);
}
int Config::_callback_set_LDAPBindDNPassword(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->lDAPBindDNPassword(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Config
{
static const auto _property_LDAPBindDNPassword =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Config::lDAPBaseDN() const -> std::string
{
    return _lDAPBaseDN;
}

int Config::_callback_get_LDAPBaseDN(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->lDAPBaseDN()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Config::lDAPBaseDN(std::string value, bool skipSignal) -> std::string
{
    if (_lDAPBaseDN != value)
    {
        _lDAPBaseDN = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Ldap_Config_interface.property_changed(
                "LDAPBaseDN");
        }
    }

    return _lDAPBaseDN;
}

auto Config::lDAPBaseDN(std::string val) -> std::string
{
    return lDAPBaseDN(val, false);
}
int Config::_callback_set_LDAPBaseDN(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->lDAPBaseDN(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Config
{
static const auto _property_LDAPBaseDN =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Config::lDAPSearchScope() const -> SearchScope
{
    return _lDAPSearchScope;
}

int Config::_callback_get_LDAPSearchScope(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* reply, void* context,
                                          sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->lDAPSearchScope()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Config::lDAPSearchScope(SearchScope value, bool skipSignal) -> SearchScope
{
    if (_lDAPSearchScope != value)
    {
        _lDAPSearchScope = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Ldap_Config_interface.property_changed(
                "LDAPSearchScope");
        }
    }

    return _lDAPSearchScope;
}

auto Config::lDAPSearchScope(SearchScope val) -> SearchScope
{
    return lDAPSearchScope(val, false);
}
int Config::_callback_set_LDAPSearchScope(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* value, void* context,
                                          sd_bus_error* error)
{
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->lDAPSearchScope(convertSearchScopeFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Config
{
static const auto _property_LDAPSearchScope =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Config::lDAPType() const -> Type
{
    return _lDAPType;
}

int Config::_callback_get_LDAPType(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->lDAPType()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Config::lDAPType(Type value, bool skipSignal) -> Type
{
    if (_lDAPType != value)
    {
        _lDAPType = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Ldap_Config_interface.property_changed(
                "LDAPType");
        }
    }

    return _lDAPType;
}

auto Config::lDAPType(Type val) -> Type
{
    return lDAPType(val, false);
}
int Config::_callback_set_LDAPType(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->lDAPType(convertTypeFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Config
{
static const auto _property_LDAPType =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Config::groupNameAttribute() const -> std::string
{
    return _groupNameAttribute;
}

int Config::_callback_get_GroupNameAttribute(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->groupNameAttribute()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Config::groupNameAttribute(std::string value, bool skipSignal)
    -> std::string
{
    if (_groupNameAttribute != value)
    {
        _groupNameAttribute = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Ldap_Config_interface.property_changed(
                "GroupNameAttribute");
        }
    }

    return _groupNameAttribute;
}

auto Config::groupNameAttribute(std::string val) -> std::string
{
    return groupNameAttribute(val, false);
}
int Config::_callback_set_GroupNameAttribute(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->groupNameAttribute(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Config
{
static const auto _property_GroupNameAttribute =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Config::userNameAttribute() const -> std::string
{
    return _userNameAttribute;
}

int Config::_callback_get_UserNameAttribute(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->userNameAttribute()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Config::userNameAttribute(std::string value, bool skipSignal)
    -> std::string
{
    if (_userNameAttribute != value)
    {
        _userNameAttribute = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Ldap_Config_interface.property_changed(
                "UserNameAttribute");
        }
    }

    return _userNameAttribute;
}

auto Config::userNameAttribute(std::string val) -> std::string
{
    return userNameAttribute(val, false);
}
int Config::_callback_set_UserNameAttribute(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<Config*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->userNameAttribute(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Config
{
static const auto _property_UserNameAttribute =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Config::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "LDAPServerURI")
    {
        auto& v = std::get<std::string>(val);
        lDAPServerURI(v, skipSignal);
        return;
    }
    if (_name == "LDAPBindDN")
    {
        auto& v = std::get<std::string>(val);
        lDAPBindDN(v, skipSignal);
        return;
    }
    if (_name == "LDAPBindDNPassword")
    {
        auto& v = std::get<std::string>(val);
        lDAPBindDNPassword(v, skipSignal);
        return;
    }
    if (_name == "LDAPBaseDN")
    {
        auto& v = std::get<std::string>(val);
        lDAPBaseDN(v, skipSignal);
        return;
    }
    if (_name == "LDAPSearchScope")
    {
        auto& v = std::get<SearchScope>(val);
        lDAPSearchScope(v, skipSignal);
        return;
    }
    if (_name == "LDAPType")
    {
        auto& v = std::get<Type>(val);
        lDAPType(v, skipSignal);
        return;
    }
    if (_name == "GroupNameAttribute")
    {
        auto& v = std::get<std::string>(val);
        groupNameAttribute(v, skipSignal);
        return;
    }
    if (_name == "UserNameAttribute")
    {
        auto& v = std::get<std::string>(val);
        userNameAttribute(v, skipSignal);
        return;
    }
}

auto Config::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "LDAPServerURI")
    {
        return lDAPServerURI();
    }
    if (_name == "LDAPBindDN")
    {
        return lDAPBindDN();
    }
    if (_name == "LDAPBindDNPassword")
    {
        return lDAPBindDNPassword();
    }
    if (_name == "LDAPBaseDN")
    {
        return lDAPBaseDN();
    }
    if (_name == "LDAPSearchScope")
    {
        return lDAPSearchScope();
    }
    if (_name == "LDAPType")
    {
        return lDAPType();
    }
    if (_name == "GroupNameAttribute")
    {
        return groupNameAttribute();
    }
    if (_name == "UserNameAttribute")
    {
        return userNameAttribute();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Config::SearchScope */
static const std::tuple<const char*, Config::SearchScope>
    mappingConfigSearchScope[] = {
        std::make_tuple("xyz.openbmc_project.User.Ldap.Config.SearchScope.sub",
                        Config::SearchScope::sub),
        std::make_tuple("xyz.openbmc_project.User.Ldap.Config.SearchScope.one",
                        Config::SearchScope::one),
        std::make_tuple("xyz.openbmc_project.User.Ldap.Config.SearchScope.base",
                        Config::SearchScope::base),
};

} // anonymous namespace

auto Config::convertSearchScopeFromString(const std::string& s) -> SearchScope
{
    auto i = std::find_if(std::begin(mappingConfigSearchScope),
                          std::end(mappingConfigSearchScope), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingConfigSearchScope) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Config::SearchScope v)
{
    auto i = std::find_if(std::begin(mappingConfigSearchScope),
                          std::end(mappingConfigSearchScope),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingConfigSearchScope))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Config::Type */
static const std::tuple<const char*, Config::Type> mappingConfigType[] = {
    std::make_tuple("xyz.openbmc_project.User.Ldap.Config.Type.ActiveDirectory",
                    Config::Type::ActiveDirectory),
    std::make_tuple("xyz.openbmc_project.User.Ldap.Config.Type.OpenLdap",
                    Config::Type::OpenLdap),
};

} // anonymous namespace

auto Config::convertTypeFromString(const std::string& s) -> Type
{
    auto i = std::find_if(
        std::begin(mappingConfigType), std::end(mappingConfigType),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingConfigType) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Config::Type v)
{
    auto i =
        std::find_if(std::begin(mappingConfigType), std::end(mappingConfigType),
                     [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingConfigType))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Config::_vtable[] = {
    vtable::start(),
    vtable::property("LDAPServerURI",
                     details::Config::_property_LDAPServerURI.data(),
                     _callback_get_LDAPServerURI, _callback_set_LDAPServerURI,
                     vtable::property_::emits_change),
    vtable::property("LDAPBindDN", details::Config::_property_LDAPBindDN.data(),
                     _callback_get_LDAPBindDN, _callback_set_LDAPBindDN,
                     vtable::property_::emits_change),
    vtable::property("LDAPBindDNPassword",
                     details::Config::_property_LDAPBindDNPassword.data(),
                     _callback_get_LDAPBindDNPassword,
                     _callback_set_LDAPBindDNPassword,
                     vtable::property_::emits_change),
    vtable::property("LDAPBaseDN", details::Config::_property_LDAPBaseDN.data(),
                     _callback_get_LDAPBaseDN, _callback_set_LDAPBaseDN,
                     vtable::property_::emits_change),
    vtable::property(
        "LDAPSearchScope", details::Config::_property_LDAPSearchScope.data(),
        _callback_get_LDAPSearchScope, _callback_set_LDAPSearchScope,
        vtable::property_::emits_change),
    vtable::property("LDAPType", details::Config::_property_LDAPType.data(),
                     _callback_get_LDAPType, _callback_set_LDAPType,
                     vtable::property_::emits_change),
    vtable::property("GroupNameAttribute",
                     details::Config::_property_GroupNameAttribute.data(),
                     _callback_get_GroupNameAttribute,
                     _callback_set_GroupNameAttribute,
                     vtable::property_::emits_change),
    vtable::property("UserNameAttribute",
                     details::Config::_property_UserNameAttribute.data(),
                     _callback_get_UserNameAttribute,
                     _callback_set_UserNameAttribute,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Ldap
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/User/Common/error.hpp>
#include <xyz/openbmc_project/User/Manager/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace server
{

Manager::Manager(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_User_Manager_interface(bus, path, _interface, _vtable,
                                                this),
    _intf(bus.getInterface())
{
}

Manager::Manager(bus::bus& bus, const char* path,
                 const std::map<std::string, PropertiesVariant>& vals,
                 bool skipSignal) :
    Manager(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

int Manager::_callback_CreateUser(sd_bus_message* msg, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string userName{};
        std::vector<std::string> groupNames{};
        std::string privilege{};
        bool enabled{};

        m.read(userName, groupNames, privilege, enabled);

        auto o = static_cast<Manager*>(context);
        o->createUser(userName, groupNames, privilege, enabled);

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::Common::Error::InsufficientPermission&
            e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::User::Common::Error::UserNameExists& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::User::Common::Error::UserNameGroupFail&
            e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::User::Common::Error::UserNamePrivFail&
            e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::User::Common::Error::NoResource& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Manager
{
static const auto _param_CreateUser = utility::tuple_to_array(
    message::types::type_id<std::string, std::vector<std::string>, std::string,
                            bool>());
static const auto _return_CreateUser =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Manager
} // namespace details

int Manager::_callback_RenameUser(sd_bus_message* msg, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string userName{};
        std::string newUserName{};

        m.read(userName, newUserName);

        auto o = static_cast<Manager*>(context);
        o->renameUser(userName, newUserName);

        auto reply = m.new_method_return();
        // No data to append on reply.

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::Common::Error::InsufficientPermission&
            e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::User::Common::Error::
               UserNameDoesNotExist& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::User::Common::Error::UserNameExists& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::User::Common::Error::UserNameGroupFail&
            e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::User::Common::Error::UserNamePrivFail&
            e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::User::Common::Error::NoResource& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Manager
{
static const auto _param_RenameUser = utility::tuple_to_array(
    message::types::type_id<std::string, std::string>());
static const auto _return_RenameUser =
    utility::tuple_to_array(std::make_tuple('\0'));
} // namespace Manager
} // namespace details

int Manager::_callback_GetUserInfo(sd_bus_message* msg, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string userName{};

        m.read(userName);

        auto o = static_cast<Manager*>(context);
        auto r = o->getUserInfo(userName);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::Common::Error::InsufficientPermission&
            e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::User::Common::Error::
               UserNameDoesNotExist& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Manager
{
static const auto _param_GetUserInfo =
    utility::tuple_to_array(message::types::type_id<std::string>());
static const auto _return_GetUserInfo = utility::tuple_to_array(
    message::types::type_id<
        std::map<std::string,
                 std::variant<std::string, std::vector<std::string>, bool>>>());
} // namespace Manager
} // namespace details

void Manager::userRenamed(std::string userName, std::string newUserName)
{
    using sdbusplus::server::binding::details::convertForMessage;

    auto& i = _xyz_openbmc_project_User_Manager_interface;
    auto m = i.new_signal("UserRenamed");

    m.append(convertForMessage(userName), convertForMessage(newUserName));
    m.signal_send();
}

namespace details
{
namespace Manager
{
static const auto _signal_UserRenamed = utility::tuple_to_array(
    message::types::type_id<std::string, std::string>());
}
} // namespace details

auto Manager::allPrivileges() const -> std::vector<std::string>
{
    return _allPrivileges;
}

int Manager::_callback_get_AllPrivileges(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Manager*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->allPrivileges()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Manager::allPrivileges(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_allPrivileges != value)
    {
        _allPrivileges = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Manager_interface.property_changed(
                "AllPrivileges");
        }
    }

    return _allPrivileges;
}

auto Manager::allPrivileges(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return allPrivileges(val, false);
}
int Manager::_callback_set_AllPrivileges(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Manager*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->allPrivileges(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Manager
{
static const auto _property_AllPrivileges = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto Manager::allGroups() const -> std::vector<std::string>
{
    return _allGroups;
}

int Manager::_callback_get_AllGroups(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Manager*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->allGroups()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Manager::allGroups(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_allGroups != value)
    {
        _allGroups = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Manager_interface.property_changed(
                "AllGroups");
        }
    }

    return _allGroups;
}

auto Manager::allGroups(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return allGroups(val, false);
}
int Manager::_callback_set_AllGroups(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<Manager*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->allGroups(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Manager
{
static const auto _property_AllGroups = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

void Manager::setPropertyByName(const std::string& _name,
                                const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "AllPrivileges")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        allPrivileges(v, skipSignal);
        return;
    }
    if (_name == "AllGroups")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        allGroups(v, skipSignal);
        return;
    }
}

auto Manager::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "AllPrivileges")
    {
        return allPrivileges();
    }
    if (_name == "AllGroups")
    {
        return allGroups();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Manager::_vtable[] = {
    vtable::start(),

    vtable::method("CreateUser", details::Manager::_param_CreateUser.data(),
                   details::Manager::_return_CreateUser.data(),
                   _callback_CreateUser),

    vtable::method("RenameUser", details::Manager::_param_RenameUser.data(),
                   details::Manager::_return_RenameUser.data(),
                   _callback_RenameUser),

    vtable::method("GetUserInfo", details::Manager::_param_GetUserInfo.data(),
                   details::Manager::_return_GetUserInfo.data(),
                   _callback_GetUserInfo),

    vtable::signal("UserRenamed", details::Manager::_signal_UserRenamed.data()),
    vtable::property("AllPrivileges",
                     details::Manager::_property_AllPrivileges.data(),
                     _callback_get_AllPrivileges, _callback_set_AllPrivileges,
                     vtable::property_::emits_change),
    vtable::property("AllGroups", details::Manager::_property_AllGroups.data(),
                     _callback_get_AllGroups, _callback_set_AllGroups,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/User/AccountPolicy/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace server
{

AccountPolicy::AccountPolicy(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_User_AccountPolicy_interface(bus, path, _interface,
                                                      _vtable, this),
    _intf(bus.getInterface())
{
}

AccountPolicy::AccountPolicy(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    AccountPolicy(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto AccountPolicy::maxLoginAttemptBeforeLockout() const -> uint16_t
{
    return _maxLoginAttemptBeforeLockout;
}

int AccountPolicy::_callback_get_MaxLoginAttemptBeforeLockout(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<AccountPolicy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->maxLoginAttemptBeforeLockout()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto AccountPolicy::maxLoginAttemptBeforeLockout(uint16_t value,
                                                 bool skipSignal) -> uint16_t
{
    if (_maxLoginAttemptBeforeLockout != value)
    {
        _maxLoginAttemptBeforeLockout = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_AccountPolicy_interface.property_changed(
                "MaxLoginAttemptBeforeLockout");
        }
    }

    return _maxLoginAttemptBeforeLockout;
}

auto AccountPolicy::maxLoginAttemptBeforeLockout(uint16_t val) -> uint16_t
{
    return maxLoginAttemptBeforeLockout(val, false);
}
int AccountPolicy::_callback_set_MaxLoginAttemptBeforeLockout(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<AccountPolicy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint16_t v{};
        m.read(v);
        o->maxLoginAttemptBeforeLockout(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace AccountPolicy
{
static const auto _property_MaxLoginAttemptBeforeLockout =
    utility::tuple_to_array(message::types::type_id<uint16_t>());
}
} // namespace details

auto AccountPolicy::accountUnlockTimeout() const -> uint32_t
{
    return _accountUnlockTimeout;
}

int AccountPolicy::_callback_get_AccountUnlockTimeout(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<AccountPolicy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->accountUnlockTimeout()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto AccountPolicy::accountUnlockTimeout(uint32_t value, bool skipSignal)
    -> uint32_t
{
    if (_accountUnlockTimeout != value)
    {
        _accountUnlockTimeout = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_AccountPolicy_interface.property_changed(
                "AccountUnlockTimeout");
        }
    }

    return _accountUnlockTimeout;
}

auto AccountPolicy::accountUnlockTimeout(uint32_t val) -> uint32_t
{
    return accountUnlockTimeout(val, false);
}
int AccountPolicy::_callback_set_AccountUnlockTimeout(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<AccountPolicy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->accountUnlockTimeout(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace AccountPolicy
{
static const auto _property_AccountUnlockTimeout =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto AccountPolicy::minPasswordLength() const -> uint8_t
{
    return _minPasswordLength;
}

int AccountPolicy::_callback_get_MinPasswordLength(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<AccountPolicy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->minPasswordLength()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto AccountPolicy::minPasswordLength(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_minPasswordLength != value)
    {
        _minPasswordLength = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_AccountPolicy_interface.property_changed(
                "MinPasswordLength");
        }
    }

    return _minPasswordLength;
}

auto AccountPolicy::minPasswordLength(uint8_t val) -> uint8_t
{
    return minPasswordLength(val, false);
}
int AccountPolicy::_callback_set_MinPasswordLength(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<AccountPolicy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->minPasswordLength(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace AccountPolicy
{
static const auto _property_MinPasswordLength =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto AccountPolicy::rememberOldPasswordTimes() const -> uint8_t
{
    return _rememberOldPasswordTimes;
}

int AccountPolicy::_callback_get_RememberOldPasswordTimes(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<AccountPolicy*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->rememberOldPasswordTimes()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto AccountPolicy::rememberOldPasswordTimes(uint8_t value, bool skipSignal)
    -> uint8_t
{
    if (_rememberOldPasswordTimes != value)
    {
        _rememberOldPasswordTimes = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_AccountPolicy_interface.property_changed(
                "RememberOldPasswordTimes");
        }
    }

    return _rememberOldPasswordTimes;
}

auto AccountPolicy::rememberOldPasswordTimes(uint8_t val) -> uint8_t
{
    return rememberOldPasswordTimes(val, false);
}
int AccountPolicy::_callback_set_RememberOldPasswordTimes(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<AccountPolicy*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->rememberOldPasswordTimes(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace AccountPolicy
{
static const auto _property_RememberOldPasswordTimes =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

void AccountPolicy::setPropertyByName(const std::string& _name,
                                      const PropertiesVariant& val,
                                      bool skipSignal)
{
    if (_name == "MaxLoginAttemptBeforeLockout")
    {
        auto& v = std::get<uint16_t>(val);
        maxLoginAttemptBeforeLockout(v, skipSignal);
        return;
    }
    if (_name == "AccountUnlockTimeout")
    {
        auto& v = std::get<uint32_t>(val);
        accountUnlockTimeout(v, skipSignal);
        return;
    }
    if (_name == "MinPasswordLength")
    {
        auto& v = std::get<uint8_t>(val);
        minPasswordLength(v, skipSignal);
        return;
    }
    if (_name == "RememberOldPasswordTimes")
    {
        auto& v = std::get<uint8_t>(val);
        rememberOldPasswordTimes(v, skipSignal);
        return;
    }
}

auto AccountPolicy::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "MaxLoginAttemptBeforeLockout")
    {
        return maxLoginAttemptBeforeLockout();
    }
    if (_name == "AccountUnlockTimeout")
    {
        return accountUnlockTimeout();
    }
    if (_name == "MinPasswordLength")
    {
        return minPasswordLength();
    }
    if (_name == "RememberOldPasswordTimes")
    {
        return rememberOldPasswordTimes();
    }

    return PropertiesVariant();
}

const vtable::vtable_t AccountPolicy::_vtable[] = {
    vtable::start(),
    vtable::property(
        "MaxLoginAttemptBeforeLockout",
        details::AccountPolicy::_property_MaxLoginAttemptBeforeLockout.data(),
        _callback_get_MaxLoginAttemptBeforeLockout,
        _callback_set_MaxLoginAttemptBeforeLockout,
        vtable::property_::emits_change),
    vtable::property(
        "AccountUnlockTimeout",
        details::AccountPolicy::_property_AccountUnlockTimeout.data(),
        _callback_get_AccountUnlockTimeout, _callback_set_AccountUnlockTimeout,
        vtable::property_::emits_change),
    vtable::property("MinPasswordLength",
                     details::AccountPolicy::_property_MinPasswordLength.data(),
                     _callback_get_MinPasswordLength,
                     _callback_set_MinPasswordLength,
                     vtable::property_::emits_change),
    vtable::property(
        "RememberOldPasswordTimes",
        details::AccountPolicy::_property_RememberOldPasswordTimes.data(),
        _callback_get_RememberOldPasswordTimes,
        _callback_set_RememberOldPasswordTimes,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/User/Common/error.hpp>
#include <xyz/openbmc_project/User/PrivilegeMapper/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace server
{

PrivilegeMapper::PrivilegeMapper(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_User_PrivilegeMapper_interface(bus, path, _interface,
                                                        _vtable, this),
    _intf(bus.getInterface())
{
}

int PrivilegeMapper::_callback_Create(sd_bus_message* msg, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string groupName{};
        std::string privilege{};

        m.read(groupName, privilege);

        auto o = static_cast<PrivilegeMapper*>(context);
        auto r = o->create(groupName, privilege);

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::User::Common::Error::
               PrivilegeMappingExists& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PrivilegeMapper
{
static const auto _param_Create = utility::tuple_to_array(
    message::types::type_id<std::string, std::string>());
static const auto _return_Create = utility::tuple_to_array(
    message::types::type_id<sdbusplus::message::object_path>());
} // namespace PrivilegeMapper
} // namespace details

const vtable::vtable_t PrivilegeMapper::_vtable[] = {
    vtable::start(),

    vtable::method("Create", details::PrivilegeMapper::_param_Create.data(),
                   details::PrivilegeMapper::_return_Create.data(),
                   _callback_Create),
    vtable::end()};

} // namespace server
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/User/Attributes/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace server
{

Attributes::Attributes(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_User_Attributes_interface(bus, path, _interface,
                                                   _vtable, this),
    _intf(bus.getInterface())
{
}

Attributes::Attributes(bus::bus& bus, const char* path,
                       const std::map<std::string, PropertiesVariant>& vals,
                       bool skipSignal) :
    Attributes(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Attributes::userGroups() const -> std::vector<std::string>
{
    return _userGroups;
}

int Attributes::_callback_get_UserGroups(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->userGroups()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Attributes::userGroups(std::vector<std::string> value, bool skipSignal)
    -> std::vector<std::string>
{
    if (_userGroups != value)
    {
        _userGroups = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Attributes_interface.property_changed(
                "UserGroups");
        }
    }

    return _userGroups;
}

auto Attributes::userGroups(std::vector<std::string> val)
    -> std::vector<std::string>
{
    return userGroups(val, false);
}
int Attributes::_callback_set_UserGroups(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<std::string> v{};
        m.read(v);
        o->userGroups(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Attributes
{
static const auto _property_UserGroups = utility::tuple_to_array(
    message::types::type_id<std::vector<std::string>>());
}
} // namespace details

auto Attributes::userPrivilege() const -> std::string
{
    return _userPrivilege;
}

int Attributes::_callback_get_UserPrivilege(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->userPrivilege()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Attributes::userPrivilege(std::string value, bool skipSignal)
    -> std::string
{
    if (_userPrivilege != value)
    {
        _userPrivilege = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Attributes_interface.property_changed(
                "UserPrivilege");
        }
    }

    return _userPrivilege;
}

auto Attributes::userPrivilege(std::string val) -> std::string
{
    return userPrivilege(val, false);
}
int Attributes::_callback_set_UserPrivilege(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->userPrivilege(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Attributes
{
static const auto _property_UserPrivilege =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Attributes::userEnabled() const -> bool
{
    return _userEnabled;
}

int Attributes::_callback_get_UserEnabled(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* reply, void* context,
                                          sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->userEnabled()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Attributes::userEnabled(bool value, bool skipSignal) -> bool
{
    if (_userEnabled != value)
    {
        _userEnabled = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Attributes_interface.property_changed(
                "UserEnabled");
        }
    }

    return _userEnabled;
}

auto Attributes::userEnabled(bool val) -> bool
{
    return userEnabled(val, false);
}
int Attributes::_callback_set_UserEnabled(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* value, void* context,
                                          sd_bus_error* error)
{
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->userEnabled(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Attributes
{
static const auto _property_UserEnabled =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Attributes::userLockedForFailedAttempt() const -> bool
{
    return _userLockedForFailedAttempt;
}

int Attributes::_callback_get_UserLockedForFailedAttempt(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->userLockedForFailedAttempt()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Attributes::userLockedForFailedAttempt(bool value, bool skipSignal) -> bool
{
    if (_userLockedForFailedAttempt != value)
    {
        _userLockedForFailedAttempt = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_Attributes_interface.property_changed(
                "UserLockedForFailedAttempt");
        }
    }

    return _userLockedForFailedAttempt;
}

auto Attributes::userLockedForFailedAttempt(bool val) -> bool
{
    return userLockedForFailedAttempt(val, false);
}
int Attributes::_callback_set_UserLockedForFailedAttempt(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Attributes*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->userLockedForFailedAttempt(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Attributes
{
static const auto _property_UserLockedForFailedAttempt =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Attributes::setPropertyByName(const std::string& _name,
                                   const PropertiesVariant& val,
                                   bool skipSignal)
{
    if (_name == "UserGroups")
    {
        auto& v = std::get<std::vector<std::string>>(val);
        userGroups(v, skipSignal);
        return;
    }
    if (_name == "UserPrivilege")
    {
        auto& v = std::get<std::string>(val);
        userPrivilege(v, skipSignal);
        return;
    }
    if (_name == "UserEnabled")
    {
        auto& v = std::get<bool>(val);
        userEnabled(v, skipSignal);
        return;
    }
    if (_name == "UserLockedForFailedAttempt")
    {
        auto& v = std::get<bool>(val);
        userLockedForFailedAttempt(v, skipSignal);
        return;
    }
}

auto Attributes::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "UserGroups")
    {
        return userGroups();
    }
    if (_name == "UserPrivilege")
    {
        return userPrivilege();
    }
    if (_name == "UserEnabled")
    {
        return userEnabled();
    }
    if (_name == "UserLockedForFailedAttempt")
    {
        return userLockedForFailedAttempt();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Attributes::_vtable[] = {
    vtable::start(),
    vtable::property("UserGroups",
                     details::Attributes::_property_UserGroups.data(),
                     _callback_get_UserGroups, _callback_set_UserGroups,
                     vtable::property_::emits_change),
    vtable::property("UserPrivilege",
                     details::Attributes::_property_UserPrivilege.data(),
                     _callback_get_UserPrivilege, _callback_set_UserPrivilege,
                     vtable::property_::emits_change),
    vtable::property("UserEnabled",
                     details::Attributes::_property_UserEnabled.data(),
                     _callback_get_UserEnabled, _callback_set_UserEnabled,
                     vtable::property_::emits_change),
    vtable::property(
        "UserLockedForFailedAttempt",
        details::Attributes::_property_UserLockedForFailedAttempt.data(),
        _callback_get_UserLockedForFailedAttempt,
        _callback_set_UserLockedForFailedAttempt,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/User/Common/error.hpp>
#include <xyz/openbmc_project/User/PrivilegeMapperEntry/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace server
{

PrivilegeMapperEntry::PrivilegeMapperEntry(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_User_PrivilegeMapperEntry_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

PrivilegeMapperEntry::PrivilegeMapperEntry(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    PrivilegeMapperEntry(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto PrivilegeMapperEntry::groupName() const -> std::string
{
    return _groupName;
}

int PrivilegeMapperEntry::_callback_get_GroupName(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PrivilegeMapperEntry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->groupName()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::User::Common::Error::
               PrivilegeMappingExists& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PrivilegeMapperEntry::groupName(std::string value, bool skipSignal)
    -> std::string
{
    if (_groupName != value)
    {
        _groupName = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_PrivilegeMapperEntry_interface
                .property_changed("GroupName");
        }
    }

    return _groupName;
}

auto PrivilegeMapperEntry::groupName(std::string val) -> std::string
{
    return groupName(val, false);
}
int PrivilegeMapperEntry::_callback_set_GroupName(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PrivilegeMapperEntry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->groupName(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::User::Common::Error::
               PrivilegeMappingExists& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PrivilegeMapperEntry
{
static const auto _property_GroupName =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto PrivilegeMapperEntry::privilege() const -> std::string
{
    return _privilege;
}

int PrivilegeMapperEntry::_callback_get_Privilege(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<PrivilegeMapperEntry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->privilege()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto PrivilegeMapperEntry::privilege(std::string value, bool skipSignal)
    -> std::string
{
    if (_privilege != value)
    {
        _privilege = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_User_PrivilegeMapperEntry_interface
                .property_changed("Privilege");
        }
    }

    return _privilege;
}

auto PrivilegeMapperEntry::privilege(std::string val) -> std::string
{
    return privilege(val, false);
}
int PrivilegeMapperEntry::_callback_set_Privilege(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<PrivilegeMapperEntry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->privilege(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace PrivilegeMapperEntry
{
static const auto _property_Privilege =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void PrivilegeMapperEntry::setPropertyByName(const std::string& _name,
                                             const PropertiesVariant& val,
                                             bool skipSignal)
{
    if (_name == "GroupName")
    {
        auto& v = std::get<std::string>(val);
        groupName(v, skipSignal);
        return;
    }
    if (_name == "Privilege")
    {
        auto& v = std::get<std::string>(val);
        privilege(v, skipSignal);
        return;
    }
}

auto PrivilegeMapperEntry::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "GroupName")
    {
        return groupName();
    }
    if (_name == "Privilege")
    {
        return privilege();
    }

    return PropertiesVariant();
}

const vtable::vtable_t PrivilegeMapperEntry::_vtable[] = {
    vtable::start(),
    vtable::property("GroupName",
                     details::PrivilegeMapperEntry::_property_GroupName.data(),
                     _callback_get_GroupName, _callback_set_GroupName,
                     vtable::property_::emits_change),
    vtable::property("Privilege",
                     details::PrivilegeMapperEntry::_property_Privilege.data(),
                     _callback_get_Privilege, _callback_set_Privilege,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Nvme/Status/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace server
{

Status::Status(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Nvme_Status_interface(bus, path, _interface, _vtable,
                                               this),
    _intf(bus.getInterface())
{
}

Status::Status(bus::bus& bus, const char* path,
               const std::map<std::string, PropertiesVariant>& vals,
               bool skipSignal) :
    Status(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Status::smartWarnings() const -> std::string
{
    return _smartWarnings;
}

int Status::_callback_get_SmartWarnings(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->smartWarnings()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::smartWarnings(std::string value, bool skipSignal) -> std::string
{
    if (_smartWarnings != value)
    {
        _smartWarnings = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Nvme_Status_interface.property_changed(
                "SmartWarnings");
        }
    }

    return _smartWarnings;
}

auto Status::smartWarnings(std::string val) -> std::string
{
    return smartWarnings(val, false);
}
int Status::_callback_set_SmartWarnings(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->smartWarnings(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_SmartWarnings =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Status::statusFlags() const -> std::string
{
    return _statusFlags;
}

int Status::_callback_get_StatusFlags(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->statusFlags()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::statusFlags(std::string value, bool skipSignal) -> std::string
{
    if (_statusFlags != value)
    {
        _statusFlags = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Nvme_Status_interface.property_changed(
                "StatusFlags");
        }
    }

    return _statusFlags;
}

auto Status::statusFlags(std::string val) -> std::string
{
    return statusFlags(val, false);
}
int Status::_callback_set_StatusFlags(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->statusFlags(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_StatusFlags =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Status::driveLifeUsed() const -> std::string
{
    return _driveLifeUsed;
}

int Status::_callback_get_DriveLifeUsed(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->driveLifeUsed()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::driveLifeUsed(std::string value, bool skipSignal) -> std::string
{
    if (_driveLifeUsed != value)
    {
        _driveLifeUsed = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Nvme_Status_interface.property_changed(
                "DriveLifeUsed");
        }
    }

    return _driveLifeUsed;
}

auto Status::driveLifeUsed(std::string val) -> std::string
{
    return driveLifeUsed(val, false);
}
int Status::_callback_set_DriveLifeUsed(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->driveLifeUsed(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_DriveLifeUsed =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Status::capacityFault() const -> bool
{
    return _capacityFault;
}

int Status::_callback_get_CapacityFault(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->capacityFault()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::capacityFault(bool value, bool skipSignal) -> bool
{
    if (_capacityFault != value)
    {
        _capacityFault = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Nvme_Status_interface.property_changed(
                "CapacityFault");
        }
    }

    return _capacityFault;
}

auto Status::capacityFault(bool val) -> bool
{
    return capacityFault(val, false);
}
int Status::_callback_set_CapacityFault(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->capacityFault(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_CapacityFault =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Status::temperatureFault() const -> bool
{
    return _temperatureFault;
}

int Status::_callback_get_TemperatureFault(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->temperatureFault()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::temperatureFault(bool value, bool skipSignal) -> bool
{
    if (_temperatureFault != value)
    {
        _temperatureFault = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Nvme_Status_interface.property_changed(
                "TemperatureFault");
        }
    }

    return _temperatureFault;
}

auto Status::temperatureFault(bool val) -> bool
{
    return temperatureFault(val, false);
}
int Status::_callback_set_TemperatureFault(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->temperatureFault(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_TemperatureFault =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Status::degradesFault() const -> bool
{
    return _degradesFault;
}

int Status::_callback_get_DegradesFault(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->degradesFault()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::degradesFault(bool value, bool skipSignal) -> bool
{
    if (_degradesFault != value)
    {
        _degradesFault = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Nvme_Status_interface.property_changed(
                "DegradesFault");
        }
    }

    return _degradesFault;
}

auto Status::degradesFault(bool val) -> bool
{
    return degradesFault(val, false);
}
int Status::_callback_set_DegradesFault(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->degradesFault(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_DegradesFault =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Status::mediaFault() const -> bool
{
    return _mediaFault;
}

int Status::_callback_get_MediaFault(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->mediaFault()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::mediaFault(bool value, bool skipSignal) -> bool
{
    if (_mediaFault != value)
    {
        _mediaFault = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Nvme_Status_interface.property_changed(
                "MediaFault");
        }
    }

    return _mediaFault;
}

auto Status::mediaFault(bool val) -> bool
{
    return mediaFault(val, false);
}
int Status::_callback_set_MediaFault(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->mediaFault(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_MediaFault =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Status::backupDeviceFault() const -> bool
{
    return _backupDeviceFault;
}

int Status::_callback_get_BackupDeviceFault(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->backupDeviceFault()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Status::backupDeviceFault(bool value, bool skipSignal) -> bool
{
    if (_backupDeviceFault != value)
    {
        _backupDeviceFault = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Nvme_Status_interface.property_changed(
                "BackupDeviceFault");
        }
    }

    return _backupDeviceFault;
}

auto Status::backupDeviceFault(bool val) -> bool
{
    return backupDeviceFault(val, false);
}
int Status::_callback_set_BackupDeviceFault(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<Status*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->backupDeviceFault(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Status
{
static const auto _property_BackupDeviceFault =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Status::setPropertyByName(const std::string& _name,
                               const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "SmartWarnings")
    {
        auto& v = std::get<std::string>(val);
        smartWarnings(v, skipSignal);
        return;
    }
    if (_name == "StatusFlags")
    {
        auto& v = std::get<std::string>(val);
        statusFlags(v, skipSignal);
        return;
    }
    if (_name == "DriveLifeUsed")
    {
        auto& v = std::get<std::string>(val);
        driveLifeUsed(v, skipSignal);
        return;
    }
    if (_name == "CapacityFault")
    {
        auto& v = std::get<bool>(val);
        capacityFault(v, skipSignal);
        return;
    }
    if (_name == "TemperatureFault")
    {
        auto& v = std::get<bool>(val);
        temperatureFault(v, skipSignal);
        return;
    }
    if (_name == "DegradesFault")
    {
        auto& v = std::get<bool>(val);
        degradesFault(v, skipSignal);
        return;
    }
    if (_name == "MediaFault")
    {
        auto& v = std::get<bool>(val);
        mediaFault(v, skipSignal);
        return;
    }
    if (_name == "BackupDeviceFault")
    {
        auto& v = std::get<bool>(val);
        backupDeviceFault(v, skipSignal);
        return;
    }
}

auto Status::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "SmartWarnings")
    {
        return smartWarnings();
    }
    if (_name == "StatusFlags")
    {
        return statusFlags();
    }
    if (_name == "DriveLifeUsed")
    {
        return driveLifeUsed();
    }
    if (_name == "CapacityFault")
    {
        return capacityFault();
    }
    if (_name == "TemperatureFault")
    {
        return temperatureFault();
    }
    if (_name == "DegradesFault")
    {
        return degradesFault();
    }
    if (_name == "MediaFault")
    {
        return mediaFault();
    }
    if (_name == "BackupDeviceFault")
    {
        return backupDeviceFault();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Status::_vtable[] = {
    vtable::start(),
    vtable::property("SmartWarnings",
                     details::Status::_property_SmartWarnings.data(),
                     _callback_get_SmartWarnings, _callback_set_SmartWarnings,
                     vtable::property_::emits_change),
    vtable::property("StatusFlags",
                     details::Status::_property_StatusFlags.data(),
                     _callback_get_StatusFlags, _callback_set_StatusFlags,
                     vtable::property_::emits_change),
    vtable::property("DriveLifeUsed",
                     details::Status::_property_DriveLifeUsed.data(),
                     _callback_get_DriveLifeUsed, _callback_set_DriveLifeUsed,
                     vtable::property_::emits_change),
    vtable::property("CapacityFault",
                     details::Status::_property_CapacityFault.data(),
                     _callback_get_CapacityFault, _callback_set_CapacityFault,
                     vtable::property_::emits_change),
    vtable::property(
        "TemperatureFault", details::Status::_property_TemperatureFault.data(),
        _callback_get_TemperatureFault, _callback_set_TemperatureFault,
        vtable::property_::emits_change),
    vtable::property("DegradesFault",
                     details::Status::_property_DegradesFault.data(),
                     _callback_get_DegradesFault, _callback_set_DegradesFault,
                     vtable::property_::emits_change),
    vtable::property("MediaFault", details::Status::_property_MediaFault.data(),
                     _callback_get_MediaFault, _callback_set_MediaFault,
                     vtable::property_::emits_change),
    vtable::property("BackupDeviceFault",
                     details::Status::_property_BackupDeviceFault.data(),
                     _callback_get_BackupDeviceFault,
                     _callback_set_BackupDeviceFault,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Memory/MemoryECC/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Memory
{
namespace server
{

MemoryECC::MemoryECC(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Memory_MemoryECC_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

MemoryECC::MemoryECC(bus::bus& bus, const char* path,
                     const std::map<std::string, PropertiesVariant>& vals,
                     bool skipSignal) :
    MemoryECC(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto MemoryECC::isLoggingLimitReached() const -> bool
{
    return _isLoggingLimitReached;
}

int MemoryECC::_callback_get_isLoggingLimitReached(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<MemoryECC*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->isLoggingLimitReached()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto MemoryECC::isLoggingLimitReached(bool value, bool skipSignal) -> bool
{
    if (_isLoggingLimitReached != value)
    {
        _isLoggingLimitReached = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Memory_MemoryECC_interface.property_changed(
                "isLoggingLimitReached");
        }
    }

    return _isLoggingLimitReached;
}

auto MemoryECC::isLoggingLimitReached(bool val) -> bool
{
    return isLoggingLimitReached(val, false);
}
int MemoryECC::_callback_set_isLoggingLimitReached(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<MemoryECC*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->isLoggingLimitReached(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace MemoryECC
{
static const auto _property_isLoggingLimitReached =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto MemoryECC::ceCount() const -> int64_t
{
    return _ceCount;
}

int MemoryECC::_callback_get_ceCount(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<MemoryECC*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->ceCount()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto MemoryECC::ceCount(int64_t value, bool skipSignal) -> int64_t
{
    if (_ceCount != value)
    {
        _ceCount = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Memory_MemoryECC_interface.property_changed(
                "ceCount");
        }
    }

    return _ceCount;
}

auto MemoryECC::ceCount(int64_t val) -> int64_t
{
    return ceCount(val, false);
}
int MemoryECC::_callback_set_ceCount(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<MemoryECC*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->ceCount(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace MemoryECC
{
static const auto _property_ceCount =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto MemoryECC::ueCount() const -> int64_t
{
    return _ueCount;
}

int MemoryECC::_callback_get_ueCount(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<MemoryECC*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->ueCount()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto MemoryECC::ueCount(int64_t value, bool skipSignal) -> int64_t
{
    if (_ueCount != value)
    {
        _ueCount = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Memory_MemoryECC_interface.property_changed(
                "ueCount");
        }
    }

    return _ueCount;
}

auto MemoryECC::ueCount(int64_t val) -> int64_t
{
    return ueCount(val, false);
}
int MemoryECC::_callback_set_ueCount(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<MemoryECC*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->ueCount(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace MemoryECC
{
static const auto _property_ueCount =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto MemoryECC::state() const -> ECCStatus
{
    return _state;
}

int MemoryECC::_callback_get_state(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<MemoryECC*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->state()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto MemoryECC::state(ECCStatus value, bool skipSignal) -> ECCStatus
{
    if (_state != value)
    {
        _state = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Memory_MemoryECC_interface.property_changed(
                "state");
        }
    }

    return _state;
}

auto MemoryECC::state(ECCStatus val) -> ECCStatus
{
    return state(val, false);
}
int MemoryECC::_callback_set_state(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<MemoryECC*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->state(convertECCStatusFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace MemoryECC
{
static const auto _property_state =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void MemoryECC::setPropertyByName(const std::string& _name,
                                  const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "isLoggingLimitReached")
    {
        auto& v = std::get<bool>(val);
        isLoggingLimitReached(v, skipSignal);
        return;
    }
    if (_name == "ceCount")
    {
        auto& v = std::get<int64_t>(val);
        ceCount(v, skipSignal);
        return;
    }
    if (_name == "ueCount")
    {
        auto& v = std::get<int64_t>(val);
        ueCount(v, skipSignal);
        return;
    }
    if (_name == "state")
    {
        auto& v = std::get<ECCStatus>(val);
        state(v, skipSignal);
        return;
    }
}

auto MemoryECC::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "isLoggingLimitReached")
    {
        return isLoggingLimitReached();
    }
    if (_name == "ceCount")
    {
        return ceCount();
    }
    if (_name == "ueCount")
    {
        return ueCount();
    }
    if (_name == "state")
    {
        return state();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for MemoryECC::ECCStatus */
static const std::tuple<const char*, MemoryECC::ECCStatus>
    mappingMemoryECCECCStatus[] = {
        std::make_tuple("xyz.openbmc_project.Memory.MemoryECC.ECCStatus.ok",
                        MemoryECC::ECCStatus::ok),
        std::make_tuple("xyz.openbmc_project.Memory.MemoryECC.ECCStatus.CE",
                        MemoryECC::ECCStatus::CE),
        std::make_tuple("xyz.openbmc_project.Memory.MemoryECC.ECCStatus.UE",
                        MemoryECC::ECCStatus::UE),
        std::make_tuple(
            "xyz.openbmc_project.Memory.MemoryECC.ECCStatus.LogFull",
            MemoryECC::ECCStatus::LogFull),
};

} // anonymous namespace

auto MemoryECC::convertECCStatusFromString(const std::string& s) -> ECCStatus
{
    auto i = std::find_if(std::begin(mappingMemoryECCECCStatus),
                          std::end(mappingMemoryECCECCStatus), [&s](auto& e) {
                              return 0 == strcmp(s.c_str(), std::get<0>(e));
                          });
    if (std::end(mappingMemoryECCECCStatus) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(MemoryECC::ECCStatus v)
{
    auto i = std::find_if(std::begin(mappingMemoryECCECCStatus),
                          std::end(mappingMemoryECCECCStatus),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingMemoryECCECCStatus))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t MemoryECC::_vtable[] = {
    vtable::start(),
    vtable::property("isLoggingLimitReached",
                     details::MemoryECC::_property_isLoggingLimitReached.data(),
                     _callback_get_isLoggingLimitReached,
                     _callback_set_isLoggingLimitReached,
                     vtable::property_::emits_change),
    vtable::property("ceCount", details::MemoryECC::_property_ceCount.data(),
                     _callback_get_ceCount, _callback_set_ceCount,
                     vtable::property_::emits_change),
    vtable::property("ueCount", details::MemoryECC::_property_ueCount.data(),
                     _callback_get_ueCount, _callback_set_ueCount,
                     vtable::property_::emits_change),
    vtable::property("state", details::MemoryECC::_property_state.data(),
                     _callback_get_state, _callback_set_state,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Memory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Led/Physical/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace server
{

Physical::Physical(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Led_Physical_interface(bus, path, _interface, _vtable,
                                                this),
    _intf(bus.getInterface())
{
}

Physical::Physical(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    Physical(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Physical::state() const -> Action
{
    return _state;
}

int Physical::_callback_get_State(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Physical*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->state()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Physical::state(Action value, bool skipSignal) -> Action
{
    if (_state != value)
    {
        _state = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Led_Physical_interface.property_changed(
                "State");
        }
    }

    return _state;
}

auto Physical::state(Action val) -> Action
{
    return state(val, false);
}
int Physical::_callback_set_State(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Physical*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->state(convertActionFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Physical
{
static const auto _property_State =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Physical::dutyOn() const -> uint8_t
{
    return _dutyOn;
}

int Physical::_callback_get_DutyOn(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Physical*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->dutyOn()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Physical::dutyOn(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_dutyOn != value)
    {
        _dutyOn = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Led_Physical_interface.property_changed(
                "DutyOn");
        }
    }

    return _dutyOn;
}

auto Physical::dutyOn(uint8_t val) -> uint8_t
{
    return dutyOn(val, false);
}
int Physical::_callback_set_DutyOn(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Physical*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->dutyOn(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Physical
{
static const auto _property_DutyOn =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto Physical::color() const -> Palette
{
    return _color;
}

int Physical::_callback_get_Color(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Physical*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->color()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Physical::color(Palette value, bool skipSignal) -> Palette
{
    if (_color != value)
    {
        _color = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Led_Physical_interface.property_changed(
                "Color");
        }
    }

    return _color;
}

auto Physical::color(Palette val) -> Palette
{
    return color(val, false);
}
int Physical::_callback_set_Color(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Physical*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->color(convertPaletteFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Physical
{
static const auto _property_Color =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Physical::period() const -> uint16_t
{
    return _period;
}

int Physical::_callback_get_Period(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Physical*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->period()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Physical::period(uint16_t value, bool skipSignal) -> uint16_t
{
    if (_period != value)
    {
        _period = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Led_Physical_interface.property_changed(
                "Period");
        }
    }

    return _period;
}

auto Physical::period(uint16_t val) -> uint16_t
{
    return period(val, false);
}
int Physical::_callback_set_Period(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Physical*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint16_t v{};
        m.read(v);
        o->period(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Physical
{
static const auto _property_Period =
    utility::tuple_to_array(message::types::type_id<uint16_t>());
}
} // namespace details

void Physical::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "State")
    {
        auto& v = std::get<Action>(val);
        state(v, skipSignal);
        return;
    }
    if (_name == "DutyOn")
    {
        auto& v = std::get<uint8_t>(val);
        dutyOn(v, skipSignal);
        return;
    }
    if (_name == "Color")
    {
        auto& v = std::get<Palette>(val);
        color(v, skipSignal);
        return;
    }
    if (_name == "Period")
    {
        auto& v = std::get<uint16_t>(val);
        period(v, skipSignal);
        return;
    }
}

auto Physical::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "State")
    {
        return state();
    }
    if (_name == "DutyOn")
    {
        return dutyOn();
    }
    if (_name == "Color")
    {
        return color();
    }
    if (_name == "Period")
    {
        return period();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Physical::Action */
static const std::tuple<const char*, Physical::Action> mappingPhysicalAction[] =
    {
        std::make_tuple("xyz.openbmc_project.Led.Physical.Action.Off",
                        Physical::Action::Off),
        std::make_tuple("xyz.openbmc_project.Led.Physical.Action.On",
                        Physical::Action::On),
        std::make_tuple("xyz.openbmc_project.Led.Physical.Action.Blink",
                        Physical::Action::Blink),
};

} // anonymous namespace

auto Physical::convertActionFromString(const std::string& s) -> Action
{
    auto i = std::find_if(
        std::begin(mappingPhysicalAction), std::end(mappingPhysicalAction),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingPhysicalAction) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Physical::Action v)
{
    auto i = std::find_if(std::begin(mappingPhysicalAction),
                          std::end(mappingPhysicalAction),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingPhysicalAction))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

namespace
{
/** String to enum mapping for Physical::Palette */
static const std::tuple<const char*, Physical::Palette>
    mappingPhysicalPalette[] = {
        std::make_tuple("xyz.openbmc_project.Led.Physical.Palette.Unknown",
                        Physical::Palette::Unknown),
        std::make_tuple("xyz.openbmc_project.Led.Physical.Palette.Red",
                        Physical::Palette::Red),
        std::make_tuple("xyz.openbmc_project.Led.Physical.Palette.Green",
                        Physical::Palette::Green),
        std::make_tuple("xyz.openbmc_project.Led.Physical.Palette.Blue",
                        Physical::Palette::Blue),
        std::make_tuple("xyz.openbmc_project.Led.Physical.Palette.Yellow",
                        Physical::Palette::Yellow),
};

} // anonymous namespace

auto Physical::convertPaletteFromString(const std::string& s) -> Palette
{
    auto i = std::find_if(
        std::begin(mappingPhysicalPalette), std::end(mappingPhysicalPalette),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingPhysicalPalette) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Physical::Palette v)
{
    auto i = std::find_if(std::begin(mappingPhysicalPalette),
                          std::end(mappingPhysicalPalette),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingPhysicalPalette))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Physical::_vtable[] = {
    vtable::start(),
    vtable::property("State", details::Physical::_property_State.data(),
                     _callback_get_State, _callback_set_State,
                     vtable::property_::emits_change),
    vtable::property("DutyOn", details::Physical::_property_DutyOn.data(),
                     _callback_get_DutyOn, _callback_set_DutyOn,
                     vtable::property_::emits_change),
    vtable::property("Color", details::Physical::_property_Color.data(),
                     _callback_get_Color, _callback_set_Color,
                     vtable::property_::emits_change),
    vtable::property("Period", details::Physical::_property_Period.data(),
                     _callback_get_Period, _callback_set_Period,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Led/Group/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace server
{

Group::Group(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Led_Group_interface(bus, path, _interface, _vtable,
                                             this),
    _intf(bus.getInterface())
{
}

Group::Group(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Group(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Group::asserted() const -> bool
{
    return _asserted;
}

int Group::_callback_get_Asserted(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Group*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->asserted()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Group::asserted(bool value, bool skipSignal) -> bool
{
    if (_asserted != value)
    {
        _asserted = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Led_Group_interface.property_changed(
                "Asserted");
        }
    }

    return _asserted;
}

auto Group::asserted(bool val) -> bool
{
    return asserted(val, false);
}
int Group::_callback_set_Asserted(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Group*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->asserted(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Group
{
static const auto _property_Asserted =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Group::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Asserted")
    {
        auto& v = std::get<bool>(val);
        asserted(v, skipSignal);
        return;
    }
}

auto Group::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Asserted")
    {
        return asserted();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Group::_vtable[] = {
    vtable::start(),
    vtable::property("Asserted", details::Group::_property_Asserted.data(),
                     _callback_get_Asserted, _callback_set_Asserted,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Sensor/Threshold/Warning/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Threshold
{
namespace server
{

Warning::Warning(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Sensor_Threshold_Warning_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Warning::Warning(bus::bus& bus, const char* path,
                 const std::map<std::string, PropertiesVariant>& vals,
                 bool skipSignal) :
    Warning(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Warning::warningHigh() const -> int64_t
{
    return _warningHigh;
}

int Warning::_callback_get_WarningHigh(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* reply, void* context,
                                       sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Warning*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->warningHigh()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Warning::warningHigh(int64_t value, bool skipSignal) -> int64_t
{
    if (_warningHigh != value)
    {
        _warningHigh = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Threshold_Warning_interface
                .property_changed("WarningHigh");
        }
    }

    return _warningHigh;
}

auto Warning::warningHigh(int64_t val) -> int64_t
{
    return warningHigh(val, false);
}
int Warning::_callback_set_WarningHigh(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* value, void* context,
                                       sd_bus_error* error)
{
    auto o = static_cast<Warning*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->warningHigh(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Warning
{
static const auto _property_WarningHigh =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto Warning::warningLow() const -> int64_t
{
    return _warningLow;
}

int Warning::_callback_get_WarningLow(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Warning*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->warningLow()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Warning::warningLow(int64_t value, bool skipSignal) -> int64_t
{
    if (_warningLow != value)
    {
        _warningLow = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Threshold_Warning_interface
                .property_changed("WarningLow");
        }
    }

    return _warningLow;
}

auto Warning::warningLow(int64_t val) -> int64_t
{
    return warningLow(val, false);
}
int Warning::_callback_set_WarningLow(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<Warning*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->warningLow(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Warning
{
static const auto _property_WarningLow =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto Warning::warningAlarmHigh() const -> bool
{
    return _warningAlarmHigh;
}

int Warning::_callback_get_WarningAlarmHigh(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Warning*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->warningAlarmHigh()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Warning::warningAlarmHigh(bool value, bool skipSignal) -> bool
{
    if (_warningAlarmHigh != value)
    {
        _warningAlarmHigh = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Threshold_Warning_interface
                .property_changed("WarningAlarmHigh");
        }
    }

    return _warningAlarmHigh;
}

auto Warning::warningAlarmHigh(bool val) -> bool
{
    return warningAlarmHigh(val, false);
}
int Warning::_callback_set_WarningAlarmHigh(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<Warning*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->warningAlarmHigh(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Warning
{
static const auto _property_WarningAlarmHigh =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Warning::warningAlarmLow() const -> bool
{
    return _warningAlarmLow;
}

int Warning::_callback_get_WarningAlarmLow(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Warning*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->warningAlarmLow()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Warning::warningAlarmLow(bool value, bool skipSignal) -> bool
{
    if (_warningAlarmLow != value)
    {
        _warningAlarmLow = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Threshold_Warning_interface
                .property_changed("WarningAlarmLow");
        }
    }

    return _warningAlarmLow;
}

auto Warning::warningAlarmLow(bool val) -> bool
{
    return warningAlarmLow(val, false);
}
int Warning::_callback_set_WarningAlarmLow(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<Warning*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->warningAlarmLow(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Warning
{
static const auto _property_WarningAlarmLow =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Warning::setPropertyByName(const std::string& _name,
                                const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "WarningHigh")
    {
        auto& v = std::get<int64_t>(val);
        warningHigh(v, skipSignal);
        return;
    }
    if (_name == "WarningLow")
    {
        auto& v = std::get<int64_t>(val);
        warningLow(v, skipSignal);
        return;
    }
    if (_name == "WarningAlarmHigh")
    {
        auto& v = std::get<bool>(val);
        warningAlarmHigh(v, skipSignal);
        return;
    }
    if (_name == "WarningAlarmLow")
    {
        auto& v = std::get<bool>(val);
        warningAlarmLow(v, skipSignal);
        return;
    }
}

auto Warning::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "WarningHigh")
    {
        return warningHigh();
    }
    if (_name == "WarningLow")
    {
        return warningLow();
    }
    if (_name == "WarningAlarmHigh")
    {
        return warningAlarmHigh();
    }
    if (_name == "WarningAlarmLow")
    {
        return warningAlarmLow();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Warning::_vtable[] = {
    vtable::start(),
    vtable::property("WarningHigh",
                     details::Warning::_property_WarningHigh.data(),
                     _callback_get_WarningHigh, _callback_set_WarningHigh,
                     vtable::property_::emits_change),
    vtable::property("WarningLow",
                     details::Warning::_property_WarningLow.data(),
                     _callback_get_WarningLow, _callback_set_WarningLow,
                     vtable::property_::emits_change),
    vtable::property(
        "WarningAlarmHigh", details::Warning::_property_WarningAlarmHigh.data(),
        _callback_get_WarningAlarmHigh, _callback_set_WarningAlarmHigh,
        vtable::property_::emits_change),
    vtable::property(
        "WarningAlarmLow", details::Warning::_property_WarningAlarmLow.data(),
        _callback_get_WarningAlarmLow, _callback_set_WarningAlarmLow,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Threshold
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Sensor/Threshold/Critical/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Threshold
{
namespace server
{

Critical::Critical(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Sensor_Threshold_Critical_interface(
        bus, path, _interface, _vtable, this),
    _intf(bus.getInterface())
{
}

Critical::Critical(bus::bus& bus, const char* path,
                   const std::map<std::string, PropertiesVariant>& vals,
                   bool skipSignal) :
    Critical(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Critical::criticalHigh() const -> int64_t
{
    return _criticalHigh;
}

int Critical::_callback_get_CriticalHigh(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* reply, void* context,
                                         sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Critical*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->criticalHigh()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Critical::criticalHigh(int64_t value, bool skipSignal) -> int64_t
{
    if (_criticalHigh != value)
    {
        _criticalHigh = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Threshold_Critical_interface
                .property_changed("CriticalHigh");
        }
    }

    return _criticalHigh;
}

auto Critical::criticalHigh(int64_t val) -> int64_t
{
    return criticalHigh(val, false);
}
int Critical::_callback_set_CriticalHigh(sd_bus* bus, const char* path,
                                         const char* interface,
                                         const char* property,
                                         sd_bus_message* value, void* context,
                                         sd_bus_error* error)
{
    auto o = static_cast<Critical*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->criticalHigh(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Critical
{
static const auto _property_CriticalHigh =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto Critical::criticalLow() const -> int64_t
{
    return _criticalLow;
}

int Critical::_callback_get_CriticalLow(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* reply, void* context,
                                        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Critical*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->criticalLow()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Critical::criticalLow(int64_t value, bool skipSignal) -> int64_t
{
    if (_criticalLow != value)
    {
        _criticalLow = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Threshold_Critical_interface
                .property_changed("CriticalLow");
        }
    }

    return _criticalLow;
}

auto Critical::criticalLow(int64_t val) -> int64_t
{
    return criticalLow(val, false);
}
int Critical::_callback_set_CriticalLow(sd_bus* bus, const char* path,
                                        const char* interface,
                                        const char* property,
                                        sd_bus_message* value, void* context,
                                        sd_bus_error* error)
{
    auto o = static_cast<Critical*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->criticalLow(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Critical
{
static const auto _property_CriticalLow =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto Critical::criticalAlarmHigh() const -> bool
{
    return _criticalAlarmHigh;
}

int Critical::_callback_get_CriticalAlarmHigh(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Critical*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->criticalAlarmHigh()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Critical::criticalAlarmHigh(bool value, bool skipSignal) -> bool
{
    if (_criticalAlarmHigh != value)
    {
        _criticalAlarmHigh = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Threshold_Critical_interface
                .property_changed("CriticalAlarmHigh");
        }
    }

    return _criticalAlarmHigh;
}

auto Critical::criticalAlarmHigh(bool val) -> bool
{
    return criticalAlarmHigh(val, false);
}
int Critical::_callback_set_CriticalAlarmHigh(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Critical*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->criticalAlarmHigh(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Critical
{
static const auto _property_CriticalAlarmHigh =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto Critical::criticalAlarmLow() const -> bool
{
    return _criticalAlarmLow;
}

int Critical::_callback_get_CriticalAlarmLow(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Critical*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->criticalAlarmLow()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Critical::criticalAlarmLow(bool value, bool skipSignal) -> bool
{
    if (_criticalAlarmLow != value)
    {
        _criticalAlarmLow = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Threshold_Critical_interface
                .property_changed("CriticalAlarmLow");
        }
    }

    return _criticalAlarmLow;
}

auto Critical::criticalAlarmLow(bool val) -> bool
{
    return criticalAlarmLow(val, false);
}
int Critical::_callback_set_CriticalAlarmLow(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<Critical*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->criticalAlarmLow(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Critical
{
static const auto _property_CriticalAlarmLow =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

void Critical::setPropertyByName(const std::string& _name,
                                 const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "CriticalHigh")
    {
        auto& v = std::get<int64_t>(val);
        criticalHigh(v, skipSignal);
        return;
    }
    if (_name == "CriticalLow")
    {
        auto& v = std::get<int64_t>(val);
        criticalLow(v, skipSignal);
        return;
    }
    if (_name == "CriticalAlarmHigh")
    {
        auto& v = std::get<bool>(val);
        criticalAlarmHigh(v, skipSignal);
        return;
    }
    if (_name == "CriticalAlarmLow")
    {
        auto& v = std::get<bool>(val);
        criticalAlarmLow(v, skipSignal);
        return;
    }
}

auto Critical::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "CriticalHigh")
    {
        return criticalHigh();
    }
    if (_name == "CriticalLow")
    {
        return criticalLow();
    }
    if (_name == "CriticalAlarmHigh")
    {
        return criticalAlarmHigh();
    }
    if (_name == "CriticalAlarmLow")
    {
        return criticalAlarmLow();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Critical::_vtable[] = {
    vtable::start(),
    vtable::property("CriticalHigh",
                     details::Critical::_property_CriticalHigh.data(),
                     _callback_get_CriticalHigh, _callback_set_CriticalHigh,
                     vtable::property_::emits_change),
    vtable::property("CriticalLow",
                     details::Critical::_property_CriticalLow.data(),
                     _callback_get_CriticalLow, _callback_set_CriticalLow,
                     vtable::property_::emits_change),
    vtable::property("CriticalAlarmHigh",
                     details::Critical::_property_CriticalAlarmHigh.data(),
                     _callback_get_CriticalAlarmHigh,
                     _callback_set_CriticalAlarmHigh,
                     vtable::property_::emits_change),
    vtable::property("CriticalAlarmLow",
                     details::Critical::_property_CriticalAlarmLow.data(),
                     _callback_get_CriticalAlarmLow,
                     _callback_set_CriticalAlarmLow,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Threshold
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Sensor/Value/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace server
{

Value::Value(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Sensor_Value_interface(bus, path, _interface, _vtable,
                                                this),
    _intf(bus.getInterface())
{
}

Value::Value(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Value(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Value::value() const -> int64_t
{
    return _value;
}

int Value::_callback_get_Value(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->value()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Value::value(int64_t value, bool skipSignal) -> int64_t
{
    if (_value != value)
    {
        _value = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Value_interface.property_changed(
                "Value");
        }
    }

    return _value;
}

auto Value::value(int64_t val) -> int64_t
{
    return value(val, false);
}
int Value::_callback_set_Value(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->value(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Value
{
static const auto _property_Value =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto Value::maxValue() const -> int64_t
{
    return _maxValue;
}

int Value::_callback_get_MaxValue(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->maxValue()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Value::maxValue(int64_t value, bool skipSignal) -> int64_t
{
    if (_maxValue != value)
    {
        _maxValue = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Value_interface.property_changed(
                "MaxValue");
        }
    }

    return _maxValue;
}

auto Value::maxValue(int64_t val) -> int64_t
{
    return maxValue(val, false);
}
int Value::_callback_set_MaxValue(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->maxValue(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Value
{
static const auto _property_MaxValue =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto Value::minValue() const -> int64_t
{
    return _minValue;
}

int Value::_callback_get_MinValue(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->minValue()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Value::minValue(int64_t value, bool skipSignal) -> int64_t
{
    if (_minValue != value)
    {
        _minValue = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Value_interface.property_changed(
                "MinValue");
        }
    }

    return _minValue;
}

auto Value::minValue(int64_t val) -> int64_t
{
    return minValue(val, false);
}
int Value::_callback_set_MinValue(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->minValue(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Value
{
static const auto _property_MinValue =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

auto Value::unit() const -> Unit
{
    return _unit;
}

int Value::_callback_get_Unit(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* reply, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->unit()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Value::unit(Unit value, bool skipSignal) -> Unit
{
    if (_unit != value)
    {
        _unit = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Value_interface.property_changed(
                "Unit");
        }
    }

    return _unit;
}

auto Value::unit(Unit val) -> Unit
{
    return unit(val, false);
}
int Value::_callback_set_Unit(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* value, void* context,
                              sd_bus_error* error)
{
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->unit(convertUnitFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Value
{
static const auto _property_Unit =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

auto Value::scale() const -> int64_t
{
    return _scale;
}

int Value::_callback_get_Scale(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* reply, void* context,
                               sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->scale()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Value::scale(int64_t value, bool skipSignal) -> int64_t
{
    if (_scale != value)
    {
        _scale = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Sensor_Value_interface.property_changed(
                "Scale");
        }
    }

    return _scale;
}

auto Value::scale(int64_t val) -> int64_t
{
    return scale(val, false);
}
int Value::_callback_set_Scale(sd_bus* bus, const char* path,
                               const char* interface, const char* property,
                               sd_bus_message* value, void* context,
                               sd_bus_error* error)
{
    auto o = static_cast<Value*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        int64_t v{};
        m.read(v);
        o->scale(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Value
{
static const auto _property_Scale =
    utility::tuple_to_array(message::types::type_id<int64_t>());
}
} // namespace details

void Value::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Value")
    {
        auto& v = std::get<int64_t>(val);
        value(v, skipSignal);
        return;
    }
    if (_name == "MaxValue")
    {
        auto& v = std::get<int64_t>(val);
        maxValue(v, skipSignal);
        return;
    }
    if (_name == "MinValue")
    {
        auto& v = std::get<int64_t>(val);
        minValue(v, skipSignal);
        return;
    }
    if (_name == "Unit")
    {
        auto& v = std::get<Unit>(val);
        unit(v, skipSignal);
        return;
    }
    if (_name == "Scale")
    {
        auto& v = std::get<int64_t>(val);
        scale(v, skipSignal);
        return;
    }
}

auto Value::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Value")
    {
        return value();
    }
    if (_name == "MaxValue")
    {
        return maxValue();
    }
    if (_name == "MinValue")
    {
        return minValue();
    }
    if (_name == "Unit")
    {
        return unit();
    }
    if (_name == "Scale")
    {
        return scale();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Value::Unit */
static const std::tuple<const char*, Value::Unit> mappingValueUnit[] = {
    std::make_tuple("xyz.openbmc_project.Sensor.Value.Unit.DegreesC",
                    Value::Unit::DegreesC),
    std::make_tuple("xyz.openbmc_project.Sensor.Value.Unit.RPMS",
                    Value::Unit::RPMS),
    std::make_tuple("xyz.openbmc_project.Sensor.Value.Unit.Volts",
                    Value::Unit::Volts),
    std::make_tuple("xyz.openbmc_project.Sensor.Value.Unit.Meters",
                    Value::Unit::Meters),
    std::make_tuple("xyz.openbmc_project.Sensor.Value.Unit.Amperes",
                    Value::Unit::Amperes),
    std::make_tuple("xyz.openbmc_project.Sensor.Value.Unit.Watts",
                    Value::Unit::Watts),
    std::make_tuple("xyz.openbmc_project.Sensor.Value.Unit.Joules",
                    Value::Unit::Joules),
};

} // anonymous namespace

auto Value::convertUnitFromString(const std::string& s) -> Unit
{
    auto i = std::find_if(
        std::begin(mappingValueUnit), std::end(mappingValueUnit),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingValueUnit) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Value::Unit v)
{
    auto i =
        std::find_if(std::begin(mappingValueUnit), std::end(mappingValueUnit),
                     [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingValueUnit))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Value::_vtable[] = {
    vtable::start(),
    vtable::property("Value", details::Value::_property_Value.data(),
                     _callback_get_Value, _callback_set_Value,
                     vtable::property_::emits_change),
    vtable::property("MaxValue", details::Value::_property_MaxValue.data(),
                     _callback_get_MaxValue, _callback_set_MaxValue,
                     vtable::property_::emits_change),
    vtable::property("MinValue", details::Value::_property_MinValue.data(),
                     _callback_get_MinValue, _callback_set_MinValue,
                     vtable::property_::emits_change),
    vtable::property("Unit", details::Value::_property_Unit.data(),
                     _callback_get_Unit, _callback_set_Unit,
                     vtable::property_::emits_change),
    vtable::property("Scale", details::Value::_property_Scale.data(),
                     _callback_get_Scale, _callback_set_Scale,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/File/error.hpp>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Dump/Create/error.hpp>
#include <xyz/openbmc_project/Dump/Create/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Dump
{
namespace server
{

Create::Create(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Dump_Create_interface(bus, path, _interface, _vtable,
                                               this),
    _intf(bus.getInterface())
{
}

int Create::_callback_CreateDump(sd_bus_message* msg, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    try
    {
        auto m = message::message(msg);
#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        auto o = static_cast<Create*>(context);
        auto r = o->createDump();

        auto reply = m.new_method_return();
        reply.append(convertForMessage(std::move(r)));

        reply.method_return();
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::File::Error::Write& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Dump::Create::Error::Disabled& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }
    catch (
        sdbusplus::xyz::openbmc_project::Dump::Create::Error::QuotaExceeded& e)
    {
        return sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Create
{
static const auto _param_CreateDump =
    utility::tuple_to_array(std::make_tuple('\0'));
static const auto _return_CreateDump =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
} // namespace Create
} // namespace details

const vtable::vtable_t Create::_vtable[] = {
    vtable::start(),

    vtable::method("CreateDump", details::Create::_param_CreateDump.data(),
                   details::Create::_return_CreateDump.data(),
                   _callback_CreateDump),
    vtable::end()};

} // namespace server
} // namespace Dump
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Dump/Entry/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Dump
{
namespace server
{

Entry::Entry(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Dump_Entry_interface(bus, path, _interface, _vtable,
                                              this),
    _intf(bus.getInterface())
{
}

Entry::Entry(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Entry(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Entry::size() const -> uint64_t
{
    return _size;
}

int Entry::_callback_get_Size(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* reply, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->size()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Entry::size(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_size != value)
    {
        _size = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Dump_Entry_interface.property_changed("Size");
        }
    }

    return _size;
}

auto Entry::size(uint64_t val) -> uint64_t
{
    return size(val, false);
}
int Entry::_callback_set_Size(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* value, void* context,
                              sd_bus_error* error)
{
    auto o = static_cast<Entry*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->size(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Entry
{
static const auto _property_Size =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

void Entry::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Size")
    {
        auto& v = std::get<uint64_t>(val);
        size(v, skipSignal);
        return;
    }
}

auto Entry::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Size")
    {
        return size();
    }

    return PropertiesVariant();
}

const vtable::vtable_t Entry::_vtable[] = {
    vtable::start(),
    vtable::property("Size", details::Entry::_property_Size.data(),
                     _callback_get_Size, _callback_set_Size,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Dump
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Time/Owner/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Time
{
namespace server
{

Owner::Owner(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Time_Owner_interface(bus, path, _interface, _vtable,
                                              this),
    _intf(bus.getInterface())
{
}

Owner::Owner(bus::bus& bus, const char* path,
             const std::map<std::string, PropertiesVariant>& vals,
             bool skipSignal) :
    Owner(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Owner::timeOwner() const -> Owners
{
    return _timeOwner;
}

int Owner::_callback_get_TimeOwner(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* reply, void* context,
                                   sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Owner*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->timeOwner()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Owner::timeOwner(Owners value, bool skipSignal) -> Owners
{
    if (_timeOwner != value)
    {
        _timeOwner = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Time_Owner_interface.property_changed(
                "TimeOwner");
        }
    }

    return _timeOwner;
}

auto Owner::timeOwner(Owners val) -> Owners
{
    return timeOwner(val, false);
}
int Owner::_callback_set_TimeOwner(sd_bus* bus, const char* path,
                                   const char* interface, const char* property,
                                   sd_bus_message* value, void* context,
                                   sd_bus_error* error)
{
    auto o = static_cast<Owner*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->timeOwner(convertOwnersFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Owner
{
static const auto _property_TimeOwner =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Owner::setPropertyByName(const std::string& _name,
                              const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "TimeOwner")
    {
        auto& v = std::get<Owners>(val);
        timeOwner(v, skipSignal);
        return;
    }
}

auto Owner::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "TimeOwner")
    {
        return timeOwner();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Owner::Owners */
static const std::tuple<const char*, Owner::Owners> mappingOwnerOwners[] = {
    std::make_tuple("xyz.openbmc_project.Time.Owner.Owners.BMC",
                    Owner::Owners::BMC),
    std::make_tuple("xyz.openbmc_project.Time.Owner.Owners.Host",
                    Owner::Owners::Host),
    std::make_tuple("xyz.openbmc_project.Time.Owner.Owners.Both",
                    Owner::Owners::Both),
    std::make_tuple("xyz.openbmc_project.Time.Owner.Owners.Split",
                    Owner::Owners::Split),
};

} // anonymous namespace

auto Owner::convertOwnersFromString(const std::string& s) -> Owners
{
    auto i = std::find_if(
        std::begin(mappingOwnerOwners), std::end(mappingOwnerOwners),
        [&s](auto& e) { return 0 == strcmp(s.c_str(), std::get<0>(e)); });
    if (std::end(mappingOwnerOwners) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Owner::Owners v)
{
    auto i = std::find_if(std::begin(mappingOwnerOwners),
                          std::end(mappingOwnerOwners),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingOwnerOwners))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Owner::_vtable[] = {
    vtable::start(),
    vtable::property("TimeOwner", details::Owner::_property_TimeOwner.data(),
                     _callback_get_TimeOwner, _callback_set_TimeOwner,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Time
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Time/Synchronization/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Time
{
namespace server
{

Synchronization::Synchronization(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Time_Synchronization_interface(bus, path, _interface,
                                                        _vtable, this),
    _intf(bus.getInterface())
{
}

Synchronization::Synchronization(
    bus::bus& bus, const char* path,
    const std::map<std::string, PropertiesVariant>& vals, bool skipSignal) :
    Synchronization(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto Synchronization::timeSyncMethod() const -> Method
{
    return _timeSyncMethod;
}

int Synchronization::_callback_get_TimeSyncMethod(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<Synchronization*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->timeSyncMethod()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto Synchronization::timeSyncMethod(Method value, bool skipSignal) -> Method
{
    if (_timeSyncMethod != value)
    {
        _timeSyncMethod = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Time_Synchronization_interface
                .property_changed("TimeSyncMethod");
        }
    }

    return _timeSyncMethod;
}

auto Synchronization::timeSyncMethod(Method val) -> Method
{
    return timeSyncMethod(val, false);
}
int Synchronization::_callback_set_TimeSyncMethod(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<Synchronization*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::string v{};
        m.read(v);
        o->timeSyncMethod(convertMethodFromString(v));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace Synchronization
{
static const auto _property_TimeSyncMethod =
    utility::tuple_to_array(message::types::type_id<std::string>());
}
} // namespace details

void Synchronization::setPropertyByName(const std::string& _name,
                                        const PropertiesVariant& val,
                                        bool skipSignal)
{
    if (_name == "TimeSyncMethod")
    {
        auto& v = std::get<Method>(val);
        timeSyncMethod(v, skipSignal);
        return;
    }
}

auto Synchronization::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "TimeSyncMethod")
    {
        return timeSyncMethod();
    }

    return PropertiesVariant();
}

namespace
{
/** String to enum mapping for Synchronization::Method */
static const std::tuple<const char*, Synchronization::Method>
    mappingSynchronizationMethod[] = {
        std::make_tuple("xyz.openbmc_project.Time.Synchronization.Method.NTP",
                        Synchronization::Method::NTP),
        std::make_tuple(
            "xyz.openbmc_project.Time.Synchronization.Method.Manual",
            Synchronization::Method::Manual),
};

} // anonymous namespace

auto Synchronization::convertMethodFromString(const std::string& s) -> Method
{
    auto i =
        std::find_if(std::begin(mappingSynchronizationMethod),
                     std::end(mappingSynchronizationMethod), [&s](auto& e) {
                         return 0 == strcmp(s.c_str(), std::get<0>(e));
                     });
    if (std::end(mappingSynchronizationMethod) == i)
    {
        throw sdbusplus::exception::InvalidEnumString();
    }
    else
    {
        return std::get<1>(*i);
    }
}

std::string convertForMessage(Synchronization::Method v)
{
    auto i = std::find_if(std::begin(mappingSynchronizationMethod),
                          std::end(mappingSynchronizationMethod),
                          [v](auto& e) { return v == std::get<1>(e); });
    if (i == std::end(mappingSynchronizationMethod))
    {
        throw std::invalid_argument(std::to_string(static_cast<int>(v)));
    }
    return std::get<0>(*i);
}

const vtable::vtable_t Synchronization::_vtable[] = {
    vtable::start(),
    vtable::property("TimeSyncMethod",
                     details::Synchronization::_property_TimeSyncMethod.data(),
                     _callback_get_TimeSyncMethod, _callback_set_TimeSyncMethod,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Time
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Time/EpochTime/server.hpp>
#include <xyz/openbmc_project/Time/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Time
{
namespace server
{

EpochTime::EpochTime(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Time_EpochTime_interface(bus, path, _interface,
                                                  _vtable, this),
    _intf(bus.getInterface())
{
}

EpochTime::EpochTime(bus::bus& bus, const char* path,
                     const std::map<std::string, PropertiesVariant>& vals,
                     bool skipSignal) :
    EpochTime(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto EpochTime::elapsed() const -> uint64_t
{
    return _elapsed;
}

int EpochTime::_callback_get_Elapsed(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<EpochTime*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->elapsed()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Time::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Time::Error::Failed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto EpochTime::elapsed(uint64_t value, bool skipSignal) -> uint64_t
{
    if (_elapsed != value)
    {
        _elapsed = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Time_EpochTime_interface.property_changed(
                "Elapsed");
        }
    }

    return _elapsed;
}

auto EpochTime::elapsed(uint64_t val) -> uint64_t
{
    return elapsed(val, false);
}
int EpochTime::_callback_set_Elapsed(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<EpochTime*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint64_t v{};
        m.read(v);
        o->elapsed(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Time::Error::NotAllowed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Time::Error::Failed& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace EpochTime
{
static const auto _property_Elapsed =
    utility::tuple_to_array(message::types::type_id<uint64_t>());
}
} // namespace details

void EpochTime::setPropertyByName(const std::string& _name,
                                  const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Elapsed")
    {
        auto& v = std::get<uint64_t>(val);
        elapsed(v, skipSignal);
        return;
    }
}

auto EpochTime::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Elapsed")
    {
        return elapsed();
    }

    return PropertiesVariant();
}

const vtable::vtable_t EpochTime::_vtable[] = {
    vtable::start(),
    vtable::property("Elapsed", details::EpochTime::_property_Elapsed.data(),
                     _callback_get_Elapsed, _callback_set_Elapsed,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Time
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Ipmi/SOL/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Ipmi
{
namespace server
{

SOL::SOL(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Ipmi_SOL_interface(bus, path, _interface, _vtable,
                                            this),
    _intf(bus.getInterface())
{
}

SOL::SOL(bus::bus& bus, const char* path,
         const std::map<std::string, PropertiesVariant>& vals,
         bool skipSignal) :
    SOL(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto SOL::progress() const -> uint8_t
{
    return _progress;
}

int SOL::_callback_get_Progress(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* reply, void* context,
                                sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->progress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::progress(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_progress != value)
    {
        _progress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed(
                "Progress");
        }
    }

    return _progress;
}

auto SOL::progress(uint8_t val) -> uint8_t
{
    return progress(val, false);
}
int SOL::_callback_set_Progress(sd_bus* bus, const char* path,
                                const char* interface, const char* property,
                                sd_bus_message* value, void* context,
                                sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->progress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_Progress =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SOL::enable() const -> bool
{
    return _enable;
}

int SOL::_callback_get_Enable(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* reply, void* context,
                              sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->enable()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::enable(bool value, bool skipSignal) -> bool
{
    if (_enable != value)
    {
        _enable = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed("Enable");
        }
    }

    return _enable;
}

auto SOL::enable(bool val) -> bool
{
    return enable(val, false);
}
int SOL::_callback_set_Enable(sd_bus* bus, const char* path,
                              const char* interface, const char* property,
                              sd_bus_message* value, void* context,
                              sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->enable(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_Enable =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto SOL::forceEncryption() const -> bool
{
    return _forceEncryption;
}

int SOL::_callback_get_ForceEncryption(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* reply, void* context,
                                       sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->forceEncryption()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::forceEncryption(bool value, bool skipSignal) -> bool
{
    if (_forceEncryption != value)
    {
        _forceEncryption = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed(
                "ForceEncryption");
        }
    }

    return _forceEncryption;
}

auto SOL::forceEncryption(bool val) -> bool
{
    return forceEncryption(val, false);
}
int SOL::_callback_set_ForceEncryption(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* value, void* context,
                                       sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->forceEncryption(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_ForceEncryption =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto SOL::forceAuthentication() const -> bool
{
    return _forceAuthentication;
}

int SOL::_callback_get_ForceAuthentication(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* reply, void* context,
                                           sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->forceAuthentication()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::forceAuthentication(bool value, bool skipSignal) -> bool
{
    if (_forceAuthentication != value)
    {
        _forceAuthentication = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed(
                "ForceAuthentication");
        }
    }

    return _forceAuthentication;
}

auto SOL::forceAuthentication(bool val) -> bool
{
    return forceAuthentication(val, false);
}
int SOL::_callback_set_ForceAuthentication(sd_bus* bus, const char* path,
                                           const char* interface,
                                           const char* property,
                                           sd_bus_message* value, void* context,
                                           sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        bool v{};
        m.read(v);
        o->forceAuthentication(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_ForceAuthentication =
    utility::tuple_to_array(message::types::type_id<bool>());
}
} // namespace details

auto SOL::privilege() const -> uint8_t
{
    return _privilege;
}

int SOL::_callback_get_Privilege(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->privilege()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::privilege(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_privilege != value)
    {
        _privilege = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed(
                "Privilege");
        }
    }

    return _privilege;
}

auto SOL::privilege(uint8_t val) -> uint8_t
{
    return privilege(val, false);
}
int SOL::_callback_set_Privilege(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->privilege(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_Privilege =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SOL::accumulateIntervalMS() const -> uint8_t
{
    return _accumulateIntervalMS;
}

int SOL::_callback_get_AccumulateIntervalMS(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->accumulateIntervalMS()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::accumulateIntervalMS(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_accumulateIntervalMS != value)
    {
        _accumulateIntervalMS = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed(
                "AccumulateIntervalMS");
        }
    }

    return _accumulateIntervalMS;
}

auto SOL::accumulateIntervalMS(uint8_t val) -> uint8_t
{
    return accumulateIntervalMS(val, false);
}
int SOL::_callback_set_AccumulateIntervalMS(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->accumulateIntervalMS(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_AccumulateIntervalMS =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SOL::threshold() const -> uint8_t
{
    return _threshold;
}

int SOL::_callback_get_Threshold(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* reply, void* context,
                                 sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->threshold()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::threshold(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_threshold != value)
    {
        _threshold = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed(
                "Threshold");
        }
    }

    return _threshold;
}

auto SOL::threshold(uint8_t val) -> uint8_t
{
    return threshold(val, false);
}
int SOL::_callback_set_Threshold(sd_bus* bus, const char* path,
                                 const char* interface, const char* property,
                                 sd_bus_message* value, void* context,
                                 sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->threshold(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_Threshold =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SOL::retryCount() const -> uint8_t
{
    return _retryCount;
}

int SOL::_callback_get_RetryCount(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* reply, void* context,
                                  sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->retryCount()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::retryCount(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_retryCount != value)
    {
        _retryCount = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed(
                "RetryCount");
        }
    }

    return _retryCount;
}

auto SOL::retryCount(uint8_t val) -> uint8_t
{
    return retryCount(val, false);
}
int SOL::_callback_set_RetryCount(sd_bus* bus, const char* path,
                                  const char* interface, const char* property,
                                  sd_bus_message* value, void* context,
                                  sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->retryCount(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_RetryCount =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SOL::retryIntervalMS() const -> uint8_t
{
    return _retryIntervalMS;
}

int SOL::_callback_get_RetryIntervalMS(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* reply, void* context,
                                       sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->retryIntervalMS()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SOL::retryIntervalMS(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_retryIntervalMS != value)
    {
        _retryIntervalMS = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SOL_interface.property_changed(
                "RetryIntervalMS");
        }
    }

    return _retryIntervalMS;
}

auto SOL::retryIntervalMS(uint8_t val) -> uint8_t
{
    return retryIntervalMS(val, false);
}
int SOL::_callback_set_RetryIntervalMS(sd_bus* bus, const char* path,
                                       const char* interface,
                                       const char* property,
                                       sd_bus_message* value, void* context,
                                       sd_bus_error* error)
{
    auto o = static_cast<SOL*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->retryIntervalMS(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SOL
{
static const auto _property_RetryIntervalMS =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

void SOL::setPropertyByName(const std::string& _name,
                            const PropertiesVariant& val, bool skipSignal)
{
    if (_name == "Progress")
    {
        auto& v = std::get<uint8_t>(val);
        progress(v, skipSignal);
        return;
    }
    if (_name == "Enable")
    {
        auto& v = std::get<bool>(val);
        enable(v, skipSignal);
        return;
    }
    if (_name == "ForceEncryption")
    {
        auto& v = std::get<bool>(val);
        forceEncryption(v, skipSignal);
        return;
    }
    if (_name == "ForceAuthentication")
    {
        auto& v = std::get<bool>(val);
        forceAuthentication(v, skipSignal);
        return;
    }
    if (_name == "Privilege")
    {
        auto& v = std::get<uint8_t>(val);
        privilege(v, skipSignal);
        return;
    }
    if (_name == "AccumulateIntervalMS")
    {
        auto& v = std::get<uint8_t>(val);
        accumulateIntervalMS(v, skipSignal);
        return;
    }
    if (_name == "Threshold")
    {
        auto& v = std::get<uint8_t>(val);
        threshold(v, skipSignal);
        return;
    }
    if (_name == "RetryCount")
    {
        auto& v = std::get<uint8_t>(val);
        retryCount(v, skipSignal);
        return;
    }
    if (_name == "RetryIntervalMS")
    {
        auto& v = std::get<uint8_t>(val);
        retryIntervalMS(v, skipSignal);
        return;
    }
}

auto SOL::getPropertyByName(const std::string& _name) -> PropertiesVariant
{
    if (_name == "Progress")
    {
        return progress();
    }
    if (_name == "Enable")
    {
        return enable();
    }
    if (_name == "ForceEncryption")
    {
        return forceEncryption();
    }
    if (_name == "ForceAuthentication")
    {
        return forceAuthentication();
    }
    if (_name == "Privilege")
    {
        return privilege();
    }
    if (_name == "AccumulateIntervalMS")
    {
        return accumulateIntervalMS();
    }
    if (_name == "Threshold")
    {
        return threshold();
    }
    if (_name == "RetryCount")
    {
        return retryCount();
    }
    if (_name == "RetryIntervalMS")
    {
        return retryIntervalMS();
    }

    return PropertiesVariant();
}

const vtable::vtable_t SOL::_vtable[] = {
    vtable::start(),
    vtable::property("Progress", details::SOL::_property_Progress.data(),
                     _callback_get_Progress, _callback_set_Progress,
                     vtable::property_::emits_change),
    vtable::property("Enable", details::SOL::_property_Enable.data(),
                     _callback_get_Enable, _callback_set_Enable,
                     vtable::property_::emits_change),
    vtable::property(
        "ForceEncryption", details::SOL::_property_ForceEncryption.data(),
        _callback_get_ForceEncryption, _callback_set_ForceEncryption,
        vtable::property_::emits_change),
    vtable::property("ForceAuthentication",
                     details::SOL::_property_ForceAuthentication.data(),
                     _callback_get_ForceAuthentication,
                     _callback_set_ForceAuthentication,
                     vtable::property_::emits_change),
    vtable::property("Privilege", details::SOL::_property_Privilege.data(),
                     _callback_get_Privilege, _callback_set_Privilege,
                     vtable::property_::emits_change),
    vtable::property("AccumulateIntervalMS",
                     details::SOL::_property_AccumulateIntervalMS.data(),
                     _callback_get_AccumulateIntervalMS,
                     _callback_set_AccumulateIntervalMS,
                     vtable::property_::emits_change),
    vtable::property("Threshold", details::SOL::_property_Threshold.data(),
                     _callback_get_Threshold, _callback_set_Threshold,
                     vtable::property_::emits_change),
    vtable::property("RetryCount", details::SOL::_property_RetryCount.data(),
                     _callback_get_RetryCount, _callback_set_RetryCount,
                     vtable::property_::emits_change),
    vtable::property(
        "RetryIntervalMS", details::SOL::_property_RetryIntervalMS.data(),
        _callback_get_RetryIntervalMS, _callback_set_RetryIntervalMS,
        vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Ipmi
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <algorithm>
#include <map>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/sdbus.hpp>
#include <sdbusplus/server.hpp>
#include <string>
#include <tuple>
#include <variant>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Ipmi/SessionInfo/server.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Ipmi
{
namespace server
{

SessionInfo::SessionInfo(bus::bus& bus, const char* path) :
    _xyz_openbmc_project_Ipmi_SessionInfo_interface(bus, path, _interface,
                                                    _vtable, this),
    _intf(bus.getInterface())
{
}

SessionInfo::SessionInfo(bus::bus& bus, const char* path,
                         const std::map<std::string, PropertiesVariant>& vals,
                         bool skipSignal) :
    SessionInfo(bus, path)
{
    for (const auto& v : vals)
    {
        setPropertyByName(v.first, v.second, skipSignal);
    }
}

auto SessionInfo::sessionHandle() const -> uint8_t
{
    return _sessionHandle;
}

int SessionInfo::_callback_get_SessionHandle(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* reply,
                                             void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->sessionHandle()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SessionInfo::sessionHandle(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_sessionHandle != value)
    {
        _sessionHandle = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SessionInfo_interface.property_changed(
                "SessionHandle");
        }
    }

    return _sessionHandle;
}

auto SessionInfo::sessionHandle(uint8_t val) -> uint8_t
{
    return sessionHandle(val, false);
}
int SessionInfo::_callback_set_SessionHandle(sd_bus* bus, const char* path,
                                             const char* interface,
                                             const char* property,
                                             sd_bus_message* value,
                                             void* context, sd_bus_error* error)
{
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->sessionHandle(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SessionInfo
{
static const auto _property_SessionHandle =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SessionInfo::channelNum() const -> uint8_t
{
    return _channelNum;
}

int SessionInfo::_callback_get_ChannelNum(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* reply, void* context,
                                          sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->channelNum()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SessionInfo::channelNum(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_channelNum != value)
    {
        _channelNum = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SessionInfo_interface.property_changed(
                "ChannelNum");
        }
    }

    return _channelNum;
}

auto SessionInfo::channelNum(uint8_t val) -> uint8_t
{
    return channelNum(val, false);
}
int SessionInfo::_callback_set_ChannelNum(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* value, void* context,
                                          sd_bus_error* error)
{
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->channelNum(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SessionInfo
{
static const auto _property_ChannelNum =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SessionInfo::currentPrivilege() const -> uint8_t
{
    return _currentPrivilege;
}

int SessionInfo::_callback_get_CurrentPrivilege(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->currentPrivilege()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SessionInfo::currentPrivilege(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_currentPrivilege != value)
    {
        _currentPrivilege = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SessionInfo_interface.property_changed(
                "CurrentPrivilege");
        }
    }

    return _currentPrivilege;
}

auto SessionInfo::currentPrivilege(uint8_t val) -> uint8_t
{
    return currentPrivilege(val, false);
}
int SessionInfo::_callback_set_CurrentPrivilege(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->currentPrivilege(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SessionInfo
{
static const auto _property_CurrentPrivilege =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SessionInfo::remoteIPAddr() const -> uint32_t
{
    return _remoteIPAddr;
}

int SessionInfo::_callback_get_RemoteIPAddr(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* reply,
                                            void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->remoteIPAddr()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SessionInfo::remoteIPAddr(uint32_t value, bool skipSignal) -> uint32_t
{
    if (_remoteIPAddr != value)
    {
        _remoteIPAddr = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SessionInfo_interface.property_changed(
                "RemoteIPAddr");
        }
    }

    return _remoteIPAddr;
}

auto SessionInfo::remoteIPAddr(uint32_t val) -> uint32_t
{
    return remoteIPAddr(val, false);
}
int SessionInfo::_callback_set_RemoteIPAddr(sd_bus* bus, const char* path,
                                            const char* interface,
                                            const char* property,
                                            sd_bus_message* value,
                                            void* context, sd_bus_error* error)
{
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint32_t v{};
        m.read(v);
        o->remoteIPAddr(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SessionInfo
{
static const auto _property_RemoteIPAddr =
    utility::tuple_to_array(message::types::type_id<uint32_t>());
}
} // namespace details

auto SessionInfo::remotePort() const -> uint16_t
{
    return _remotePort;
}

int SessionInfo::_callback_get_RemotePort(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* reply, void* context,
                                          sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->remotePort()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SessionInfo::remotePort(uint16_t value, bool skipSignal) -> uint16_t
{
    if (_remotePort != value)
    {
        _remotePort = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SessionInfo_interface.property_changed(
                "RemotePort");
        }
    }

    return _remotePort;
}

auto SessionInfo::remotePort(uint16_t val) -> uint16_t
{
    return remotePort(val, false);
}
int SessionInfo::_callback_set_RemotePort(sd_bus* bus, const char* path,
                                          const char* interface,
                                          const char* property,
                                          sd_bus_message* value, void* context,
                                          sd_bus_error* error)
{
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint16_t v{};
        m.read(v);
        o->remotePort(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SessionInfo
{
static const auto _property_RemotePort =
    utility::tuple_to_array(message::types::type_id<uint16_t>());
}
} // namespace details

auto SessionInfo::remoteMACAddress() const -> std::vector<uint8_t>
{
    return _remoteMACAddress;
}

int SessionInfo::_callback_get_RemoteMACAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* reply, void* context, sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->remoteMACAddress()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SessionInfo::remoteMACAddress(std::vector<uint8_t> value, bool skipSignal)
    -> std::vector<uint8_t>
{
    if (_remoteMACAddress != value)
    {
        _remoteMACAddress = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SessionInfo_interface.property_changed(
                "RemoteMACAddress");
        }
    }

    return _remoteMACAddress;
}

auto SessionInfo::remoteMACAddress(std::vector<uint8_t> val)
    -> std::vector<uint8_t>
{
    return remoteMACAddress(val, false);
}
int SessionInfo::_callback_set_RemoteMACAddress(
    sd_bus* bus, const char* path, const char* interface, const char* property,
    sd_bus_message* value, void* context, sd_bus_error* error)
{
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        std::vector<uint8_t> v{};
        m.read(v);
        o->remoteMACAddress(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SessionInfo
{
static const auto _property_RemoteMACAddress =
    utility::tuple_to_array(message::types::type_id<std::vector<uint8_t>>());
}
} // namespace details

auto SessionInfo::userID() const -> uint8_t
{
    return _userID;
}

int SessionInfo::_callback_get_UserID(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* reply, void* context,
                                      sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->userID()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SessionInfo::userID(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_userID != value)
    {
        _userID = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SessionInfo_interface.property_changed(
                "UserID");
        }
    }

    return _userID;
}

auto SessionInfo::userID(uint8_t val) -> uint8_t
{
    return userID(val, false);
}
int SessionInfo::_callback_set_UserID(sd_bus* bus, const char* path,
                                      const char* interface,
                                      const char* property,
                                      sd_bus_message* value, void* context,
                                      sd_bus_error* error)
{
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->userID(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SessionInfo
{
static const auto _property_UserID =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

auto SessionInfo::state() const -> uint8_t
{
    return _state;
}

int SessionInfo::_callback_get_State(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* reply, void* context,
                                     sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->state()));
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

auto SessionInfo::state(uint8_t value, bool skipSignal) -> uint8_t
{
    if (_state != value)
    {
        _state = value;
        if (!skipSignal)
        {
            _xyz_openbmc_project_Ipmi_SessionInfo_interface.property_changed(
                "State");
        }
    }

    return _state;
}

auto SessionInfo::state(uint8_t val) -> uint8_t
{
    return state(val, false);
}
int SessionInfo::_callback_set_State(sd_bus* bus, const char* path,
                                     const char* interface,
                                     const char* property,
                                     sd_bus_message* value, void* context,
                                     sd_bus_error* error)
{
    auto o = static_cast<SessionInfo*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if 1
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id(
                std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        uint8_t v{};
        m.read(v);
        o->state(v);
    }
    catch (sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    catch (sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }

    return true;
}

namespace details
{
namespace SessionInfo
{
static const auto _property_State =
    utility::tuple_to_array(message::types::type_id<uint8_t>());
}
} // namespace details

void SessionInfo::setPropertyByName(const std::string& _name,
                                    const PropertiesVariant& val,
                                    bool skipSignal)
{
    if (_name == "SessionHandle")
    {
        auto& v = std::get<uint8_t>(val);
        sessionHandle(v, skipSignal);
        return;
    }
    if (_name == "ChannelNum")
    {
        auto& v = std::get<uint8_t>(val);
        channelNum(v, skipSignal);
        return;
    }
    if (_name == "CurrentPrivilege")
    {
        auto& v = std::get<uint8_t>(val);
        currentPrivilege(v, skipSignal);
        return;
    }
    if (_name == "RemoteIPAddr")
    {
        auto& v = std::get<uint32_t>(val);
        remoteIPAddr(v, skipSignal);
        return;
    }
    if (_name == "RemotePort")
    {
        auto& v = std::get<uint16_t>(val);
        remotePort(v, skipSignal);
        return;
    }
    if (_name == "RemoteMACAddress")
    {
        auto& v = std::get<std::vector<uint8_t>>(val);
        remoteMACAddress(v, skipSignal);
        return;
    }
    if (_name == "UserID")
    {
        auto& v = std::get<uint8_t>(val);
        userID(v, skipSignal);
        return;
    }
    if (_name == "State")
    {
        auto& v = std::get<uint8_t>(val);
        state(v, skipSignal);
        return;
    }
}

auto SessionInfo::getPropertyByName(const std::string& _name)
    -> PropertiesVariant
{
    if (_name == "SessionHandle")
    {
        return sessionHandle();
    }
    if (_name == "ChannelNum")
    {
        return channelNum();
    }
    if (_name == "CurrentPrivilege")
    {
        return currentPrivilege();
    }
    if (_name == "RemoteIPAddr")
    {
        return remoteIPAddr();
    }
    if (_name == "RemotePort")
    {
        return remotePort();
    }
    if (_name == "RemoteMACAddress")
    {
        return remoteMACAddress();
    }
    if (_name == "UserID")
    {
        return userID();
    }
    if (_name == "State")
    {
        return state();
    }

    return PropertiesVariant();
}

const vtable::vtable_t SessionInfo::_vtable[] = {
    vtable::start(),
    vtable::property("SessionHandle",
                     details::SessionInfo::_property_SessionHandle.data(),
                     _callback_get_SessionHandle, _callback_set_SessionHandle,
                     vtable::property_::emits_change),
    vtable::property("ChannelNum",
                     details::SessionInfo::_property_ChannelNum.data(),
                     _callback_get_ChannelNum, _callback_set_ChannelNum,
                     vtable::property_::emits_change),
    vtable::property("CurrentPrivilege",
                     details::SessionInfo::_property_CurrentPrivilege.data(),
                     _callback_get_CurrentPrivilege,
                     _callback_set_CurrentPrivilege,
                     vtable::property_::emits_change),
    vtable::property("RemoteIPAddr",
                     details::SessionInfo::_property_RemoteIPAddr.data(),
                     _callback_get_RemoteIPAddr, _callback_set_RemoteIPAddr,
                     vtable::property_::emits_change),
    vtable::property("RemotePort",
                     details::SessionInfo::_property_RemotePort.data(),
                     _callback_get_RemotePort, _callback_set_RemotePort,
                     vtable::property_::emits_change),
    vtable::property("RemoteMACAddress",
                     details::SessionInfo::_property_RemoteMACAddress.data(),
                     _callback_get_RemoteMACAddress,
                     _callback_set_RemoteMACAddress,
                     vtable::property_::emits_change),
    vtable::property("UserID", details::SessionInfo::_property_UserID.data(),
                     _callback_get_UserID, _callback_set_UserID,
                     vtable::property_::emits_change),
    vtable::property("State", details::SessionInfo::_property_State.data(),
                     _callback_get_State, _callback_set_State,
                     vtable::property_::emits_change),
    vtable::end()};

} // namespace server
} // namespace Ipmi
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Inventory/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Error
{
const char* NotPresent::name() const noexcept
{
    return errName;
}
const char* NotPresent::description() const noexcept
{
    return errDesc;
}
const char* NotPresent::what() const noexcept
{
    return errWhat;
}
const char* Nonfunctional::name() const noexcept
{
    return errName;
}
const char* Nonfunctional::description() const noexcept
{
    return errDesc;
}
const char* Nonfunctional::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Chassis/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Common
{
namespace Error
{
const char* UnsupportedCommand::name() const noexcept
{
    return errName;
}
const char* UnsupportedCommand::description() const noexcept
{
    return errDesc;
}
const char* UnsupportedCommand::what() const noexcept
{
    return errWhat;
}
const char* IOError::name() const noexcept
{
    return errName;
}
const char* IOError::description() const noexcept
{
    return errDesc;
}
const char* IOError::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Common
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Control/Device/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Device
{
namespace Error
{
const char* WriteFailure::name() const noexcept
{
    return errName;
}
const char* WriteFailure::description() const noexcept
{
    return errDesc;
}
const char* WriteFailure::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Device
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Control/Host/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Host
{
namespace Error
{
const char* CommandNotSupported::name() const noexcept
{
    return errName;
}
const char* CommandNotSupported::description() const noexcept
{
    return errDesc;
}
const char* CommandNotSupported::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Host
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Software/Version/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Version
{
namespace Error
{
const char* Incompatible::name() const noexcept
{
    return errName;
}
const char* Incompatible::description() const noexcept
{
    return errDesc;
}
const char* Incompatible::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Version
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Common/Device/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Device
{
namespace Error
{
const char* ReadFailure::name() const noexcept
{
    return errName;
}
const char* ReadFailure::description() const noexcept
{
    return errDesc;
}
const char* ReadFailure::what() const noexcept
{
    return errWhat;
}
const char* WriteFailure::name() const noexcept
{
    return errName;
}
const char* WriteFailure::description() const noexcept
{
    return errDesc;
}
const char* WriteFailure::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Device
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Common/Callout/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
const char* Device::name() const noexcept
{
    return errName;
}
const char* Device::description() const noexcept
{
    return errDesc;
}
const char* Device::what() const noexcept
{
    return errWhat;
}
const char* GPIO::name() const noexcept
{
    return errName;
}
const char* GPIO::description() const noexcept
{
    return errDesc;
}
const char* GPIO::what() const noexcept
{
    return errWhat;
}
const char* IIC::name() const noexcept
{
    return errName;
}
const char* IIC::description() const noexcept
{
    return errDesc;
}
const char* IIC::what() const noexcept
{
    return errWhat;
}
const char* Inventory::name() const noexcept
{
    return errName;
}
const char* Inventory::description() const noexcept
{
    return errDesc;
}
const char* Inventory::what() const noexcept
{
    return errWhat;
}
const char* IPMISensor::name() const noexcept
{
    return errName;
}
const char* IPMISensor::description() const noexcept
{
    return errDesc;
}
const char* IPMISensor::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Common/File/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace Error
{
const char* Open::name() const noexcept
{
    return errName;
}
const char* Open::description() const noexcept
{
    return errDesc;
}
const char* Open::what() const noexcept
{
    return errWhat;
}
const char* Seek::name() const noexcept
{
    return errName;
}
const char* Seek::description() const noexcept
{
    return errDesc;
}
const char* Seek::what() const noexcept
{
    return errWhat;
}
const char* Write::name() const noexcept
{
    return errName;
}
const char* Write::description() const noexcept
{
    return errDesc;
}
const char* Write::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/State/Host/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Host
{
namespace Error
{
const char* SoftOffTimeout::name() const noexcept
{
    return errName;
}
const char* SoftOffTimeout::description() const noexcept
{
    return errDesc;
}
const char* SoftOffTimeout::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Host
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/State/Shutdown/Inventory/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace Inventory
{
namespace Error
{
const char* Fan::name() const noexcept
{
    return errName;
}
const char* Fan::description() const noexcept
{
    return errDesc;
}
const char* Fan::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Inventory
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/State/Shutdown/ThermalEvent/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace ThermalEvent
{
namespace Error
{
const char* Processor::name() const noexcept
{
    return errName;
}
const char* Processor::description() const noexcept
{
    return errDesc;
}
const char* Processor::what() const noexcept
{
    return errWhat;
}
const char* GPU::name() const noexcept
{
    return errName;
}
const char* GPU::description() const noexcept
{
    return errDesc;
}
const char* GPU::what() const noexcept
{
    return errWhat;
}
const char* Ambient::name() const noexcept
{
    return errName;
}
const char* Ambient::description() const noexcept
{
    return errDesc;
}
const char* Ambient::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace ThermalEvent
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/State/Shutdown/Power/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace Power
{
namespace Error
{
const char* Fault::name() const noexcept
{
    return errName;
}
const char* Fault::description() const noexcept
{
    return errDesc;
}
const char* Fault::what() const noexcept
{
    return errWhat;
}
const char* Blackout::name() const noexcept
{
    return errName;
}
const char* Blackout::description() const noexcept
{
    return errDesc;
}
const char* Blackout::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Power
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/User/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace Error
{
const char* UserNameExists::name() const noexcept
{
    return errName;
}
const char* UserNameExists::description() const noexcept
{
    return errDesc;
}
const char* UserNameExists::what() const noexcept
{
    return errWhat;
}
const char* UserNameDoesNotExist::name() const noexcept
{
    return errName;
}
const char* UserNameDoesNotExist::description() const noexcept
{
    return errDesc;
}
const char* UserNameDoesNotExist::what() const noexcept
{
    return errWhat;
}
const char* UserNameGroupFail::name() const noexcept
{
    return errName;
}
const char* UserNameGroupFail::description() const noexcept
{
    return errDesc;
}
const char* UserNameGroupFail::what() const noexcept
{
    return errWhat;
}
const char* UserNamePrivFail::name() const noexcept
{
    return errName;
}
const char* UserNamePrivFail::description() const noexcept
{
    return errDesc;
}
const char* UserNamePrivFail::what() const noexcept
{
    return errWhat;
}
const char* NoResource::name() const noexcept
{
    return errName;
}
const char* NoResource::description() const noexcept
{
    return errDesc;
}
const char* NoResource::what() const noexcept
{
    return errWhat;
}
const char* PrivilegeMappingExists::name() const noexcept
{
    return errName;
}
const char* PrivilegeMappingExists::description() const noexcept
{
    return errDesc;
}
const char* PrivilegeMappingExists::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Common/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
const char* Timeout::name() const noexcept
{
    return errName;
}
const char* Timeout::description() const noexcept
{
    return errDesc;
}
const char* Timeout::what() const noexcept
{
    return errWhat;
}
const char* InternalFailure::name() const noexcept
{
    return errName;
}
const char* InternalFailure::description() const noexcept
{
    return errDesc;
}
const char* InternalFailure::what() const noexcept
{
    return errWhat;
}
const char* InvalidArgument::name() const noexcept
{
    return errName;
}
const char* InvalidArgument::description() const noexcept
{
    return errDesc;
}
const char* InvalidArgument::what() const noexcept
{
    return errWhat;
}
const char* InsufficientPermission::name() const noexcept
{
    return errName;
}
const char* InsufficientPermission::description() const noexcept
{
    return errDesc;
}
const char* InsufficientPermission::what() const noexcept
{
    return errWhat;
}
const char* NotAllowed::name() const noexcept
{
    return errName;
}
const char* NotAllowed::description() const noexcept
{
    return errDesc;
}
const char* NotAllowed::what() const noexcept
{
    return errWhat;
}
const char* NoCACertificate::name() const noexcept
{
    return errName;
}
const char* NoCACertificate::description() const noexcept
{
    return errDesc;
}
const char* NoCACertificate::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Nvme/Status/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace Error
{
const char* CapacityFault::name() const noexcept
{
    return errName;
}
const char* CapacityFault::description() const noexcept
{
    return errDesc;
}
const char* CapacityFault::what() const noexcept
{
    return errWhat;
}
const char* TemperatureFault::name() const noexcept
{
    return errName;
}
const char* TemperatureFault::description() const noexcept
{
    return errDesc;
}
const char* TemperatureFault::what() const noexcept
{
    return errWhat;
}
const char* DegradesFault::name() const noexcept
{
    return errName;
}
const char* DegradesFault::description() const noexcept
{
    return errDesc;
}
const char* DegradesFault::what() const noexcept
{
    return errWhat;
}
const char* MediaFault::name() const noexcept
{
    return errName;
}
const char* MediaFault::description() const noexcept
{
    return errDesc;
}
const char* MediaFault::what() const noexcept
{
    return errWhat;
}
const char* BackupDeviceFault::name() const noexcept
{
    return errName;
}
const char* BackupDeviceFault::description() const noexcept
{
    return errDesc;
}
const char* BackupDeviceFault::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Memory/MemoryECC/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Memory
{
namespace MemoryECC
{
namespace Error
{
const char* isLoggingLimitReached::name() const noexcept
{
    return errName;
}
const char* isLoggingLimitReached::description() const noexcept
{
    return errDesc;
}
const char* isLoggingLimitReached::what() const noexcept
{
    return errWhat;
}
const char* ceCount::name() const noexcept
{
    return errName;
}
const char* ceCount::description() const noexcept
{
    return errDesc;
}
const char* ceCount::what() const noexcept
{
    return errWhat;
}
const char* ueCount::name() const noexcept
{
    return errName;
}
const char* ueCount::description() const noexcept
{
    return errDesc;
}
const char* ueCount::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace MemoryECC
} // namespace Memory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Certs/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Certs
{
namespace Error
{
const char* InvalidCertificate::name() const noexcept
{
    return errName;
}
const char* InvalidCertificate::description() const noexcept
{
    return errDesc;
}
const char* InvalidCertificate::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Certs
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Sensor/Device/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Device
{
namespace Error
{
const char* ReadFailure::name() const noexcept
{
    return errName;
}
const char* ReadFailure::description() const noexcept
{
    return errDesc;
}
const char* ReadFailure::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Device
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Sensor/Threshold/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Threshold
{
namespace Error
{
const char* CriticalHigh::name() const noexcept
{
    return errName;
}
const char* CriticalHigh::description() const noexcept
{
    return errDesc;
}
const char* CriticalHigh::what() const noexcept
{
    return errWhat;
}
const char* CriticalLow::name() const noexcept
{
    return errName;
}
const char* CriticalLow::description() const noexcept
{
    return errDesc;
}
const char* CriticalLow::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Threshold
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Time/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Time
{
namespace Error
{
const char* NotAllowed::name() const noexcept
{
    return errName;
}
const char* NotAllowed::description() const noexcept
{
    return errDesc;
}
const char* NotAllowed::what() const noexcept
{
    return errWhat;
}
const char* Failed::name() const noexcept
{
    return errName;
}
const char* Failed::description() const noexcept
{
    return errDesc;
}
const char* Failed::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Time
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

#include <xyz/openbmc_project/Dump/Create/error.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Dump
{
namespace Create
{
namespace Error
{
const char* Disabled::name() const noexcept
{
    return errName;
}
const char* Disabled::description() const noexcept
{
    return errDesc;
}
const char* Disabled::what() const noexcept
{
    return errWhat;
}
const char* QuotaExceeded::name() const noexcept
{
    return errName;
}
const char* QuotaExceeded::description() const noexcept
{
    return errDesc;
}
const char* QuotaExceeded::what() const noexcept
{
    return errWhat;
}

} // namespace Error
} // namespace Create
} // namespace Dump
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <string>
#include <tuple>
#include <type_traits>
#include <sdbusplus/exception.hpp>
#include <phosphor-logging/log.hpp>
#include <phosphor-logging/elog.hpp>

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSupplyInputFault;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Host
{
namespace Error
{
    struct SoftOffTimeout;
} // namespace Error
} // namespace Host
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace Error
{
    struct Open;
} // namespace Error
} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Fru
{
namespace Monitor
{
namespace Error
{
    struct InventoryPathError;
} // namespace Error
} // namespace Monitor
} // namespace Fru
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace Error
{
    struct Seek;
} // namespace Error
} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace Error
{
    struct UserNameGroupFail;
} // namespace Error
} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace Error
{
    struct ReadFailure;
} // namespace Error
} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace Error
{
    struct Write;
} // namespace Error
} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct Shutdown;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSupplyFanFault;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct InvalidArgument;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace Power
{
namespace Error
{
    struct Blackout;
} // namespace Error
} // namespace Power
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace Error
{
    struct ConfigFailure;
} // namespace Error
} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace ThermalEvent
{
namespace Error
{
    struct GPU;
} // namespace Error
} // namespace ThermalEvent
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Host
{
namespace Access
{
namespace Error
{
    struct ReadCFAM;
} // namespace Error
} // namespace Access
} // namespace Host
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Host
{
namespace Error
{
    struct Event;
} // namespace Error
} // namespace Host
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace Error
{
    struct DegradesFault;
} // namespace Error
} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace Inventory
{
namespace Error
{
    struct Fan;
} // namespace Error
} // namespace Inventory
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Device
{
namespace Error
{
    struct ReadFailure;
} // namespace Error
} // namespace Device
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Memory
{
namespace MemoryECC
{
namespace Error
{
    struct isLoggingLimitReached;
} // namespace Error
} // namespace MemoryECC
} // namespace Memory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace Error
{
    struct UserNamePrivFail;
} // namespace Error
} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace FSI
{
namespace Error
{
    struct MasterDetectionFailure;
} // namespace Error
} // namespace FSI
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct GPUOverTemp;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace Error
{
    struct ManifestFileFailure;
} // namespace Error
} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace ThermalEvent
{
namespace Error
{
    struct Ambient;
} // namespace Error
} // namespace ThermalEvent
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct InternalFailure;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct Device;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Host
{
namespace Error
{
    struct CommandNotSupported;
} // namespace Error
} // namespace Host
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Device
{
namespace Error
{
    struct WriteFailure;
} // namespace Error
} // namespace Device
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Certs
{
namespace Error
{
    struct InvalidCertificate;
} // namespace Error
} // namespace Certs
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Dump
{
namespace Create
{
namespace Error
{
    struct Disabled;
} // namespace Error
} // namespace Create
} // namespace Dump
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace Error
{
    struct PrivilegeMappingExists;
} // namespace Error
} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace Error
{
    struct ObjectNotFoundError;
} // namespace Error
} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct Inventory;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSupplyOutputOvercurrent;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSequencerVoltageFault;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace Error
{
    struct CapacityFault;
} // namespace Error
} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace Error
{
    struct InternalFailure;
} // namespace Error
} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct MemoryPowerFault;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Dump
{
namespace Create
{
namespace Error
{
    struct QuotaExceeded;
} // namespace Error
} // namespace Create
} // namespace Dump
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSequencerPGOODFault;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Memory
{
namespace MemoryECC
{
namespace Error
{
    struct ceCount;
} // namespace Error
} // namespace MemoryECC
} // namespace Memory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Version
{
namespace Error
{
    struct Incompatible;
} // namespace Error
} // namespace Version
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct Procedure;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace Error
{
    struct MethodError;
} // namespace Error
} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Host
{
namespace Access
{
namespace Error
{
    struct WriteCFAM;
} // namespace Error
} // namespace Access
} // namespace Host
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace Error
{
    struct TemperatureFault;
} // namespace Error
} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace Error
{
    struct OpenFailure;
} // namespace Error
} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct GPIO;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct IPMISensor;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSupplyOutputOvervoltage;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace Error
{
    struct WriteFailure;
} // namespace Error
} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace OCC
{
namespace Metrics
{
namespace Error
{
    struct Event;
} // namespace Error
} // namespace Metrics
} // namespace OCC
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace Error
{
    struct UnTarFailure;
} // namespace Error
} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Host
{
namespace Boot
{
namespace Error
{
    struct Checkstop;
} // namespace Error
} // namespace Boot
} // namespace Host
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace ThermalEvent
{
namespace Error
{
    struct Processor;
} // namespace Error
} // namespace ThermalEvent
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Host
{
namespace Boot
{
namespace Error
{
    struct WatchdogTimedOut;
} // namespace Error
} // namespace Boot
} // namespace Host
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Device
{
namespace Error
{
    struct ReadFailure;
} // namespace Error
} // namespace Device
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Error
{
    struct Nonfunctional;
} // namespace Error
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Device
{
namespace Error
{
    struct WriteFailure;
} // namespace Error
} // namespace Device
} // namespace Control
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace Error
{
    struct UserNameDoesNotExist;
} // namespace Error
} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace Error
{
    struct MediaFault;
} // namespace Error
} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerOnFailure;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Memory
{
namespace MemoryECC
{
namespace Error
{
    struct ueCount;
} // namespace Error
} // namespace MemoryECC
} // namespace Memory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace Error
{
    struct NotPresent;
} // namespace Error
} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Threshold
{
namespace Error
{
    struct CriticalLow;
} // namespace Error
} // namespace Threshold
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSupplyTemperatureFault;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Threshold
{
namespace Error
{
    struct CriticalHigh;
} // namespace Error
} // namespace Threshold
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSupplyShouldBeOn;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Common
{
namespace Error
{
    struct IOError;
} // namespace Error
} // namespace Common
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace Error
{
    struct NoResource;
} // namespace Error
} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct NoCACertificate;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace FSI
{
namespace Error
{
    struct SlaveDetectionFailure;
} // namespace Error
} // namespace FSI
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace Error
{
    struct BackupDeviceFault;
} // namespace Error
} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct InsufficientPermission;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Time
{
namespace Error
{
    struct NotAllowed;
} // namespace Error
} // namespace Time
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Time
{
namespace Error
{
    struct Failed;
} // namespace Error
} // namespace Time
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Common
{
namespace Error
{
    struct UnsupportedCommand;
} // namespace Error
} // namespace Common
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct PowerSequencerFault;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct Timeout;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct IIC;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct NotAllowed;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Host
{
namespace Error
{
    struct MaintenanceProcedure;
} // namespace Error
} // namespace Host
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace Power
{
namespace Error
{
    struct Fault;
} // namespace Error
} // namespace Power
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace Error
{
    struct UserNameExists;
} // namespace Error
} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace Error
{
    struct GPUPowerFault;
} // namespace Error
} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org
} // namespace sdbusplus


namespace phosphor
{

namespace logging
{

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _Timeout
{

struct TIMEOUT_IN_MSEC
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "TIMEOUT_IN_MSEC";
    using type = std::tuple<std::decay_t<decltype("TIMEOUT_IN_MSEC=%llu")>,uint64_t>;
    explicit constexpr TIMEOUT_IN_MSEC(uint64_t a) : _entry(entry("TIMEOUT_IN_MSEC=%llu", a)) {};
    type _entry;
};

}  // namespace _Timeout

struct Timeout
{
    static constexpr auto L = level::ERR;
    using TIMEOUT_IN_MSEC = _Timeout::TIMEOUT_IN_MSEC;
    using metadata_types = std::tuple<TIMEOUT_IN_MSEC>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::Timeout>
{
    using type = xyz::openbmc_project::Common::Timeout;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _InternalFailure
{


}  // namespace _InternalFailure

struct InternalFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure>
{
    using type = xyz::openbmc_project::Common::InternalFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _InvalidArgument
{

struct ARGUMENT_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ARGUMENT_NAME";
    using type = std::tuple<std::decay_t<decltype("ARGUMENT_NAME=%s")>,const char*>;
    explicit constexpr ARGUMENT_NAME(const char* a) : _entry(entry("ARGUMENT_NAME=%s", a)) {};
    type _entry;
};
struct ARGUMENT_VALUE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ARGUMENT_VALUE";
    using type = std::tuple<std::decay_t<decltype("ARGUMENT_VALUE=%s")>,const char*>;
    explicit constexpr ARGUMENT_VALUE(const char* a) : _entry(entry("ARGUMENT_VALUE=%s", a)) {};
    type _entry;
};

}  // namespace _InvalidArgument

struct InvalidArgument
{
    static constexpr auto L = level::ERR;
    using ARGUMENT_NAME = _InvalidArgument::ARGUMENT_NAME;
    using ARGUMENT_VALUE = _InvalidArgument::ARGUMENT_VALUE;
    using metadata_types = std::tuple<ARGUMENT_NAME, ARGUMENT_VALUE>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument>
{
    using type = xyz::openbmc_project::Common::InvalidArgument;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _InsufficientPermission
{


}  // namespace _InsufficientPermission

struct InsufficientPermission
{
    static constexpr auto L = level::INFO;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::InsufficientPermission>
{
    using type = xyz::openbmc_project::Common::InsufficientPermission;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _NotAllowed
{

struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};

}  // namespace _NotAllowed

struct NotAllowed
{
    static constexpr auto L = level::INFO;
    using REASON = _NotAllowed::REASON;
    using metadata_types = std::tuple<REASON>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::NotAllowed>
{
    using type = xyz::openbmc_project::Common::NotAllowed;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _NoCACertificate
{


}  // namespace _NoCACertificate

struct NoCACertificate
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::NoCACertificate>
{
    using type = xyz::openbmc_project::Common::NoCACertificate;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace Inventory
{
namespace _Fan
{


}  // namespace _Fan

struct Fan
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Inventory
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::State::Shutdown::Inventory::Error::Fan>
{
    using type = xyz::openbmc_project::State::Shutdown::Inventory::Fan;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Dump
{
namespace Create
{
namespace _Disabled
{


}  // namespace _Disabled

struct Disabled
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Create
} // namespace Dump
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Dump::Create::Error::Disabled>
{
    using type = xyz::openbmc_project::Dump::Create::Disabled;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Dump
{
namespace Create
{
namespace _QuotaExceeded
{

struct REASON 
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON ";
    using type = std::tuple<std::decay_t<decltype("REASON = %s")>,const char*>;
    explicit constexpr REASON (const char* a) : _entry(entry("REASON = %s", a)) {};
    type _entry;
};

}  // namespace _QuotaExceeded

struct QuotaExceeded
{
    static constexpr auto L = level::ERR;
    using REASON  = _QuotaExceeded::REASON ;
    using metadata_types = std::tuple<REASON >;

};

} // namespace Create
} // namespace Dump
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Dump::Create::Error::QuotaExceeded>
{
    using type = xyz::openbmc_project::Dump::Create::QuotaExceeded;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace _CapacityFault
{


}  // namespace _CapacityFault

struct CapacityFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Nvme::Status::Error::CapacityFault>
{
    using type = xyz::openbmc_project::Nvme::Status::CapacityFault;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace _TemperatureFault
{


}  // namespace _TemperatureFault

struct TemperatureFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Nvme::Status::Error::TemperatureFault>
{
    using type = xyz::openbmc_project::Nvme::Status::TemperatureFault;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace _DegradesFault
{


}  // namespace _DegradesFault

struct DegradesFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Nvme::Status::Error::DegradesFault>
{
    using type = xyz::openbmc_project::Nvme::Status::DegradesFault;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace _MediaFault
{


}  // namespace _MediaFault

struct MediaFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Nvme::Status::Error::MediaFault>
{
    using type = xyz::openbmc_project::Nvme::Status::MediaFault;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Nvme
{
namespace Status
{
namespace _BackupDeviceFault
{


}  // namespace _BackupDeviceFault

struct BackupDeviceFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Status
} // namespace Nvme
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Nvme::Status::Error::BackupDeviceFault>
{
    using type = xyz::openbmc_project::Nvme::Status::BackupDeviceFault;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace _MethodError
{

struct METHOD_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "METHOD_NAME";
    using type = std::tuple<std::decay_t<decltype("METHOD_NAME=%s")>,const char*>;
    explicit constexpr METHOD_NAME(const char* a) : _entry(entry("METHOD_NAME=%s", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};
struct INTERFACE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "INTERFACE";
    using type = std::tuple<std::decay_t<decltype("INTERFACE=%s")>,const char*>;
    explicit constexpr INTERFACE(const char* a) : _entry(entry("INTERFACE=%s", a)) {};
    type _entry;
};

}  // namespace _MethodError

struct MethodError
{
    static constexpr auto L = level::ERR;
    using METHOD_NAME = _MethodError::METHOD_NAME;
    using PATH = _MethodError::PATH;
    using INTERFACE = _MethodError::INTERFACE;
    using metadata_types = std::tuple<METHOD_NAME, PATH, INTERFACE>;

};

} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Led::Mapper::Error::MethodError>
{
    using type = xyz::openbmc_project::Led::Mapper::MethodError;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace _ObjectNotFoundError
{

struct METHOD_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "METHOD_NAME";
    using type = std::tuple<std::decay_t<decltype("METHOD_NAME=%s")>,const char*>;
    explicit constexpr METHOD_NAME(const char* a) : _entry(entry("METHOD_NAME=%s", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};
struct INTERFACE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "INTERFACE";
    using type = std::tuple<std::decay_t<decltype("INTERFACE=%s")>,const char*>;
    explicit constexpr INTERFACE(const char* a) : _entry(entry("INTERFACE=%s", a)) {};
    type _entry;
};

}  // namespace _ObjectNotFoundError

struct ObjectNotFoundError
{
    static constexpr auto L = level::ERR;
    using METHOD_NAME = _ObjectNotFoundError::METHOD_NAME;
    using PATH = _ObjectNotFoundError::PATH;
    using INTERFACE = _ObjectNotFoundError::INTERFACE;
    using metadata_types = std::tuple<METHOD_NAME, PATH, INTERFACE>;

};

} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Led::Mapper::Error::ObjectNotFoundError>
{
    using type = xyz::openbmc_project::Led::Mapper::ObjectNotFoundError;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Memory
{
namespace MemoryECC
{
namespace _isLoggingLimitReached
{


}  // namespace _isLoggingLimitReached

struct isLoggingLimitReached
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace MemoryECC
} // namespace Memory
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Memory::MemoryECC::Error::isLoggingLimitReached>
{
    using type = xyz::openbmc_project::Memory::MemoryECC::isLoggingLimitReached;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Memory
{
namespace MemoryECC
{
namespace _ceCount
{


}  // namespace _ceCount

struct ceCount
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace MemoryECC
} // namespace Memory
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Memory::MemoryECC::Error::ceCount>
{
    using type = xyz::openbmc_project::Memory::MemoryECC::ceCount;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Memory
{
namespace MemoryECC
{
namespace _ueCount
{


}  // namespace _ueCount

struct ueCount
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace MemoryECC
} // namespace Memory
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Memory::MemoryECC::Error::ueCount>
{
    using type = xyz::openbmc_project::Memory::MemoryECC::ueCount;
};

}

namespace example
{
namespace xyz
{
namespace openbmc_project
{
namespace Example
{
namespace Device
{
namespace _Callout
{

struct CALLOUT_ERRNO_TEST
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_ERRNO_TEST";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_ERRNO_TEST=%d")>,int32_t>;
    explicit constexpr CALLOUT_ERRNO_TEST(int32_t a) : _entry(entry("CALLOUT_ERRNO_TEST=%d", a)) {};
    type _entry;
};
struct CALLOUT_DEVICE_PATH_TEST
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_DEVICE_PATH_TEST";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_DEVICE_PATH_TEST=%s")>,const char*>;
    explicit constexpr CALLOUT_DEVICE_PATH_TEST(const char* a) : _entry(entry("CALLOUT_DEVICE_PATH_TEST=%s", a)) {};
    type _entry;
};

}  // namespace _Callout

struct Callout : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Device.Callout";
    static constexpr auto errDesc = "Generic device callout";
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO_TEST = _Callout::CALLOUT_ERRNO_TEST;
    using CALLOUT_DEVICE_PATH_TEST = _Callout::CALLOUT_DEVICE_PATH_TEST;
    using metadata_types = std::tuple<CALLOUT_ERRNO_TEST, CALLOUT_DEVICE_PATH_TEST>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Device
} // namespace Example
} // namespace openbmc_project
} // namespace xyz
} // namespace example



namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Version
{
namespace _Incompatible
{

struct MIN_VERSION
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "MIN_VERSION";
    using type = std::tuple<std::decay_t<decltype("MIN_VERSION=%s")>,const char*>;
    explicit constexpr MIN_VERSION(const char* a) : _entry(entry("MIN_VERSION=%s", a)) {};
    type _entry;
};
struct ACTUAL_VERSION
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ACTUAL_VERSION";
    using type = std::tuple<std::decay_t<decltype("ACTUAL_VERSION=%s")>,const char*>;
    explicit constexpr ACTUAL_VERSION(const char* a) : _entry(entry("ACTUAL_VERSION=%s", a)) {};
    type _entry;
};
struct VERSION_PURPOSE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "VERSION_PURPOSE";
    using type = std::tuple<std::decay_t<decltype("VERSION_PURPOSE=%s")>,const char*>;
    explicit constexpr VERSION_PURPOSE(const char* a) : _entry(entry("VERSION_PURPOSE=%s", a)) {};
    type _entry;
};

}  // namespace _Incompatible

struct Incompatible
{
    static constexpr auto L = level::ERR;
    using MIN_VERSION = _Incompatible::MIN_VERSION;
    using ACTUAL_VERSION = _Incompatible::ACTUAL_VERSION;
    using VERSION_PURPOSE = _Incompatible::VERSION_PURPOSE;
    using metadata_types = std::tuple<MIN_VERSION, ACTUAL_VERSION, VERSION_PURPOSE>;

};

} // namespace Version
} // namespace Software
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Software::Version::Error::Incompatible>
{
    using type = xyz::openbmc_project::Software::Version::Incompatible;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Threshold
{
namespace _CriticalHigh
{

struct SENSOR_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SENSOR_DATA";
    using type = std::tuple<std::decay_t<decltype("SENSOR_DATA=%s")>,const char*>;
    explicit constexpr SENSOR_DATA(const char* a) : _entry(entry("SENSOR_DATA=%s", a)) {};
    type _entry;
};

}  // namespace _CriticalHigh

struct CriticalHigh
{
    static constexpr auto L = level::ERR;
    using SENSOR_DATA = _CriticalHigh::SENSOR_DATA;
    using metadata_types = std::tuple<SENSOR_DATA>;

};

} // namespace Threshold
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Sensor::Threshold::Error::CriticalHigh>
{
    using type = xyz::openbmc_project::Sensor::Threshold::CriticalHigh;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Threshold
{
namespace _CriticalLow
{

struct SENSOR_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SENSOR_DATA";
    using type = std::tuple<std::decay_t<decltype("SENSOR_DATA=%s")>,const char*>;
    explicit constexpr SENSOR_DATA(const char* a) : _entry(entry("SENSOR_DATA=%s", a)) {};
    type _entry;
};

}  // namespace _CriticalLow

struct CriticalLow
{
    static constexpr auto L = level::ERR;
    using SENSOR_DATA = _CriticalLow::SENSOR_DATA;
    using metadata_types = std::tuple<SENSOR_DATA>;

};

} // namespace Threshold
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Sensor::Threshold::Error::CriticalLow>
{
    using type = xyz::openbmc_project::Sensor::Threshold::CriticalLow;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace _Open
{

struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};

}  // namespace _Open

struct Open
{
    static constexpr auto L = level::ERR;
    using ERRNO = _Open::ERRNO;
    using PATH = _Open::PATH;
    using metadata_types = std::tuple<ERRNO, PATH>;

};

} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::File::Error::Open>
{
    using type = xyz::openbmc_project::Common::File::Open;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace _Seek
{

struct OFFSET
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "OFFSET";
    using type = std::tuple<std::decay_t<decltype("OFFSET=%ll")>,int64_t>;
    explicit constexpr OFFSET(int64_t a) : _entry(entry("OFFSET=%ll", a)) {};
    type _entry;
};
struct WHENCE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "WHENCE";
    using type = std::tuple<std::decay_t<decltype("WHENCE=%d")>,int32_t>;
    explicit constexpr WHENCE(int32_t a) : _entry(entry("WHENCE=%d", a)) {};
    type _entry;
};
struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};

}  // namespace _Seek

struct Seek
{
    static constexpr auto L = level::ERR;
    using OFFSET = _Seek::OFFSET;
    using WHENCE = _Seek::WHENCE;
    using ERRNO = _Seek::ERRNO;
    using PATH = _Seek::PATH;
    using metadata_types = std::tuple<OFFSET, WHENCE, ERRNO, PATH>;

};

} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::File::Error::Seek>
{
    using type = xyz::openbmc_project::Common::File::Seek;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace _Write
{

struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};

}  // namespace _Write

struct Write
{
    static constexpr auto L = level::ERR;
    using ERRNO = _Write::ERRNO;
    using PATH = _Write::PATH;
    using metadata_types = std::tuple<ERRNO, PATH>;

};

} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::File::Error::Write>
{
    using type = xyz::openbmc_project::Common::File::Write;
};

}

namespace org
{
namespace open_power
{
namespace Host
{
namespace Boot
{
namespace _Checkstop
{


}  // namespace _Checkstop

struct Checkstop
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Boot
} // namespace Host
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Host::Boot::Error::Checkstop>
{
    using type = org::open_power::Host::Boot::Checkstop;
};

}

namespace org
{
namespace open_power
{
namespace Host
{
namespace Boot
{
namespace _WatchdogTimedOut
{


}  // namespace _WatchdogTimedOut

struct WatchdogTimedOut
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Boot
} // namespace Host
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Host::Boot::Error::WatchdogTimedOut>
{
    using type = org::open_power::Host::Boot::WatchdogTimedOut;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Certs
{
namespace _InvalidCertificate
{

struct REASON 
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON ";
    using type = std::tuple<std::decay_t<decltype("REASON = %s")>,const char*>;
    explicit constexpr REASON (const char* a) : _entry(entry("REASON = %s", a)) {};
    type _entry;
};

}  // namespace _InvalidCertificate

struct InvalidCertificate
{
    static constexpr auto L = level::ERR;
    using REASON  = _InvalidCertificate::REASON ;
    using metadata_types = std::tuple<REASON >;

};

} // namespace Certs
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Certs::Error::InvalidCertificate>
{
    using type = xyz::openbmc_project::Certs::InvalidCertificate;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace ThermalEvent
{
namespace _Processor
{


}  // namespace _Processor

struct Processor
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace ThermalEvent
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::State::Shutdown::ThermalEvent::Error::Processor>
{
    using type = xyz::openbmc_project::State::Shutdown::ThermalEvent::Processor;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace ThermalEvent
{
namespace _GPU
{


}  // namespace _GPU

struct GPU
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace ThermalEvent
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::State::Shutdown::ThermalEvent::Error::GPU>
{
    using type = xyz::openbmc_project::State::Shutdown::ThermalEvent::GPU;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace ThermalEvent
{
namespace _Ambient
{


}  // namespace _Ambient

struct Ambient
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace ThermalEvent
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::State::Shutdown::ThermalEvent::Error::Ambient>
{
    using type = xyz::openbmc_project::State::Shutdown::ThermalEvent::Ambient;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _Shutdown
{


}  // namespace _Shutdown

struct Shutdown
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::Shutdown>
{
    using type = org::open_power::Witherspoon::Fault::Shutdown;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerOnFailure
{


}  // namespace _PowerOnFailure

struct PowerOnFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerOnFailure>
{
    using type = org::open_power::Witherspoon::Fault::PowerOnFailure;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSequencerVoltageFault
{

struct RAIL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAIL";
    using type = std::tuple<std::decay_t<decltype("RAIL=%d")>,uint16_t>;
    explicit constexpr RAIL(uint16_t a) : _entry(entry("RAIL=%d", a)) {};
    type _entry;
};
struct RAIL_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAIL_NAME";
    using type = std::tuple<std::decay_t<decltype("RAIL_NAME=%s")>,const char*>;
    explicit constexpr RAIL_NAME(const char* a) : _entry(entry("RAIL_NAME=%s", a)) {};
    type _entry;
};
struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSequencerVoltageFault

struct PowerSequencerVoltageFault
{
    static constexpr auto L = level::ERR;
    using RAIL = _PowerSequencerVoltageFault::RAIL;
    using RAIL_NAME = _PowerSequencerVoltageFault::RAIL_NAME;
    using RAW_STATUS = _PowerSequencerVoltageFault::RAW_STATUS;
    using metadata_types = std::tuple<RAIL, RAIL_NAME, RAW_STATUS>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSequencerVoltageFault>
{
    using type = org::open_power::Witherspoon::Fault::PowerSequencerVoltageFault;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSequencerPGOODFault
{

struct INPUT_NUM
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "INPUT_NUM";
    using type = std::tuple<std::decay_t<decltype("INPUT_NUM=%d")>,uint16_t>;
    explicit constexpr INPUT_NUM(uint16_t a) : _entry(entry("INPUT_NUM=%d", a)) {};
    type _entry;
};
struct INPUT_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "INPUT_NAME";
    using type = std::tuple<std::decay_t<decltype("INPUT_NAME=%s")>,const char*>;
    explicit constexpr INPUT_NAME(const char* a) : _entry(entry("INPUT_NAME=%s", a)) {};
    type _entry;
};
struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSequencerPGOODFault

struct PowerSequencerPGOODFault
{
    static constexpr auto L = level::ERR;
    using INPUT_NUM = _PowerSequencerPGOODFault::INPUT_NUM;
    using INPUT_NAME = _PowerSequencerPGOODFault::INPUT_NAME;
    using RAW_STATUS = _PowerSequencerPGOODFault::RAW_STATUS;
    using metadata_types = std::tuple<INPUT_NUM, INPUT_NAME, RAW_STATUS>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSequencerPGOODFault>
{
    using type = org::open_power::Witherspoon::Fault::PowerSequencerPGOODFault;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSequencerFault
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSequencerFault

struct PowerSequencerFault
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _PowerSequencerFault::RAW_STATUS;
    using metadata_types = std::tuple<RAW_STATUS>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSequencerFault>
{
    using type = org::open_power::Witherspoon::Fault::PowerSequencerFault;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace FSI
{
namespace _SlaveDetectionFailure
{

struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};

}  // namespace _SlaveDetectionFailure

struct SlaveDetectionFailure
{
    static constexpr auto L = level::ERR;
    using ERRNO = _SlaveDetectionFailure::ERRNO;
    using metadata_types = std::tuple<ERRNO>;

};

} // namespace FSI
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::FSI::Error::SlaveDetectionFailure>
{
    using type = org::open_power::Proc::FSI::SlaveDetectionFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace Power
{
namespace _Fault
{


}  // namespace _Fault

struct Fault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Power
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::State::Shutdown::Power::Error::Fault>
{
    using type = xyz::openbmc_project::State::Shutdown::Power::Fault;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Shutdown
{
namespace Power
{
namespace _Blackout
{


}  // namespace _Blackout

struct Blackout
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Power
} // namespace Shutdown
} // namespace State
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::State::Shutdown::Power::Error::Blackout>
{
    using type = xyz::openbmc_project::State::Shutdown::Power::Blackout;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _Device
{

struct CALLOUT_ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_ERRNO";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_ERRNO=%d")>,int32_t>;
    explicit constexpr CALLOUT_ERRNO(int32_t a) : _entry(entry("CALLOUT_ERRNO=%d", a)) {};
    type _entry;
};
struct CALLOUT_DEVICE_PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_DEVICE_PATH";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_DEVICE_PATH=%s")>,const char*>;
    explicit constexpr CALLOUT_DEVICE_PATH(const char* a) : _entry(entry("CALLOUT_DEVICE_PATH=%s", a)) {};
    type _entry;
};

}  // namespace _Device

struct Device
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = _Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = _Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::Device>
{
    using type = xyz::openbmc_project::Common::Callout::Device;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _GPIO
{

struct CALLOUT_GPIO_NUM
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_GPIO_NUM";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_GPIO_NUM=%u")>,uint32_t>;
    explicit constexpr CALLOUT_GPIO_NUM(uint32_t a) : _entry(entry("CALLOUT_GPIO_NUM=%u", a)) {};
    type _entry;
};

}  // namespace _GPIO

struct GPIO
{
    static constexpr auto L = level::ERR;
    using CALLOUT_GPIO_NUM = _GPIO::CALLOUT_GPIO_NUM;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_GPIO_NUM, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::GPIO>
{
    using type = xyz::openbmc_project::Common::Callout::GPIO;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _IIC
{

struct CALLOUT_IIC_BUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_IIC_BUS";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_IIC_BUS=%s")>,const char*>;
    explicit constexpr CALLOUT_IIC_BUS(const char* a) : _entry(entry("CALLOUT_IIC_BUS=%s", a)) {};
    type _entry;
};
struct CALLOUT_IIC_ADDR
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_IIC_ADDR";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_IIC_ADDR=0x%hx")>,uint16_t>;
    explicit constexpr CALLOUT_IIC_ADDR(uint16_t a) : _entry(entry("CALLOUT_IIC_ADDR=0x%hx", a)) {};
    type _entry;
};

}  // namespace _IIC

struct IIC
{
    static constexpr auto L = level::ERR;
    using CALLOUT_IIC_BUS = _IIC::CALLOUT_IIC_BUS;
    using CALLOUT_IIC_ADDR = _IIC::CALLOUT_IIC_ADDR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_IIC_BUS, CALLOUT_IIC_ADDR, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::IIC>
{
    using type = xyz::openbmc_project::Common::Callout::IIC;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _Inventory
{

struct CALLOUT_INVENTORY_PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_INVENTORY_PATH";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_INVENTORY_PATH=%s")>,const char*>;
    explicit constexpr CALLOUT_INVENTORY_PATH(const char* a) : _entry(entry("CALLOUT_INVENTORY_PATH=%s", a)) {};
    type _entry;
};

}  // namespace _Inventory

struct Inventory
{
    static constexpr auto L = level::ERR;
    using CALLOUT_INVENTORY_PATH = _Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<CALLOUT_INVENTORY_PATH>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::Inventory>
{
    using type = xyz::openbmc_project::Common::Callout::Inventory;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _IPMISensor
{

struct CALLOUT_IPMI_SENSOR_NUM
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_IPMI_SENSOR_NUM";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_IPMI_SENSOR_NUM=%u")>,uint32_t>;
    explicit constexpr CALLOUT_IPMI_SENSOR_NUM(uint32_t a) : _entry(entry("CALLOUT_IPMI_SENSOR_NUM=%u", a)) {};
    type _entry;
};

}  // namespace _IPMISensor

struct IPMISensor
{
    static constexpr auto L = level::ERR;
    using CALLOUT_IPMI_SENSOR_NUM = _IPMISensor::CALLOUT_IPMI_SENSOR_NUM;
    using metadata_types = std::tuple<CALLOUT_IPMI_SENSOR_NUM>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::IPMISensor>
{
    using type = xyz::openbmc_project::Common::Callout::IPMISensor;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Fru
{
namespace Monitor
{
namespace _InventoryPathError
{

struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};

}  // namespace _InventoryPathError

struct InventoryPathError
{
    static constexpr auto L = level::ERR;
    using PATH = _InventoryPathError::PATH;
    using metadata_types = std::tuple<PATH>;

};

} // namespace Monitor
} // namespace Fru
} // namespace Led
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Led::Fru::Monitor::Error::InventoryPathError>
{
    using type = xyz::openbmc_project::Led::Fru::Monitor::InventoryPathError;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Host
{
namespace _CommandNotSupported
{


}  // namespace _CommandNotSupported

struct CommandNotSupported
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Host
} // namespace Control
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Control::Host::Error::CommandNotSupported>
{
    using type = xyz::openbmc_project::Control::Host::CommandNotSupported;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Device
{
namespace _ReadFailure
{


}  // namespace _ReadFailure

struct ReadFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Device
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Device::Error::ReadFailure>
{
    using type = xyz::openbmc_project::Common::Device::ReadFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Device
{
namespace _WriteFailure
{


}  // namespace _WriteFailure

struct WriteFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Device
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Device::Error::WriteFailure>
{
    using type = xyz::openbmc_project::Common::Device::WriteFailure;
};

}

namespace example
{
namespace xyz
{
namespace openbmc_project
{
namespace Example
{
namespace Elog
{
namespace _TestErrorTwo
{

struct DEV_ADDR
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "DEV_ADDR";
    using type = std::tuple<std::decay_t<decltype("DEV_ADDR=0x%.8X")>,uint32_t>;
    explicit constexpr DEV_ADDR(uint32_t a) : _entry(entry("DEV_ADDR=0x%.8X", a)) {};
    type _entry;
};
struct DEV_ID
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "DEV_ID";
    using type = std::tuple<std::decay_t<decltype("DEV_ID=%u")>,uint32_t>;
    explicit constexpr DEV_ID(uint32_t a) : _entry(entry("DEV_ID=%u", a)) {};
    type _entry;
};
struct DEV_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "DEV_NAME";
    using type = std::tuple<std::decay_t<decltype("DEV_NAME=%s")>,const char*>;
    explicit constexpr DEV_NAME(const char* a) : _entry(entry("DEV_NAME=%s", a)) {};
    type _entry;
};

}  // namespace _TestErrorTwo

struct TestErrorTwo : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Elog.TestErrorTwo";
    static constexpr auto errDesc = "This is test error two";
    static constexpr auto L = level::ERR;
    using DEV_ADDR = _TestErrorTwo::DEV_ADDR;
    using DEV_ID = _TestErrorTwo::DEV_ID;
    using DEV_NAME = _TestErrorTwo::DEV_NAME;
    using metadata_types = std::tuple<DEV_ADDR, DEV_ID, DEV_NAME>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Elog
} // namespace Example
} // namespace openbmc_project
} // namespace xyz
} // namespace example



namespace example
{
namespace xyz
{
namespace openbmc_project
{
namespace Example
{
namespace Elog
{
namespace _AutoTestSimple
{

struct STRING
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "STRING";
    using type = std::tuple<std::decay_t<decltype("STRING=%s")>,const char*>;
    explicit constexpr STRING(const char* a) : _entry(entry("STRING=%s", a)) {};
    type _entry;
};

}  // namespace _AutoTestSimple

struct AutoTestSimple : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Elog.AutoTestSimple";
    static constexpr auto errDesc = "This is a simple test error.";
    static constexpr auto L = level::ERR;
    using STRING = _AutoTestSimple::STRING;
    using metadata_types = std::tuple<STRING>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Elog
} // namespace Example
} // namespace openbmc_project
} // namespace xyz
} // namespace example



namespace example
{
namespace xyz
{
namespace openbmc_project
{
namespace Example
{
namespace Elog
{
namespace _TestCallout
{

struct DEV_ADDR
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "DEV_ADDR";
    using type = std::tuple<std::decay_t<decltype("DEV_ADDR=0x%.8X")>,uint32_t>;
    explicit constexpr DEV_ADDR(uint32_t a) : _entry(entry("DEV_ADDR=0x%.8X", a)) {};
    type _entry;
};

}  // namespace _TestCallout

struct TestCallout : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Elog.TestCallout";
    static constexpr auto errDesc = "This is test error TestCallout";
    static constexpr auto L = level::ERR;
    using DEV_ADDR = _TestCallout::DEV_ADDR;
    using CALLOUT_ERRNO_TEST = example::xyz::openbmc_project::Example::Device::Callout::CALLOUT_ERRNO_TEST;
    using CALLOUT_DEVICE_PATH_TEST = example::xyz::openbmc_project::Example::Device::Callout::CALLOUT_DEVICE_PATH_TEST;
    using metadata_types = std::tuple<DEV_ADDR, CALLOUT_ERRNO_TEST, CALLOUT_DEVICE_PATH_TEST>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Elog
} // namespace Example
} // namespace openbmc_project
} // namespace xyz
} // namespace example



namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace _UserNameExists
{


}  // namespace _UserNameExists

struct UserNameExists
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::User::Common::Error::UserNameExists>
{
    using type = xyz::openbmc_project::User::Common::UserNameExists;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace _UserNameDoesNotExist
{


}  // namespace _UserNameDoesNotExist

struct UserNameDoesNotExist
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::User::Common::Error::UserNameDoesNotExist>
{
    using type = xyz::openbmc_project::User::Common::UserNameDoesNotExist;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace _UserNameGroupFail
{

struct REASON 
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON ";
    using type = std::tuple<std::decay_t<decltype("REASON = %s")>,const char*>;
    explicit constexpr REASON (const char* a) : _entry(entry("REASON = %s", a)) {};
    type _entry;
};

}  // namespace _UserNameGroupFail

struct UserNameGroupFail
{
    static constexpr auto L = level::ERR;
    using REASON  = _UserNameGroupFail::REASON ;
    using metadata_types = std::tuple<REASON >;

};

} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::User::Common::Error::UserNameGroupFail>
{
    using type = xyz::openbmc_project::User::Common::UserNameGroupFail;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace _UserNamePrivFail
{

struct REASON 
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON ";
    using type = std::tuple<std::decay_t<decltype("REASON = %s")>,const char*>;
    explicit constexpr REASON (const char* a) : _entry(entry("REASON = %s", a)) {};
    type _entry;
};

}  // namespace _UserNamePrivFail

struct UserNamePrivFail
{
    static constexpr auto L = level::ERR;
    using REASON  = _UserNamePrivFail::REASON ;
    using metadata_types = std::tuple<REASON >;

};

} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::User::Common::Error::UserNamePrivFail>
{
    using type = xyz::openbmc_project::User::Common::UserNamePrivFail;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace _NoResource
{

struct REASON 
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON ";
    using type = std::tuple<std::decay_t<decltype("REASON = %s")>,const char*>;
    explicit constexpr REASON (const char* a) : _entry(entry("REASON = %s", a)) {};
    type _entry;
};

}  // namespace _NoResource

struct NoResource
{
    static constexpr auto L = level::ERR;
    using REASON  = _NoResource::REASON ;
    using metadata_types = std::tuple<REASON >;

};

} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::User::Common::Error::NoResource>
{
    using type = xyz::openbmc_project::User::Common::NoResource;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace User
{
namespace Common
{
namespace _PrivilegeMappingExists
{


}  // namespace _PrivilegeMappingExists

struct PrivilegeMappingExists
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace User
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::User::Common::Error::PrivilegeMappingExists>
{
    using type = xyz::openbmc_project::User::Common::PrivilegeMappingExists;
};

}

namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace _OpenFailure
{


}  // namespace _OpenFailure

struct OpenFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::Device::Error::OpenFailure>
{
    using type = org::open_power::OCC::Device::OpenFailure;
};

}

namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace _ReadFailure
{


}  // namespace _ReadFailure

struct ReadFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::Device::Error::ReadFailure>
{
    using type = org::open_power::OCC::Device::ReadFailure;
};

}

namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace _WriteFailure
{


}  // namespace _WriteFailure

struct WriteFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::Device::Error::WriteFailure>
{
    using type = org::open_power::OCC::Device::WriteFailure;
};

}

namespace org
{
namespace open_power
{
namespace OCC
{
namespace Device
{
namespace _ConfigFailure
{


}  // namespace _ConfigFailure

struct ConfigFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Device
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::Device::Error::ConfigFailure>
{
    using type = org::open_power::OCC::Device::ConfigFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace _UnTarFailure
{

struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};

}  // namespace _UnTarFailure

struct UnTarFailure
{
    static constexpr auto L = level::ERR;
    using PATH = _UnTarFailure::PATH;
    using metadata_types = std::tuple<PATH>;

};

} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Software::Image::Error::UnTarFailure>
{
    using type = xyz::openbmc_project::Software::Image::UnTarFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace _ManifestFileFailure
{

struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};

}  // namespace _ManifestFileFailure

struct ManifestFileFailure
{
    static constexpr auto L = level::ERR;
    using PATH = _ManifestFileFailure::PATH;
    using metadata_types = std::tuple<PATH>;

};

} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Software::Image::Error::ManifestFileFailure>
{
    using type = xyz::openbmc_project::Software::Image::ManifestFileFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace _InternalFailure
{

struct FAIL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FAIL";
    using type = std::tuple<std::decay_t<decltype("FAIL=%s")>,const char*>;
    explicit constexpr FAIL(const char* a) : _entry(entry("FAIL=%s", a)) {};
    type _entry;
};

}  // namespace _InternalFailure

struct InternalFailure
{
    static constexpr auto L = level::ERR;
    using FAIL = _InternalFailure::FAIL;
    using metadata_types = std::tuple<FAIL>;

};

} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Software::Image::Error::InternalFailure>
{
    using type = xyz::openbmc_project::Software::Image::InternalFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Common
{
namespace _UnsupportedCommand
{


}  // namespace _UnsupportedCommand

struct UnsupportedCommand
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Chassis::Common::Error::UnsupportedCommand>
{
    using type = xyz::openbmc_project::Chassis::Common::UnsupportedCommand;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Chassis
{
namespace Common
{
namespace _IOError
{


}  // namespace _IOError

struct IOError
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace Chassis
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Chassis::Common::Error::IOError>
{
    using type = xyz::openbmc_project::Chassis::Common::IOError;
};

}

namespace org
{
namespace open_power
{
namespace Common
{
namespace Callout
{
namespace _Procedure
{

struct PROCEDURE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PROCEDURE";
    using type = std::tuple<std::decay_t<decltype("PROCEDURE=%u")>,uint32_t>;
    explicit constexpr PROCEDURE(uint32_t a) : _entry(entry("PROCEDURE=%u", a)) {};
    type _entry;
};

}  // namespace _Procedure

struct Procedure
{
    static constexpr auto L = level::ERR;
    using PROCEDURE = _Procedure::PROCEDURE;
    using metadata_types = std::tuple<PROCEDURE>;

};

} // namespace Callout
} // namespace Common
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Common::Callout::Error::Procedure>
{
    using type = org::open_power::Common::Callout::Procedure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace State
{
namespace Host
{
namespace _SoftOffTimeout
{


}  // namespace _SoftOffTimeout

struct SoftOffTimeout
{
    static constexpr auto L = level::ERR;
    using TIMEOUT_IN_MSEC = xyz::openbmc_project::Common::Timeout::TIMEOUT_IN_MSEC;
    using metadata_types = std::tuple<TIMEOUT_IN_MSEC>;

};

} // namespace Host
} // namespace State
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::State::Host::Error::SoftOffTimeout>
{
    using type = xyz::openbmc_project::State::Host::SoftOffTimeout;
};

}

namespace org
{
namespace open_power
{
namespace OCC
{
namespace Metrics
{
namespace _Event
{

struct ESEL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ESEL";
    using type = std::tuple<std::decay_t<decltype("ESEL=%s")>,const char*>;
    explicit constexpr ESEL(const char* a) : _entry(entry("ESEL=%s", a)) {};
    type _entry;
};

}  // namespace _Event

struct Event
{
    static constexpr auto L = level::INFO;
    using ESEL = _Event::ESEL;
    using metadata_types = std::tuple<ESEL>;

};

} // namespace Metrics
} // namespace OCC
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::OCC::Metrics::Error::Event>
{
    using type = org::open_power::OCC::Metrics::Event;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Time
{
namespace _NotAllowed
{

struct OWNER
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "OWNER";
    using type = std::tuple<std::decay_t<decltype("OWNER=%s")>,const char*>;
    explicit constexpr OWNER(const char* a) : _entry(entry("OWNER=%s", a)) {};
    type _entry;
};
struct SYNC_METHOD
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SYNC_METHOD";
    using type = std::tuple<std::decay_t<decltype("SYNC_METHOD=%s")>,const char*>;
    explicit constexpr SYNC_METHOD(const char* a) : _entry(entry("SYNC_METHOD=%s", a)) {};
    type _entry;
};

}  // namespace _NotAllowed

struct NotAllowed
{
    static constexpr auto L = level::ERR;
    using OWNER = _NotAllowed::OWNER;
    using SYNC_METHOD = _NotAllowed::SYNC_METHOD;
    using REASON = xyz::openbmc_project::Common::NotAllowed::REASON;
    using metadata_types = std::tuple<OWNER, SYNC_METHOD, REASON>;

};

} // namespace Time
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Time::Error::NotAllowed>
{
    using type = xyz::openbmc_project::Time::NotAllowed;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Time
{
namespace _Failed
{

struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};

}  // namespace _Failed

struct Failed
{
    static constexpr auto L = level::ERR;
    using REASON = _Failed::REASON;
    using metadata_types = std::tuple<REASON>;

};

} // namespace Time
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Time::Error::Failed>
{
    using type = xyz::openbmc_project::Time::Failed;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Sensor
{
namespace Device
{
namespace _ReadFailure
{


}  // namespace _ReadFailure

struct ReadFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Device
} // namespace Sensor
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Sensor::Device::Error::ReadFailure>
{
    using type = xyz::openbmc_project::Sensor::Device::ReadFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace _NotPresent
{


}  // namespace _NotPresent

struct NotPresent
{
    static constexpr auto L = level::ERR;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<CALLOUT_INVENTORY_PATH>;

};

} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Inventory::Error::NotPresent>
{
    using type = xyz::openbmc_project::Inventory::NotPresent;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Inventory
{
namespace _Nonfunctional
{


}  // namespace _Nonfunctional

struct Nonfunctional
{
    static constexpr auto L = level::ERR;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<CALLOUT_INVENTORY_PATH>;

};

} // namespace Inventory
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Inventory::Error::Nonfunctional>
{
    using type = xyz::openbmc_project::Inventory::Nonfunctional;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Control
{
namespace Device
{
namespace _WriteFailure
{


}  // namespace _WriteFailure

struct WriteFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Device
} // namespace Control
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Control::Device::Error::WriteFailure>
{
    using type = xyz::openbmc_project::Control::Device::WriteFailure;
};

}

namespace org
{
namespace open_power
{
namespace Host
{
namespace Access
{
namespace _WriteCFAM
{

struct ADDRESS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ADDRESS";
    using type = std::tuple<std::decay_t<decltype("ADDRESS=0x%X")>,uint32_t>;
    explicit constexpr ADDRESS(uint32_t a) : _entry(entry("ADDRESS=0x%X", a)) {};
    type _entry;
};

}  // namespace _WriteCFAM

struct WriteCFAM
{
    static constexpr auto L = level::ERR;
    using ADDRESS = _WriteCFAM::ADDRESS;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<ADDRESS, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Access
} // namespace Host
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Host::Access::Error::WriteCFAM>
{
    using type = org::open_power::Host::Access::WriteCFAM;
};

}

namespace org
{
namespace open_power
{
namespace Host
{
namespace Access
{
namespace _ReadCFAM
{

struct ADDRESS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ADDRESS";
    using type = std::tuple<std::decay_t<decltype("ADDRESS=0x%X")>,uint32_t>;
    explicit constexpr ADDRESS(uint32_t a) : _entry(entry("ADDRESS=0x%X", a)) {};
    type _entry;
};

}  // namespace _ReadCFAM

struct ReadCFAM
{
    static constexpr auto L = level::ERR;
    using ADDRESS = _ReadCFAM::ADDRESS;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<ADDRESS, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Access
} // namespace Host
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Host::Access::Error::ReadCFAM>
{
    using type = org::open_power::Host::Access::ReadCFAM;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSupplyInputFault
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSupplyInputFault

struct PowerSupplyInputFault
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _PowerSupplyInputFault::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSupplyInputFault>
{
    using type = org::open_power::Witherspoon::Fault::PowerSupplyInputFault;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSupplyShouldBeOn
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSupplyShouldBeOn

struct PowerSupplyShouldBeOn
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _PowerSupplyShouldBeOn::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSupplyShouldBeOn>
{
    using type = org::open_power::Witherspoon::Fault::PowerSupplyShouldBeOn;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSupplyOutputOvercurrent
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSupplyOutputOvercurrent

struct PowerSupplyOutputOvercurrent
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _PowerSupplyOutputOvercurrent::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSupplyOutputOvercurrent>
{
    using type = org::open_power::Witherspoon::Fault::PowerSupplyOutputOvercurrent;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSupplyOutputOvervoltage
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSupplyOutputOvervoltage

struct PowerSupplyOutputOvervoltage
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _PowerSupplyOutputOvervoltage::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSupplyOutputOvervoltage>
{
    using type = org::open_power::Witherspoon::Fault::PowerSupplyOutputOvervoltage;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSupplyFanFault
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSupplyFanFault

struct PowerSupplyFanFault
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _PowerSupplyFanFault::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSupplyFanFault>
{
    using type = org::open_power::Witherspoon::Fault::PowerSupplyFanFault;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _PowerSupplyTemperatureFault
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _PowerSupplyTemperatureFault

struct PowerSupplyTemperatureFault
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _PowerSupplyTemperatureFault::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::PowerSupplyTemperatureFault>
{
    using type = org::open_power::Witherspoon::Fault::PowerSupplyTemperatureFault;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _GPUPowerFault
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _GPUPowerFault

struct GPUPowerFault
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _GPUPowerFault::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::GPUPowerFault>
{
    using type = org::open_power::Witherspoon::Fault::GPUPowerFault;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _GPUOverTemp
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _GPUOverTemp

struct GPUOverTemp
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _GPUOverTemp::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::GPUOverTemp>
{
    using type = org::open_power::Witherspoon::Fault::GPUOverTemp;
};

}

namespace org
{
namespace open_power
{
namespace Witherspoon
{
namespace Fault
{
namespace _MemoryPowerFault
{

struct RAW_STATUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RAW_STATUS";
    using type = std::tuple<std::decay_t<decltype("RAW_STATUS=%s")>,const char*>;
    explicit constexpr RAW_STATUS(const char* a) : _entry(entry("RAW_STATUS=%s", a)) {};
    type _entry;
};

}  // namespace _MemoryPowerFault

struct MemoryPowerFault
{
    static constexpr auto L = level::ERR;
    using RAW_STATUS = _MemoryPowerFault::RAW_STATUS;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<RAW_STATUS, CALLOUT_INVENTORY_PATH>;

};

} // namespace Fault
} // namespace Witherspoon
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Witherspoon::Fault::Error::MemoryPowerFault>
{
    using type = org::open_power::Witherspoon::Fault::MemoryPowerFault;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace FSI
{
namespace _MasterDetectionFailure
{


}  // namespace _MasterDetectionFailure

struct MasterDetectionFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace FSI
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::FSI::Error::MasterDetectionFailure>
{
    using type = org::open_power::Proc::FSI::MasterDetectionFailure;
};

}

namespace org
{
namespace open_power
{
namespace Host
{
namespace _Event
{

struct ESEL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ESEL";
    using type = std::tuple<std::decay_t<decltype("ESEL=%s")>,const char*>;
    explicit constexpr ESEL(const char* a) : _entry(entry("ESEL=%s", a)) {};
    type _entry;
};

}  // namespace _Event

struct Event
{
    static constexpr auto L = level::ERR;
    using ESEL = _Event::ESEL;
    using CALLOUT_INVENTORY_PATH = xyz::openbmc_project::Common::Callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<ESEL, CALLOUT_INVENTORY_PATH>;

};

} // namespace Host
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Host::Error::Event>
{
    using type = org::open_power::Host::Event;
};

}

namespace org
{
namespace open_power
{
namespace Host
{
namespace _MaintenanceProcedure
{

struct ESEL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ESEL";
    using type = std::tuple<std::decay_t<decltype("ESEL=%s")>,const char*>;
    explicit constexpr ESEL(const char* a) : _entry(entry("ESEL=%s", a)) {};
    type _entry;
};

}  // namespace _MaintenanceProcedure

struct MaintenanceProcedure
{
    static constexpr auto L = level::ERR;
    using ESEL = _MaintenanceProcedure::ESEL;
    using PROCEDURE = org::open_power::Common::Callout::Procedure::PROCEDURE;
    using metadata_types = std::tuple<ESEL, PROCEDURE>;

};

} // namespace Host
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Host::Error::MaintenanceProcedure>
{
    using type = org::open_power::Host::MaintenanceProcedure;
};

}

namespace example
{
namespace xyz
{
namespace openbmc_project
{
namespace Example
{
namespace Elog
{
namespace _TestErrorOne
{

struct ERRNUM
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNUM";
    using type = std::tuple<std::decay_t<decltype("ERRNUM=0x%.4X")>,uint16_t>;
    explicit constexpr ERRNUM(uint16_t a) : _entry(entry("ERRNUM=0x%.4X", a)) {};
    type _entry;
};
struct FILE_PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FILE_PATH";
    using type = std::tuple<std::decay_t<decltype("FILE_PATH=%s")>,const char*>;
    explicit constexpr FILE_PATH(const char* a) : _entry(entry("FILE_PATH=%s", a)) {};
    type _entry;
};
struct FILE_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FILE_NAME";
    using type = std::tuple<std::decay_t<decltype("FILE_NAME=%s")>,const char*>;
    explicit constexpr FILE_NAME(const char* a) : _entry(entry("FILE_NAME=%s", a)) {};
    type _entry;
};

}  // namespace _TestErrorOne

struct TestErrorOne : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Elog.TestErrorOne";
    static constexpr auto errDesc = "this is test error one";
    static constexpr auto L = level::INFO;
    using ERRNUM = _TestErrorOne::ERRNUM;
    using FILE_PATH = _TestErrorOne::FILE_PATH;
    using FILE_NAME = _TestErrorOne::FILE_NAME;
    using DEV_ADDR = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_ADDR;
    using DEV_ID = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_ID;
    using DEV_NAME = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_NAME;
    using metadata_types = std::tuple<ERRNUM, FILE_PATH, FILE_NAME, DEV_ADDR, DEV_ID, DEV_NAME>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Elog
} // namespace Example
} // namespace openbmc_project
} // namespace xyz
} // namespace example



namespace example
{
namespace xyz
{
namespace openbmc_project
{
namespace Example
{
namespace Foo
{
namespace _Foo
{

struct FOO_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FOO_DATA";
    using type = std::tuple<std::decay_t<decltype("FOO_DATA=%s")>,const char*>;
    explicit constexpr FOO_DATA(const char* a) : _entry(entry("FOO_DATA=%s", a)) {};
    type _entry;
};

}  // namespace _Foo

struct Foo : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Foo.Foo";
    static constexpr auto errDesc = "this is test error Foo";
    static constexpr auto L = level::INFO;
    using FOO_DATA = _Foo::FOO_DATA;
    using ERRNUM = example::xyz::openbmc_project::Example::Elog::TestErrorOne::ERRNUM;
    using FILE_PATH = example::xyz::openbmc_project::Example::Elog::TestErrorOne::FILE_PATH;
    using FILE_NAME = example::xyz::openbmc_project::Example::Elog::TestErrorOne::FILE_NAME;
    using DEV_ADDR = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_ADDR;
    using DEV_ID = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_ID;
    using DEV_NAME = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_NAME;
    using metadata_types = std::tuple<FOO_DATA, ERRNUM, FILE_PATH, FILE_NAME, DEV_ADDR, DEV_ID, DEV_NAME>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Foo
} // namespace Example
} // namespace openbmc_project
} // namespace xyz
} // namespace example



namespace example
{
namespace xyz
{
namespace openbmc_project
{
namespace Example
{
namespace Bar
{
namespace _Bar
{

struct BAR_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "BAR_DATA";
    using type = std::tuple<std::decay_t<decltype("BAR_DATA=%s")>,const char*>;
    explicit constexpr BAR_DATA(const char* a) : _entry(entry("BAR_DATA=%s", a)) {};
    type _entry;
};

}  // namespace _Bar

struct Bar : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Bar.Bar";
    static constexpr auto errDesc = "this is test error Bar";
    static constexpr auto L = level::INFO;
    using BAR_DATA = _Bar::BAR_DATA;
    using FOO_DATA = example::xyz::openbmc_project::Example::Foo::Foo::FOO_DATA;
    using ERRNUM = example::xyz::openbmc_project::Example::Elog::TestErrorOne::ERRNUM;
    using FILE_PATH = example::xyz::openbmc_project::Example::Elog::TestErrorOne::FILE_PATH;
    using FILE_NAME = example::xyz::openbmc_project::Example::Elog::TestErrorOne::FILE_NAME;
    using DEV_ADDR = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_ADDR;
    using DEV_ID = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_ID;
    using DEV_NAME = example::xyz::openbmc_project::Example::Elog::TestErrorTwo::DEV_NAME;
    using metadata_types = std::tuple<BAR_DATA, FOO_DATA, ERRNUM, FILE_PATH, FILE_NAME, DEV_ADDR, DEV_ID, DEV_NAME>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Bar
} // namespace Example
} // namespace openbmc_project
} // namespace xyz
} // namespace example




} // namespace logging

} // namespace phosphor
